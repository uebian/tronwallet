// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_api_2fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "core/Tron.pb.h"
#include "google/api/annotations.pb.h"
#include "core/contract/asset_issue_contract.pb.h"
#include "core/contract/account_contract.pb.h"
#include "core/contract/witness_contract.pb.h"
#include "core/contract/balance_contract.pb.h"
#include "core/contract/proposal_contract.pb.h"
#include "core/contract/storage_contract.pb.h"
#include "core/contract/exchange_contract.pb.h"
#include "core/contract/smart_contract.pb.h"
#include "core/contract/shield_contract.pb.h"
#include "core/contract/market_contract.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_api_2fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fapi_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[78]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_api_2fapi_2eproto;
namespace protocol {
class AccountNetMessage;
struct AccountNetMessageDefaultTypeInternal;
extern AccountNetMessageDefaultTypeInternal _AccountNetMessage_default_instance_;
class AccountNetMessage_AssetNetLimitEntry_DoNotUse;
struct AccountNetMessage_AssetNetLimitEntry_DoNotUseDefaultTypeInternal;
extern AccountNetMessage_AssetNetLimitEntry_DoNotUseDefaultTypeInternal _AccountNetMessage_AssetNetLimitEntry_DoNotUse_default_instance_;
class AccountNetMessage_AssetNetUsedEntry_DoNotUse;
struct AccountNetMessage_AssetNetUsedEntry_DoNotUseDefaultTypeInternal;
extern AccountNetMessage_AssetNetUsedEntry_DoNotUseDefaultTypeInternal _AccountNetMessage_AssetNetUsedEntry_DoNotUse_default_instance_;
class AccountPaginated;
struct AccountPaginatedDefaultTypeInternal;
extern AccountPaginatedDefaultTypeInternal _AccountPaginated_default_instance_;
class AccountResourceMessage;
struct AccountResourceMessageDefaultTypeInternal;
extern AccountResourceMessageDefaultTypeInternal _AccountResourceMessage_default_instance_;
class AccountResourceMessage_AssetNetLimitEntry_DoNotUse;
struct AccountResourceMessage_AssetNetLimitEntry_DoNotUseDefaultTypeInternal;
extern AccountResourceMessage_AssetNetLimitEntry_DoNotUseDefaultTypeInternal _AccountResourceMessage_AssetNetLimitEntry_DoNotUse_default_instance_;
class AccountResourceMessage_AssetNetUsedEntry_DoNotUse;
struct AccountResourceMessage_AssetNetUsedEntry_DoNotUseDefaultTypeInternal;
extern AccountResourceMessage_AssetNetUsedEntry_DoNotUseDefaultTypeInternal _AccountResourceMessage_AssetNetUsedEntry_DoNotUse_default_instance_;
class Address;
struct AddressDefaultTypeInternal;
extern AddressDefaultTypeInternal _Address_default_instance_;
class AddressPrKeyPairMessage;
struct AddressPrKeyPairMessageDefaultTypeInternal;
extern AddressPrKeyPairMessageDefaultTypeInternal _AddressPrKeyPairMessage_default_instance_;
class AssetIssueList;
struct AssetIssueListDefaultTypeInternal;
extern AssetIssueListDefaultTypeInternal _AssetIssueList_default_instance_;
class BlockExtention;
struct BlockExtentionDefaultTypeInternal;
extern BlockExtentionDefaultTypeInternal _BlockExtention_default_instance_;
class BlockIncrementalMerkleTree;
struct BlockIncrementalMerkleTreeDefaultTypeInternal;
extern BlockIncrementalMerkleTreeDefaultTypeInternal _BlockIncrementalMerkleTree_default_instance_;
class BlockLimit;
struct BlockLimitDefaultTypeInternal;
extern BlockLimitDefaultTypeInternal _BlockLimit_default_instance_;
class BlockList;
struct BlockListDefaultTypeInternal;
extern BlockListDefaultTypeInternal _BlockList_default_instance_;
class BlockListExtention;
struct BlockListExtentionDefaultTypeInternal;
extern BlockListExtentionDefaultTypeInternal _BlockListExtention_default_instance_;
class BlockReference;
struct BlockReferenceDefaultTypeInternal;
extern BlockReferenceDefaultTypeInternal _BlockReference_default_instance_;
class BytesMessage;
struct BytesMessageDefaultTypeInternal;
extern BytesMessageDefaultTypeInternal _BytesMessage_default_instance_;
class DecryptNotes;
struct DecryptNotesDefaultTypeInternal;
extern DecryptNotesDefaultTypeInternal _DecryptNotes_default_instance_;
class DecryptNotesMarked;
struct DecryptNotesMarkedDefaultTypeInternal;
extern DecryptNotesMarkedDefaultTypeInternal _DecryptNotesMarked_default_instance_;
class DecryptNotesMarked_NoteTx;
struct DecryptNotesMarked_NoteTxDefaultTypeInternal;
extern DecryptNotesMarked_NoteTxDefaultTypeInternal _DecryptNotesMarked_NoteTx_default_instance_;
class DecryptNotesTRC20;
struct DecryptNotesTRC20DefaultTypeInternal;
extern DecryptNotesTRC20DefaultTypeInternal _DecryptNotesTRC20_default_instance_;
class DecryptNotesTRC20_NoteTx;
struct DecryptNotesTRC20_NoteTxDefaultTypeInternal;
extern DecryptNotesTRC20_NoteTxDefaultTypeInternal _DecryptNotesTRC20_NoteTx_default_instance_;
class DecryptNotes_NoteTx;
struct DecryptNotes_NoteTxDefaultTypeInternal;
extern DecryptNotes_NoteTxDefaultTypeInternal _DecryptNotes_NoteTx_default_instance_;
class DelegatedResourceList;
struct DelegatedResourceListDefaultTypeInternal;
extern DelegatedResourceListDefaultTypeInternal _DelegatedResourceList_default_instance_;
class DelegatedResourceMessage;
struct DelegatedResourceMessageDefaultTypeInternal;
extern DelegatedResourceMessageDefaultTypeInternal _DelegatedResourceMessage_default_instance_;
class DiversifierMessage;
struct DiversifierMessageDefaultTypeInternal;
extern DiversifierMessageDefaultTypeInternal _DiversifierMessage_default_instance_;
class EasyTransferAssetByPrivateMessage;
struct EasyTransferAssetByPrivateMessageDefaultTypeInternal;
extern EasyTransferAssetByPrivateMessageDefaultTypeInternal _EasyTransferAssetByPrivateMessage_default_instance_;
class EasyTransferAssetMessage;
struct EasyTransferAssetMessageDefaultTypeInternal;
extern EasyTransferAssetMessageDefaultTypeInternal _EasyTransferAssetMessage_default_instance_;
class EasyTransferByPrivateMessage;
struct EasyTransferByPrivateMessageDefaultTypeInternal;
extern EasyTransferByPrivateMessageDefaultTypeInternal _EasyTransferByPrivateMessage_default_instance_;
class EasyTransferMessage;
struct EasyTransferMessageDefaultTypeInternal;
extern EasyTransferMessageDefaultTypeInternal _EasyTransferMessage_default_instance_;
class EasyTransferResponse;
struct EasyTransferResponseDefaultTypeInternal;
extern EasyTransferResponseDefaultTypeInternal _EasyTransferResponse_default_instance_;
class EmptyMessage;
struct EmptyMessageDefaultTypeInternal;
extern EmptyMessageDefaultTypeInternal _EmptyMessage_default_instance_;
class ExchangeList;
struct ExchangeListDefaultTypeInternal;
extern ExchangeListDefaultTypeInternal _ExchangeList_default_instance_;
class ExpandedSpendingKeyMessage;
struct ExpandedSpendingKeyMessageDefaultTypeInternal;
extern ExpandedSpendingKeyMessageDefaultTypeInternal _ExpandedSpendingKeyMessage_default_instance_;
class IncomingViewingKeyDiversifierMessage;
struct IncomingViewingKeyDiversifierMessageDefaultTypeInternal;
extern IncomingViewingKeyDiversifierMessageDefaultTypeInternal _IncomingViewingKeyDiversifierMessage_default_instance_;
class IncomingViewingKeyMessage;
struct IncomingViewingKeyMessageDefaultTypeInternal;
extern IncomingViewingKeyMessageDefaultTypeInternal _IncomingViewingKeyMessage_default_instance_;
class IvkDecryptAndMarkParameters;
struct IvkDecryptAndMarkParametersDefaultTypeInternal;
extern IvkDecryptAndMarkParametersDefaultTypeInternal _IvkDecryptAndMarkParameters_default_instance_;
class IvkDecryptParameters;
struct IvkDecryptParametersDefaultTypeInternal;
extern IvkDecryptParametersDefaultTypeInternal _IvkDecryptParameters_default_instance_;
class IvkDecryptTRC20Parameters;
struct IvkDecryptTRC20ParametersDefaultTypeInternal;
extern IvkDecryptTRC20ParametersDefaultTypeInternal _IvkDecryptTRC20Parameters_default_instance_;
class NfParameters;
struct NfParametersDefaultTypeInternal;
extern NfParametersDefaultTypeInternal _NfParameters_default_instance_;
class NfTRC20Parameters;
struct NfTRC20ParametersDefaultTypeInternal;
extern NfTRC20ParametersDefaultTypeInternal _NfTRC20Parameters_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class NodeList;
struct NodeListDefaultTypeInternal;
extern NodeListDefaultTypeInternal _NodeList_default_instance_;
class Note;
struct NoteDefaultTypeInternal;
extern NoteDefaultTypeInternal _Note_default_instance_;
class NoteParameters;
struct NoteParametersDefaultTypeInternal;
extern NoteParametersDefaultTypeInternal _NoteParameters_default_instance_;
class NullifierResult;
struct NullifierResultDefaultTypeInternal;
extern NullifierResultDefaultTypeInternal _NullifierResult_default_instance_;
class NumberMessage;
struct NumberMessageDefaultTypeInternal;
extern NumberMessageDefaultTypeInternal _NumberMessage_default_instance_;
class OvkDecryptParameters;
struct OvkDecryptParametersDefaultTypeInternal;
extern OvkDecryptParametersDefaultTypeInternal _OvkDecryptParameters_default_instance_;
class OvkDecryptTRC20Parameters;
struct OvkDecryptTRC20ParametersDefaultTypeInternal;
extern OvkDecryptTRC20ParametersDefaultTypeInternal _OvkDecryptTRC20Parameters_default_instance_;
class PaginatedMessage;
struct PaginatedMessageDefaultTypeInternal;
extern PaginatedMessageDefaultTypeInternal _PaginatedMessage_default_instance_;
class PaymentAddressMessage;
struct PaymentAddressMessageDefaultTypeInternal;
extern PaymentAddressMessageDefaultTypeInternal _PaymentAddressMessage_default_instance_;
class PrivateParameters;
struct PrivateParametersDefaultTypeInternal;
extern PrivateParametersDefaultTypeInternal _PrivateParameters_default_instance_;
class PrivateParametersWithoutAsk;
struct PrivateParametersWithoutAskDefaultTypeInternal;
extern PrivateParametersWithoutAskDefaultTypeInternal _PrivateParametersWithoutAsk_default_instance_;
class PrivateShieldedTRC20Parameters;
struct PrivateShieldedTRC20ParametersDefaultTypeInternal;
extern PrivateShieldedTRC20ParametersDefaultTypeInternal _PrivateShieldedTRC20Parameters_default_instance_;
class PrivateShieldedTRC20ParametersWithoutAsk;
struct PrivateShieldedTRC20ParametersWithoutAskDefaultTypeInternal;
extern PrivateShieldedTRC20ParametersWithoutAskDefaultTypeInternal _PrivateShieldedTRC20ParametersWithoutAsk_default_instance_;
class ProposalList;
struct ProposalListDefaultTypeInternal;
extern ProposalListDefaultTypeInternal _ProposalList_default_instance_;
class ReceiveNote;
struct ReceiveNoteDefaultTypeInternal;
extern ReceiveNoteDefaultTypeInternal _ReceiveNote_default_instance_;
class Return;
struct ReturnDefaultTypeInternal;
extern ReturnDefaultTypeInternal _Return_default_instance_;
class ShieldedAddressInfo;
struct ShieldedAddressInfoDefaultTypeInternal;
extern ShieldedAddressInfoDefaultTypeInternal _ShieldedAddressInfo_default_instance_;
class ShieldedTRC20Parameters;
struct ShieldedTRC20ParametersDefaultTypeInternal;
extern ShieldedTRC20ParametersDefaultTypeInternal _ShieldedTRC20Parameters_default_instance_;
class ShieldedTRC20TriggerContractParameters;
struct ShieldedTRC20TriggerContractParametersDefaultTypeInternal;
extern ShieldedTRC20TriggerContractParametersDefaultTypeInternal _ShieldedTRC20TriggerContractParameters_default_instance_;
class SpendAuthSigParameters;
struct SpendAuthSigParametersDefaultTypeInternal;
extern SpendAuthSigParametersDefaultTypeInternal _SpendAuthSigParameters_default_instance_;
class SpendNote;
struct SpendNoteDefaultTypeInternal;
extern SpendNoteDefaultTypeInternal _SpendNote_default_instance_;
class SpendNoteTRC20;
struct SpendNoteTRC20DefaultTypeInternal;
extern SpendNoteTRC20DefaultTypeInternal _SpendNoteTRC20_default_instance_;
class SpendResult;
struct SpendResultDefaultTypeInternal;
extern SpendResultDefaultTypeInternal _SpendResult_default_instance_;
class TimeMessage;
struct TimeMessageDefaultTypeInternal;
extern TimeMessageDefaultTypeInternal _TimeMessage_default_instance_;
class TimePaginatedMessage;
struct TimePaginatedMessageDefaultTypeInternal;
extern TimePaginatedMessageDefaultTypeInternal _TimePaginatedMessage_default_instance_;
class TransactionApprovedList;
struct TransactionApprovedListDefaultTypeInternal;
extern TransactionApprovedListDefaultTypeInternal _TransactionApprovedList_default_instance_;
class TransactionApprovedList_Result;
struct TransactionApprovedList_ResultDefaultTypeInternal;
extern TransactionApprovedList_ResultDefaultTypeInternal _TransactionApprovedList_Result_default_instance_;
class TransactionExtention;
struct TransactionExtentionDefaultTypeInternal;
extern TransactionExtentionDefaultTypeInternal _TransactionExtention_default_instance_;
class TransactionInfoList;
struct TransactionInfoListDefaultTypeInternal;
extern TransactionInfoListDefaultTypeInternal _TransactionInfoList_default_instance_;
class TransactionLimit;
struct TransactionLimitDefaultTypeInternal;
extern TransactionLimitDefaultTypeInternal _TransactionLimit_default_instance_;
class TransactionList;
struct TransactionListDefaultTypeInternal;
extern TransactionListDefaultTypeInternal _TransactionList_default_instance_;
class TransactionListExtention;
struct TransactionListExtentionDefaultTypeInternal;
extern TransactionListExtentionDefaultTypeInternal _TransactionListExtention_default_instance_;
class TransactionSignWeight;
struct TransactionSignWeightDefaultTypeInternal;
extern TransactionSignWeightDefaultTypeInternal _TransactionSignWeight_default_instance_;
class TransactionSignWeight_Result;
struct TransactionSignWeight_ResultDefaultTypeInternal;
extern TransactionSignWeight_ResultDefaultTypeInternal _TransactionSignWeight_Result_default_instance_;
class ViewingKeyMessage;
struct ViewingKeyMessageDefaultTypeInternal;
extern ViewingKeyMessageDefaultTypeInternal _ViewingKeyMessage_default_instance_;
class WitnessList;
struct WitnessListDefaultTypeInternal;
extern WitnessListDefaultTypeInternal _WitnessList_default_instance_;
}  // namespace protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::protocol::AccountNetMessage* Arena::CreateMaybeMessage<::protocol::AccountNetMessage>(Arena*);
template<> ::protocol::AccountNetMessage_AssetNetLimitEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::AccountNetMessage_AssetNetLimitEntry_DoNotUse>(Arena*);
template<> ::protocol::AccountNetMessage_AssetNetUsedEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::AccountNetMessage_AssetNetUsedEntry_DoNotUse>(Arena*);
template<> ::protocol::AccountPaginated* Arena::CreateMaybeMessage<::protocol::AccountPaginated>(Arena*);
template<> ::protocol::AccountResourceMessage* Arena::CreateMaybeMessage<::protocol::AccountResourceMessage>(Arena*);
template<> ::protocol::AccountResourceMessage_AssetNetLimitEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::AccountResourceMessage_AssetNetLimitEntry_DoNotUse>(Arena*);
template<> ::protocol::AccountResourceMessage_AssetNetUsedEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::AccountResourceMessage_AssetNetUsedEntry_DoNotUse>(Arena*);
template<> ::protocol::Address* Arena::CreateMaybeMessage<::protocol::Address>(Arena*);
template<> ::protocol::AddressPrKeyPairMessage* Arena::CreateMaybeMessage<::protocol::AddressPrKeyPairMessage>(Arena*);
template<> ::protocol::AssetIssueList* Arena::CreateMaybeMessage<::protocol::AssetIssueList>(Arena*);
template<> ::protocol::BlockExtention* Arena::CreateMaybeMessage<::protocol::BlockExtention>(Arena*);
template<> ::protocol::BlockIncrementalMerkleTree* Arena::CreateMaybeMessage<::protocol::BlockIncrementalMerkleTree>(Arena*);
template<> ::protocol::BlockLimit* Arena::CreateMaybeMessage<::protocol::BlockLimit>(Arena*);
template<> ::protocol::BlockList* Arena::CreateMaybeMessage<::protocol::BlockList>(Arena*);
template<> ::protocol::BlockListExtention* Arena::CreateMaybeMessage<::protocol::BlockListExtention>(Arena*);
template<> ::protocol::BlockReference* Arena::CreateMaybeMessage<::protocol::BlockReference>(Arena*);
template<> ::protocol::BytesMessage* Arena::CreateMaybeMessage<::protocol::BytesMessage>(Arena*);
template<> ::protocol::DecryptNotes* Arena::CreateMaybeMessage<::protocol::DecryptNotes>(Arena*);
template<> ::protocol::DecryptNotesMarked* Arena::CreateMaybeMessage<::protocol::DecryptNotesMarked>(Arena*);
template<> ::protocol::DecryptNotesMarked_NoteTx* Arena::CreateMaybeMessage<::protocol::DecryptNotesMarked_NoteTx>(Arena*);
template<> ::protocol::DecryptNotesTRC20* Arena::CreateMaybeMessage<::protocol::DecryptNotesTRC20>(Arena*);
template<> ::protocol::DecryptNotesTRC20_NoteTx* Arena::CreateMaybeMessage<::protocol::DecryptNotesTRC20_NoteTx>(Arena*);
template<> ::protocol::DecryptNotes_NoteTx* Arena::CreateMaybeMessage<::protocol::DecryptNotes_NoteTx>(Arena*);
template<> ::protocol::DelegatedResourceList* Arena::CreateMaybeMessage<::protocol::DelegatedResourceList>(Arena*);
template<> ::protocol::DelegatedResourceMessage* Arena::CreateMaybeMessage<::protocol::DelegatedResourceMessage>(Arena*);
template<> ::protocol::DiversifierMessage* Arena::CreateMaybeMessage<::protocol::DiversifierMessage>(Arena*);
template<> ::protocol::EasyTransferAssetByPrivateMessage* Arena::CreateMaybeMessage<::protocol::EasyTransferAssetByPrivateMessage>(Arena*);
template<> ::protocol::EasyTransferAssetMessage* Arena::CreateMaybeMessage<::protocol::EasyTransferAssetMessage>(Arena*);
template<> ::protocol::EasyTransferByPrivateMessage* Arena::CreateMaybeMessage<::protocol::EasyTransferByPrivateMessage>(Arena*);
template<> ::protocol::EasyTransferMessage* Arena::CreateMaybeMessage<::protocol::EasyTransferMessage>(Arena*);
template<> ::protocol::EasyTransferResponse* Arena::CreateMaybeMessage<::protocol::EasyTransferResponse>(Arena*);
template<> ::protocol::EmptyMessage* Arena::CreateMaybeMessage<::protocol::EmptyMessage>(Arena*);
template<> ::protocol::ExchangeList* Arena::CreateMaybeMessage<::protocol::ExchangeList>(Arena*);
template<> ::protocol::ExpandedSpendingKeyMessage* Arena::CreateMaybeMessage<::protocol::ExpandedSpendingKeyMessage>(Arena*);
template<> ::protocol::IncomingViewingKeyDiversifierMessage* Arena::CreateMaybeMessage<::protocol::IncomingViewingKeyDiversifierMessage>(Arena*);
template<> ::protocol::IncomingViewingKeyMessage* Arena::CreateMaybeMessage<::protocol::IncomingViewingKeyMessage>(Arena*);
template<> ::protocol::IvkDecryptAndMarkParameters* Arena::CreateMaybeMessage<::protocol::IvkDecryptAndMarkParameters>(Arena*);
template<> ::protocol::IvkDecryptParameters* Arena::CreateMaybeMessage<::protocol::IvkDecryptParameters>(Arena*);
template<> ::protocol::IvkDecryptTRC20Parameters* Arena::CreateMaybeMessage<::protocol::IvkDecryptTRC20Parameters>(Arena*);
template<> ::protocol::NfParameters* Arena::CreateMaybeMessage<::protocol::NfParameters>(Arena*);
template<> ::protocol::NfTRC20Parameters* Arena::CreateMaybeMessage<::protocol::NfTRC20Parameters>(Arena*);
template<> ::protocol::Node* Arena::CreateMaybeMessage<::protocol::Node>(Arena*);
template<> ::protocol::NodeList* Arena::CreateMaybeMessage<::protocol::NodeList>(Arena*);
template<> ::protocol::Note* Arena::CreateMaybeMessage<::protocol::Note>(Arena*);
template<> ::protocol::NoteParameters* Arena::CreateMaybeMessage<::protocol::NoteParameters>(Arena*);
template<> ::protocol::NullifierResult* Arena::CreateMaybeMessage<::protocol::NullifierResult>(Arena*);
template<> ::protocol::NumberMessage* Arena::CreateMaybeMessage<::protocol::NumberMessage>(Arena*);
template<> ::protocol::OvkDecryptParameters* Arena::CreateMaybeMessage<::protocol::OvkDecryptParameters>(Arena*);
template<> ::protocol::OvkDecryptTRC20Parameters* Arena::CreateMaybeMessage<::protocol::OvkDecryptTRC20Parameters>(Arena*);
template<> ::protocol::PaginatedMessage* Arena::CreateMaybeMessage<::protocol::PaginatedMessage>(Arena*);
template<> ::protocol::PaymentAddressMessage* Arena::CreateMaybeMessage<::protocol::PaymentAddressMessage>(Arena*);
template<> ::protocol::PrivateParameters* Arena::CreateMaybeMessage<::protocol::PrivateParameters>(Arena*);
template<> ::protocol::PrivateParametersWithoutAsk* Arena::CreateMaybeMessage<::protocol::PrivateParametersWithoutAsk>(Arena*);
template<> ::protocol::PrivateShieldedTRC20Parameters* Arena::CreateMaybeMessage<::protocol::PrivateShieldedTRC20Parameters>(Arena*);
template<> ::protocol::PrivateShieldedTRC20ParametersWithoutAsk* Arena::CreateMaybeMessage<::protocol::PrivateShieldedTRC20ParametersWithoutAsk>(Arena*);
template<> ::protocol::ProposalList* Arena::CreateMaybeMessage<::protocol::ProposalList>(Arena*);
template<> ::protocol::ReceiveNote* Arena::CreateMaybeMessage<::protocol::ReceiveNote>(Arena*);
template<> ::protocol::Return* Arena::CreateMaybeMessage<::protocol::Return>(Arena*);
template<> ::protocol::ShieldedAddressInfo* Arena::CreateMaybeMessage<::protocol::ShieldedAddressInfo>(Arena*);
template<> ::protocol::ShieldedTRC20Parameters* Arena::CreateMaybeMessage<::protocol::ShieldedTRC20Parameters>(Arena*);
template<> ::protocol::ShieldedTRC20TriggerContractParameters* Arena::CreateMaybeMessage<::protocol::ShieldedTRC20TriggerContractParameters>(Arena*);
template<> ::protocol::SpendAuthSigParameters* Arena::CreateMaybeMessage<::protocol::SpendAuthSigParameters>(Arena*);
template<> ::protocol::SpendNote* Arena::CreateMaybeMessage<::protocol::SpendNote>(Arena*);
template<> ::protocol::SpendNoteTRC20* Arena::CreateMaybeMessage<::protocol::SpendNoteTRC20>(Arena*);
template<> ::protocol::SpendResult* Arena::CreateMaybeMessage<::protocol::SpendResult>(Arena*);
template<> ::protocol::TimeMessage* Arena::CreateMaybeMessage<::protocol::TimeMessage>(Arena*);
template<> ::protocol::TimePaginatedMessage* Arena::CreateMaybeMessage<::protocol::TimePaginatedMessage>(Arena*);
template<> ::protocol::TransactionApprovedList* Arena::CreateMaybeMessage<::protocol::TransactionApprovedList>(Arena*);
template<> ::protocol::TransactionApprovedList_Result* Arena::CreateMaybeMessage<::protocol::TransactionApprovedList_Result>(Arena*);
template<> ::protocol::TransactionExtention* Arena::CreateMaybeMessage<::protocol::TransactionExtention>(Arena*);
template<> ::protocol::TransactionInfoList* Arena::CreateMaybeMessage<::protocol::TransactionInfoList>(Arena*);
template<> ::protocol::TransactionLimit* Arena::CreateMaybeMessage<::protocol::TransactionLimit>(Arena*);
template<> ::protocol::TransactionList* Arena::CreateMaybeMessage<::protocol::TransactionList>(Arena*);
template<> ::protocol::TransactionListExtention* Arena::CreateMaybeMessage<::protocol::TransactionListExtention>(Arena*);
template<> ::protocol::TransactionSignWeight* Arena::CreateMaybeMessage<::protocol::TransactionSignWeight>(Arena*);
template<> ::protocol::TransactionSignWeight_Result* Arena::CreateMaybeMessage<::protocol::TransactionSignWeight_Result>(Arena*);
template<> ::protocol::ViewingKeyMessage* Arena::CreateMaybeMessage<::protocol::ViewingKeyMessage>(Arena*);
template<> ::protocol::WitnessList* Arena::CreateMaybeMessage<::protocol::WitnessList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace protocol {

enum Return_response_code : int {
  Return_response_code_SUCCESS = 0,
  Return_response_code_SIGERROR = 1,
  Return_response_code_CONTRACT_VALIDATE_ERROR = 2,
  Return_response_code_CONTRACT_EXE_ERROR = 3,
  Return_response_code_BANDWITH_ERROR = 4,
  Return_response_code_DUP_TRANSACTION_ERROR = 5,
  Return_response_code_TAPOS_ERROR = 6,
  Return_response_code_TOO_BIG_TRANSACTION_ERROR = 7,
  Return_response_code_TRANSACTION_EXPIRATION_ERROR = 8,
  Return_response_code_SERVER_BUSY = 9,
  Return_response_code_NO_CONNECTION = 10,
  Return_response_code_NOT_ENOUGH_EFFECTIVE_CONNECTION = 11,
  Return_response_code_OTHER_ERROR = 20,
  Return_response_code_Return_response_code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Return_response_code_Return_response_code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Return_response_code_IsValid(int value);
constexpr Return_response_code Return_response_code_response_code_MIN = Return_response_code_SUCCESS;
constexpr Return_response_code Return_response_code_response_code_MAX = Return_response_code_OTHER_ERROR;
constexpr int Return_response_code_response_code_ARRAYSIZE = Return_response_code_response_code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Return_response_code_descriptor();
template<typename T>
inline const std::string& Return_response_code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Return_response_code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Return_response_code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Return_response_code_descriptor(), enum_t_value);
}
inline bool Return_response_code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Return_response_code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Return_response_code>(
    Return_response_code_descriptor(), name, value);
}
enum TransactionSignWeight_Result_response_code : int {
  TransactionSignWeight_Result_response_code_ENOUGH_PERMISSION = 0,
  TransactionSignWeight_Result_response_code_NOT_ENOUGH_PERMISSION = 1,
  TransactionSignWeight_Result_response_code_SIGNATURE_FORMAT_ERROR = 2,
  TransactionSignWeight_Result_response_code_COMPUTE_ADDRESS_ERROR = 3,
  TransactionSignWeight_Result_response_code_PERMISSION_ERROR = 4,
  TransactionSignWeight_Result_response_code_OTHER_ERROR = 20,
  TransactionSignWeight_Result_response_code_TransactionSignWeight_Result_response_code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TransactionSignWeight_Result_response_code_TransactionSignWeight_Result_response_code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TransactionSignWeight_Result_response_code_IsValid(int value);
constexpr TransactionSignWeight_Result_response_code TransactionSignWeight_Result_response_code_response_code_MIN = TransactionSignWeight_Result_response_code_ENOUGH_PERMISSION;
constexpr TransactionSignWeight_Result_response_code TransactionSignWeight_Result_response_code_response_code_MAX = TransactionSignWeight_Result_response_code_OTHER_ERROR;
constexpr int TransactionSignWeight_Result_response_code_response_code_ARRAYSIZE = TransactionSignWeight_Result_response_code_response_code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionSignWeight_Result_response_code_descriptor();
template<typename T>
inline const std::string& TransactionSignWeight_Result_response_code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionSignWeight_Result_response_code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionSignWeight_Result_response_code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionSignWeight_Result_response_code_descriptor(), enum_t_value);
}
inline bool TransactionSignWeight_Result_response_code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionSignWeight_Result_response_code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionSignWeight_Result_response_code>(
    TransactionSignWeight_Result_response_code_descriptor(), name, value);
}
enum TransactionApprovedList_Result_response_code : int {
  TransactionApprovedList_Result_response_code_SUCCESS = 0,
  TransactionApprovedList_Result_response_code_SIGNATURE_FORMAT_ERROR = 1,
  TransactionApprovedList_Result_response_code_COMPUTE_ADDRESS_ERROR = 2,
  TransactionApprovedList_Result_response_code_OTHER_ERROR = 20,
  TransactionApprovedList_Result_response_code_TransactionApprovedList_Result_response_code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TransactionApprovedList_Result_response_code_TransactionApprovedList_Result_response_code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TransactionApprovedList_Result_response_code_IsValid(int value);
constexpr TransactionApprovedList_Result_response_code TransactionApprovedList_Result_response_code_response_code_MIN = TransactionApprovedList_Result_response_code_SUCCESS;
constexpr TransactionApprovedList_Result_response_code TransactionApprovedList_Result_response_code_response_code_MAX = TransactionApprovedList_Result_response_code_OTHER_ERROR;
constexpr int TransactionApprovedList_Result_response_code_response_code_ARRAYSIZE = TransactionApprovedList_Result_response_code_response_code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionApprovedList_Result_response_code_descriptor();
template<typename T>
inline const std::string& TransactionApprovedList_Result_response_code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionApprovedList_Result_response_code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionApprovedList_Result_response_code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionApprovedList_Result_response_code_descriptor(), enum_t_value);
}
inline bool TransactionApprovedList_Result_response_code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionApprovedList_Result_response_code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionApprovedList_Result_response_code>(
    TransactionApprovedList_Result_response_code_descriptor(), name, value);
}
// ===================================================================

class Return final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Return) */ {
 public:
  inline Return() : Return(nullptr) {}
  ~Return() override;
  explicit constexpr Return(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Return(const Return& from);
  Return(Return&& from) noexcept
    : Return() {
    *this = ::std::move(from);
  }

  inline Return& operator=(const Return& from) {
    CopyFrom(from);
    return *this;
  }
  inline Return& operator=(Return&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Return& default_instance() {
    return *internal_default_instance();
  }
  static inline const Return* internal_default_instance() {
    return reinterpret_cast<const Return*>(
               &_Return_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Return& a, Return& b) {
    a.Swap(&b);
  }
  inline void Swap(Return* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Return* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Return* New() const final {
    return new Return();
  }

  Return* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Return>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Return& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Return& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Return* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Return";
  }
  protected:
  explicit Return(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Return_response_code response_code;
  static constexpr response_code SUCCESS =
    Return_response_code_SUCCESS;
  static constexpr response_code SIGERROR =
    Return_response_code_SIGERROR;
  static constexpr response_code CONTRACT_VALIDATE_ERROR =
    Return_response_code_CONTRACT_VALIDATE_ERROR;
  static constexpr response_code CONTRACT_EXE_ERROR =
    Return_response_code_CONTRACT_EXE_ERROR;
  static constexpr response_code BANDWITH_ERROR =
    Return_response_code_BANDWITH_ERROR;
  static constexpr response_code DUP_TRANSACTION_ERROR =
    Return_response_code_DUP_TRANSACTION_ERROR;
  static constexpr response_code TAPOS_ERROR =
    Return_response_code_TAPOS_ERROR;
  static constexpr response_code TOO_BIG_TRANSACTION_ERROR =
    Return_response_code_TOO_BIG_TRANSACTION_ERROR;
  static constexpr response_code TRANSACTION_EXPIRATION_ERROR =
    Return_response_code_TRANSACTION_EXPIRATION_ERROR;
  static constexpr response_code SERVER_BUSY =
    Return_response_code_SERVER_BUSY;
  static constexpr response_code NO_CONNECTION =
    Return_response_code_NO_CONNECTION;
  static constexpr response_code NOT_ENOUGH_EFFECTIVE_CONNECTION =
    Return_response_code_NOT_ENOUGH_EFFECTIVE_CONNECTION;
  static constexpr response_code OTHER_ERROR =
    Return_response_code_OTHER_ERROR;
  static inline bool response_code_IsValid(int value) {
    return Return_response_code_IsValid(value);
  }
  static constexpr response_code response_code_MIN =
    Return_response_code_response_code_MIN;
  static constexpr response_code response_code_MAX =
    Return_response_code_response_code_MAX;
  static constexpr int response_code_ARRAYSIZE =
    Return_response_code_response_code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  response_code_descriptor() {
    return Return_response_code_descriptor();
  }
  template<typename T>
  static inline const std::string& response_code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, response_code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function response_code_Name.");
    return Return_response_code_Name(enum_t_value);
  }
  static inline bool response_code_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      response_code* value) {
    return Return_response_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kResultFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // bytes message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // .protocol.Return.response_code code = 2;
  void clear_code();
  ::protocol::Return_response_code code() const;
  void set_code(::protocol::Return_response_code value);
  private:
  ::protocol::Return_response_code _internal_code() const;
  void _internal_set_code(::protocol::Return_response_code value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Return)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool result_;
  int code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class BlockReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockReference) */ {
 public:
  inline BlockReference() : BlockReference(nullptr) {}
  ~BlockReference() override;
  explicit constexpr BlockReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockReference(const BlockReference& from);
  BlockReference(BlockReference&& from) noexcept
    : BlockReference() {
    *this = ::std::move(from);
  }

  inline BlockReference& operator=(const BlockReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockReference& operator=(BlockReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockReference* internal_default_instance() {
    return reinterpret_cast<const BlockReference*>(
               &_BlockReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BlockReference& a, BlockReference& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockReference* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockReference* New() const final {
    return new BlockReference();
  }

  BlockReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockReference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockReference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockReference";
  }
  protected:
  explicit BlockReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockHashFieldNumber = 2,
    kBlockNumFieldNumber = 1,
  };
  // bytes block_hash = 2;
  void clear_block_hash();
  const std::string& block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  // int64 block_num = 1;
  void clear_block_num();
  ::PROTOBUF_NAMESPACE_ID::int64 block_num() const;
  void set_block_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_block_num() const;
  void _internal_set_block_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.BlockReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
  ::PROTOBUF_NAMESPACE_ID::int64 block_num_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class WitnessList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.WitnessList) */ {
 public:
  inline WitnessList() : WitnessList(nullptr) {}
  ~WitnessList() override;
  explicit constexpr WitnessList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WitnessList(const WitnessList& from);
  WitnessList(WitnessList&& from) noexcept
    : WitnessList() {
    *this = ::std::move(from);
  }

  inline WitnessList& operator=(const WitnessList& from) {
    CopyFrom(from);
    return *this;
  }
  inline WitnessList& operator=(WitnessList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WitnessList& default_instance() {
    return *internal_default_instance();
  }
  static inline const WitnessList* internal_default_instance() {
    return reinterpret_cast<const WitnessList*>(
               &_WitnessList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(WitnessList& a, WitnessList& b) {
    a.Swap(&b);
  }
  inline void Swap(WitnessList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WitnessList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WitnessList* New() const final {
    return new WitnessList();
  }

  WitnessList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WitnessList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WitnessList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WitnessList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WitnessList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.WitnessList";
  }
  protected:
  explicit WitnessList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWitnessesFieldNumber = 1,
  };
  // repeated .protocol.Witness witnesses = 1;
  int witnesses_size() const;
  private:
  int _internal_witnesses_size() const;
  public:
  void clear_witnesses();
  ::protocol::Witness* mutable_witnesses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Witness >*
      mutable_witnesses();
  private:
  const ::protocol::Witness& _internal_witnesses(int index) const;
  ::protocol::Witness* _internal_add_witnesses();
  public:
  const ::protocol::Witness& witnesses(int index) const;
  ::protocol::Witness* add_witnesses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Witness >&
      witnesses() const;

  // @@protoc_insertion_point(class_scope:protocol.WitnessList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Witness > witnesses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ProposalList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ProposalList) */ {
 public:
  inline ProposalList() : ProposalList(nullptr) {}
  ~ProposalList() override;
  explicit constexpr ProposalList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProposalList(const ProposalList& from);
  ProposalList(ProposalList&& from) noexcept
    : ProposalList() {
    *this = ::std::move(from);
  }

  inline ProposalList& operator=(const ProposalList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposalList& operator=(ProposalList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProposalList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProposalList* internal_default_instance() {
    return reinterpret_cast<const ProposalList*>(
               &_ProposalList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ProposalList& a, ProposalList& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposalList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposalList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProposalList* New() const final {
    return new ProposalList();
  }

  ProposalList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProposalList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProposalList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProposalList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposalList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ProposalList";
  }
  protected:
  explicit ProposalList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProposalsFieldNumber = 1,
  };
  // repeated .protocol.Proposal proposals = 1;
  int proposals_size() const;
  private:
  int _internal_proposals_size() const;
  public:
  void clear_proposals();
  ::protocol::Proposal* mutable_proposals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Proposal >*
      mutable_proposals();
  private:
  const ::protocol::Proposal& _internal_proposals(int index) const;
  ::protocol::Proposal* _internal_add_proposals();
  public:
  const ::protocol::Proposal& proposals(int index) const;
  ::protocol::Proposal* add_proposals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Proposal >&
      proposals() const;

  // @@protoc_insertion_point(class_scope:protocol.ProposalList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Proposal > proposals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ExchangeList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ExchangeList) */ {
 public:
  inline ExchangeList() : ExchangeList(nullptr) {}
  ~ExchangeList() override;
  explicit constexpr ExchangeList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangeList(const ExchangeList& from);
  ExchangeList(ExchangeList&& from) noexcept
    : ExchangeList() {
    *this = ::std::move(from);
  }

  inline ExchangeList& operator=(const ExchangeList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeList& operator=(ExchangeList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangeList* internal_default_instance() {
    return reinterpret_cast<const ExchangeList*>(
               &_ExchangeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ExchangeList& a, ExchangeList& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExchangeList* New() const final {
    return new ExchangeList();
  }

  ExchangeList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExchangeList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExchangeList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ExchangeList";
  }
  protected:
  explicit ExchangeList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExchangesFieldNumber = 1,
  };
  // repeated .protocol.Exchange exchanges = 1;
  int exchanges_size() const;
  private:
  int _internal_exchanges_size() const;
  public:
  void clear_exchanges();
  ::protocol::Exchange* mutable_exchanges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Exchange >*
      mutable_exchanges();
  private:
  const ::protocol::Exchange& _internal_exchanges(int index) const;
  ::protocol::Exchange* _internal_add_exchanges();
  public:
  const ::protocol::Exchange& exchanges(int index) const;
  ::protocol::Exchange* add_exchanges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Exchange >&
      exchanges() const;

  // @@protoc_insertion_point(class_scope:protocol.ExchangeList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Exchange > exchanges_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class AssetIssueList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AssetIssueList) */ {
 public:
  inline AssetIssueList() : AssetIssueList(nullptr) {}
  ~AssetIssueList() override;
  explicit constexpr AssetIssueList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetIssueList(const AssetIssueList& from);
  AssetIssueList(AssetIssueList&& from) noexcept
    : AssetIssueList() {
    *this = ::std::move(from);
  }

  inline AssetIssueList& operator=(const AssetIssueList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetIssueList& operator=(AssetIssueList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetIssueList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetIssueList* internal_default_instance() {
    return reinterpret_cast<const AssetIssueList*>(
               &_AssetIssueList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AssetIssueList& a, AssetIssueList& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetIssueList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetIssueList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AssetIssueList* New() const final {
    return new AssetIssueList();
  }

  AssetIssueList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AssetIssueList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssetIssueList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AssetIssueList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetIssueList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AssetIssueList";
  }
  protected:
  explicit AssetIssueList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetIssueFieldNumber = 1,
  };
  // repeated .protocol.AssetIssueContract assetIssue = 1;
  int assetissue_size() const;
  private:
  int _internal_assetissue_size() const;
  public:
  void clear_assetissue();
  ::protocol::AssetIssueContract* mutable_assetissue(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AssetIssueContract >*
      mutable_assetissue();
  private:
  const ::protocol::AssetIssueContract& _internal_assetissue(int index) const;
  ::protocol::AssetIssueContract* _internal_add_assetissue();
  public:
  const ::protocol::AssetIssueContract& assetissue(int index) const;
  ::protocol::AssetIssueContract* add_assetissue();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AssetIssueContract >&
      assetissue() const;

  // @@protoc_insertion_point(class_scope:protocol.AssetIssueList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AssetIssueContract > assetissue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class BlockList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockList) */ {
 public:
  inline BlockList() : BlockList(nullptr) {}
  ~BlockList() override;
  explicit constexpr BlockList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockList(const BlockList& from);
  BlockList(BlockList&& from) noexcept
    : BlockList() {
    *this = ::std::move(from);
  }

  inline BlockList& operator=(const BlockList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockList& operator=(BlockList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockList& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockList* internal_default_instance() {
    return reinterpret_cast<const BlockList*>(
               &_BlockList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BlockList& a, BlockList& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockList* New() const final {
    return new BlockList();
  }

  BlockList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockList";
  }
  protected:
  explicit BlockList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // repeated .protocol.Block block = 1;
  int block_size() const;
  private:
  int _internal_block_size() const;
  public:
  void clear_block();
  ::protocol::Block* mutable_block(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Block >*
      mutable_block();
  private:
  const ::protocol::Block& _internal_block(int index) const;
  ::protocol::Block* _internal_add_block();
  public:
  const ::protocol::Block& block(int index) const;
  ::protocol::Block* add_block();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Block >&
      block() const;

  // @@protoc_insertion_point(class_scope:protocol.BlockList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Block > block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class TransactionList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionList) */ {
 public:
  inline TransactionList() : TransactionList(nullptr) {}
  ~TransactionList() override;
  explicit constexpr TransactionList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionList(const TransactionList& from);
  TransactionList(TransactionList&& from) noexcept
    : TransactionList() {
    *this = ::std::move(from);
  }

  inline TransactionList& operator=(const TransactionList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionList& operator=(TransactionList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionList* internal_default_instance() {
    return reinterpret_cast<const TransactionList*>(
               &_TransactionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TransactionList& a, TransactionList& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionList* New() const final {
    return new TransactionList();
  }

  TransactionList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionList";
  }
  protected:
  explicit TransactionList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 1,
  };
  // repeated .protocol.Transaction transaction = 1;
  int transaction_size() const;
  private:
  int _internal_transaction_size() const;
  public:
  void clear_transaction();
  ::protocol::Transaction* mutable_transaction(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >*
      mutable_transaction();
  private:
  const ::protocol::Transaction& _internal_transaction(int index) const;
  ::protocol::Transaction* _internal_add_transaction();
  public:
  const ::protocol::Transaction& transaction(int index) const;
  ::protocol::Transaction* add_transaction();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >&
      transaction() const;

  // @@protoc_insertion_point(class_scope:protocol.TransactionList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction > transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class DelegatedResourceMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DelegatedResourceMessage) */ {
 public:
  inline DelegatedResourceMessage() : DelegatedResourceMessage(nullptr) {}
  ~DelegatedResourceMessage() override;
  explicit constexpr DelegatedResourceMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegatedResourceMessage(const DelegatedResourceMessage& from);
  DelegatedResourceMessage(DelegatedResourceMessage&& from) noexcept
    : DelegatedResourceMessage() {
    *this = ::std::move(from);
  }

  inline DelegatedResourceMessage& operator=(const DelegatedResourceMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegatedResourceMessage& operator=(DelegatedResourceMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegatedResourceMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegatedResourceMessage* internal_default_instance() {
    return reinterpret_cast<const DelegatedResourceMessage*>(
               &_DelegatedResourceMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DelegatedResourceMessage& a, DelegatedResourceMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegatedResourceMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegatedResourceMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DelegatedResourceMessage* New() const final {
    return new DelegatedResourceMessage();
  }

  DelegatedResourceMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DelegatedResourceMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegatedResourceMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DelegatedResourceMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegatedResourceMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DelegatedResourceMessage";
  }
  protected:
  explicit DelegatedResourceMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromAddressFieldNumber = 1,
    kToAddressFieldNumber = 2,
  };
  // bytes fromAddress = 1;
  void clear_fromaddress();
  const std::string& fromaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fromaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fromaddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_fromaddress();
  void set_allocated_fromaddress(std::string* fromaddress);
  private:
  const std::string& _internal_fromaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromaddress(const std::string& value);
  std::string* _internal_mutable_fromaddress();
  public:

  // bytes toAddress = 2;
  void clear_toaddress();
  const std::string& toaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_toaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_toaddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_toaddress();
  void set_allocated_toaddress(std::string* toaddress);
  private:
  const std::string& _internal_toaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toaddress(const std::string& value);
  std::string* _internal_mutable_toaddress();
  public:

  // @@protoc_insertion_point(class_scope:protocol.DelegatedResourceMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr toaddress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class DelegatedResourceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DelegatedResourceList) */ {
 public:
  inline DelegatedResourceList() : DelegatedResourceList(nullptr) {}
  ~DelegatedResourceList() override;
  explicit constexpr DelegatedResourceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegatedResourceList(const DelegatedResourceList& from);
  DelegatedResourceList(DelegatedResourceList&& from) noexcept
    : DelegatedResourceList() {
    *this = ::std::move(from);
  }

  inline DelegatedResourceList& operator=(const DelegatedResourceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegatedResourceList& operator=(DelegatedResourceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegatedResourceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegatedResourceList* internal_default_instance() {
    return reinterpret_cast<const DelegatedResourceList*>(
               &_DelegatedResourceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DelegatedResourceList& a, DelegatedResourceList& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegatedResourceList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegatedResourceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DelegatedResourceList* New() const final {
    return new DelegatedResourceList();
  }

  DelegatedResourceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DelegatedResourceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegatedResourceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DelegatedResourceList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegatedResourceList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DelegatedResourceList";
  }
  protected:
  explicit DelegatedResourceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelegatedResourceFieldNumber = 1,
  };
  // repeated .protocol.DelegatedResource delegatedResource = 1;
  int delegatedresource_size() const;
  private:
  int _internal_delegatedresource_size() const;
  public:
  void clear_delegatedresource();
  ::protocol::DelegatedResource* mutable_delegatedresource(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DelegatedResource >*
      mutable_delegatedresource();
  private:
  const ::protocol::DelegatedResource& _internal_delegatedresource(int index) const;
  ::protocol::DelegatedResource* _internal_add_delegatedresource();
  public:
  const ::protocol::DelegatedResource& delegatedresource(int index) const;
  ::protocol::DelegatedResource* add_delegatedresource();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DelegatedResource >&
      delegatedresource() const;

  // @@protoc_insertion_point(class_scope:protocol.DelegatedResourceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DelegatedResource > delegatedresource_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class NodeList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.NodeList) */ {
 public:
  inline NodeList() : NodeList(nullptr) {}
  ~NodeList() override;
  explicit constexpr NodeList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeList(const NodeList& from);
  NodeList(NodeList&& from) noexcept
    : NodeList() {
    *this = ::std::move(from);
  }

  inline NodeList& operator=(const NodeList& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeList& operator=(NodeList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeList& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeList* internal_default_instance() {
    return reinterpret_cast<const NodeList*>(
               &_NodeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NodeList& a, NodeList& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeList* New() const final {
    return new NodeList();
  }

  NodeList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.NodeList";
  }
  protected:
  explicit NodeList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .protocol.Node nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::protocol::Node* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Node >*
      mutable_nodes();
  private:
  const ::protocol::Node& _internal_nodes(int index) const;
  ::protocol::Node* _internal_add_nodes();
  public:
  const ::protocol::Node& nodes(int index) const;
  ::protocol::Node* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Node >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:protocol.NodeList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Node > nodes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  explicit constexpr Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const final {
    return new Node();
  }

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Node& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // .protocol.Address address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const ::protocol::Address& address() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Address* release_address();
  ::protocol::Address* mutable_address();
  void set_allocated_address(::protocol::Address* address);
  private:
  const ::protocol::Address& _internal_address() const;
  ::protocol::Address* _internal_mutable_address();
  public:
  void unsafe_arena_set_allocated_address(
      ::protocol::Address* address);
  ::protocol::Address* unsafe_arena_release_address();

  // @@protoc_insertion_point(class_scope:protocol.Node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Address* address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Address final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Address) */ {
 public:
  inline Address() : Address(nullptr) {}
  ~Address() override;
  explicit constexpr Address(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Address(const Address& from);
  Address(Address&& from) noexcept
    : Address() {
    *this = ::std::move(from);
  }

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  inline Address& operator=(Address&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Address& default_instance() {
    return *internal_default_instance();
  }
  static inline const Address* internal_default_instance() {
    return reinterpret_cast<const Address*>(
               &_Address_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Address& a, Address& b) {
    a.Swap(&b);
  }
  inline void Swap(Address* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Address* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Address* New() const final {
    return new Address();
  }

  Address* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Address>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Address& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Address& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Address* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Address";
  }
  protected:
  explicit Address(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // bytes host = 1;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_MUST_USE_RESULT std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // int32 port = 2;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Address)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class EmptyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.EmptyMessage) */ {
 public:
  inline EmptyMessage() : EmptyMessage(nullptr) {}
  ~EmptyMessage() override;
  explicit constexpr EmptyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyMessage(const EmptyMessage& from);
  EmptyMessage(EmptyMessage&& from) noexcept
    : EmptyMessage() {
    *this = ::std::move(from);
  }

  inline EmptyMessage& operator=(const EmptyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyMessage& operator=(EmptyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyMessage* internal_default_instance() {
    return reinterpret_cast<const EmptyMessage*>(
               &_EmptyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EmptyMessage& a, EmptyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmptyMessage* New() const final {
    return new EmptyMessage();
  }

  EmptyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmptyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmptyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EmptyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.EmptyMessage";
  }
  protected:
  explicit EmptyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protocol.EmptyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class NumberMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.NumberMessage) */ {
 public:
  inline NumberMessage() : NumberMessage(nullptr) {}
  ~NumberMessage() override;
  explicit constexpr NumberMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NumberMessage(const NumberMessage& from);
  NumberMessage(NumberMessage&& from) noexcept
    : NumberMessage() {
    *this = ::std::move(from);
  }

  inline NumberMessage& operator=(const NumberMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumberMessage& operator=(NumberMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumberMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const NumberMessage* internal_default_instance() {
    return reinterpret_cast<const NumberMessage*>(
               &_NumberMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(NumberMessage& a, NumberMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(NumberMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumberMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NumberMessage* New() const final {
    return new NumberMessage();
  }

  NumberMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NumberMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NumberMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NumberMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NumberMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.NumberMessage";
  }
  protected:
  explicit NumberMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumFieldNumber = 1,
  };
  // int64 num = 1;
  void clear_num();
  ::PROTOBUF_NAMESPACE_ID::int64 num() const;
  void set_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num() const;
  void _internal_set_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.NumberMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class BytesMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BytesMessage) */ {
 public:
  inline BytesMessage() : BytesMessage(nullptr) {}
  ~BytesMessage() override;
  explicit constexpr BytesMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BytesMessage(const BytesMessage& from);
  BytesMessage(BytesMessage&& from) noexcept
    : BytesMessage() {
    *this = ::std::move(from);
  }

  inline BytesMessage& operator=(const BytesMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BytesMessage& operator=(BytesMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BytesMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BytesMessage* internal_default_instance() {
    return reinterpret_cast<const BytesMessage*>(
               &_BytesMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BytesMessage& a, BytesMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BytesMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BytesMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BytesMessage* New() const final {
    return new BytesMessage();
  }

  BytesMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BytesMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BytesMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BytesMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytesMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BytesMessage";
  }
  protected:
  explicit BytesMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:protocol.BytesMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class TimeMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TimeMessage) */ {
 public:
  inline TimeMessage() : TimeMessage(nullptr) {}
  ~TimeMessage() override;
  explicit constexpr TimeMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeMessage(const TimeMessage& from);
  TimeMessage(TimeMessage&& from) noexcept
    : TimeMessage() {
    *this = ::std::move(from);
  }

  inline TimeMessage& operator=(const TimeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeMessage& operator=(TimeMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeMessage* internal_default_instance() {
    return reinterpret_cast<const TimeMessage*>(
               &_TimeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TimeMessage& a, TimeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimeMessage* New() const final {
    return new TimeMessage();
  }

  TimeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimeMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TimeMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TimeMessage";
  }
  protected:
  explicit TimeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeginInMillisecondsFieldNumber = 1,
    kEndInMillisecondsFieldNumber = 2,
  };
  // int64 beginInMilliseconds = 1;
  void clear_begininmilliseconds();
  ::PROTOBUF_NAMESPACE_ID::int64 begininmilliseconds() const;
  void set_begininmilliseconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_begininmilliseconds() const;
  void _internal_set_begininmilliseconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 endInMilliseconds = 2;
  void clear_endinmilliseconds();
  ::PROTOBUF_NAMESPACE_ID::int64 endinmilliseconds() const;
  void set_endinmilliseconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_endinmilliseconds() const;
  void _internal_set_endinmilliseconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TimeMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 begininmilliseconds_;
  ::PROTOBUF_NAMESPACE_ID::int64 endinmilliseconds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class BlockLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockLimit) */ {
 public:
  inline BlockLimit() : BlockLimit(nullptr) {}
  ~BlockLimit() override;
  explicit constexpr BlockLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockLimit(const BlockLimit& from);
  BlockLimit(BlockLimit&& from) noexcept
    : BlockLimit() {
    *this = ::std::move(from);
  }

  inline BlockLimit& operator=(const BlockLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockLimit& operator=(BlockLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockLimit* internal_default_instance() {
    return reinterpret_cast<const BlockLimit*>(
               &_BlockLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BlockLimit& a, BlockLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockLimit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockLimit* New() const final {
    return new BlockLimit();
  }

  BlockLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockLimit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockLimit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockLimit";
  }
  protected:
  explicit BlockLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartNumFieldNumber = 1,
    kEndNumFieldNumber = 2,
  };
  // int64 startNum = 1;
  void clear_startnum();
  ::PROTOBUF_NAMESPACE_ID::int64 startnum() const;
  void set_startnum(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_startnum() const;
  void _internal_set_startnum(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 endNum = 2;
  void clear_endnum();
  ::PROTOBUF_NAMESPACE_ID::int64 endnum() const;
  void set_endnum(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_endnum() const;
  void _internal_set_endnum(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.BlockLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 startnum_;
  ::PROTOBUF_NAMESPACE_ID::int64 endnum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class TransactionLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionLimit) */ {
 public:
  inline TransactionLimit() : TransactionLimit(nullptr) {}
  ~TransactionLimit() override;
  explicit constexpr TransactionLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionLimit(const TransactionLimit& from);
  TransactionLimit(TransactionLimit&& from) noexcept
    : TransactionLimit() {
    *this = ::std::move(from);
  }

  inline TransactionLimit& operator=(const TransactionLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionLimit& operator=(TransactionLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionLimit* internal_default_instance() {
    return reinterpret_cast<const TransactionLimit*>(
               &_TransactionLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TransactionLimit& a, TransactionLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionLimit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionLimit* New() const final {
    return new TransactionLimit();
  }

  TransactionLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionLimit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionLimit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionLimit";
  }
  protected:
  explicit TransactionLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionIdFieldNumber = 1,
    kLimitNumFieldNumber = 2,
  };
  // bytes transactionId = 1;
  void clear_transactionid();
  const std::string& transactionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transactionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transactionid();
  PROTOBUF_MUST_USE_RESULT std::string* release_transactionid();
  void set_allocated_transactionid(std::string* transactionid);
  private:
  const std::string& _internal_transactionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transactionid(const std::string& value);
  std::string* _internal_mutable_transactionid();
  public:

  // int64 limitNum = 2;
  void clear_limitnum();
  ::PROTOBUF_NAMESPACE_ID::int64 limitnum() const;
  void set_limitnum(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_limitnum() const;
  void _internal_set_limitnum(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TransactionLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transactionid_;
  ::PROTOBUF_NAMESPACE_ID::int64 limitnum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class AccountPaginated final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountPaginated) */ {
 public:
  inline AccountPaginated() : AccountPaginated(nullptr) {}
  ~AccountPaginated() override;
  explicit constexpr AccountPaginated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountPaginated(const AccountPaginated& from);
  AccountPaginated(AccountPaginated&& from) noexcept
    : AccountPaginated() {
    *this = ::std::move(from);
  }

  inline AccountPaginated& operator=(const AccountPaginated& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountPaginated& operator=(AccountPaginated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountPaginated& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountPaginated* internal_default_instance() {
    return reinterpret_cast<const AccountPaginated*>(
               &_AccountPaginated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AccountPaginated& a, AccountPaginated& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountPaginated* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountPaginated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountPaginated* New() const final {
    return new AccountPaginated();
  }

  AccountPaginated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountPaginated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountPaginated& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountPaginated& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountPaginated* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountPaginated";
  }
  protected:
  explicit AccountPaginated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kLimitFieldNumber = 3,
  };
  // .protocol.Account account = 1;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const ::protocol::Account& account() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Account* release_account();
  ::protocol::Account* mutable_account();
  void set_allocated_account(::protocol::Account* account);
  private:
  const ::protocol::Account& _internal_account() const;
  ::protocol::Account* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      ::protocol::Account* account);
  ::protocol::Account* unsafe_arena_release_account();

  // int64 offset = 2;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 limit = 3;
  void clear_limit();
  ::PROTOBUF_NAMESPACE_ID::int64 limit() const;
  void set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_limit() const;
  void _internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.AccountPaginated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Account* account_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  ::PROTOBUF_NAMESPACE_ID::int64 limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class TimePaginatedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TimePaginatedMessage) */ {
 public:
  inline TimePaginatedMessage() : TimePaginatedMessage(nullptr) {}
  ~TimePaginatedMessage() override;
  explicit constexpr TimePaginatedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimePaginatedMessage(const TimePaginatedMessage& from);
  TimePaginatedMessage(TimePaginatedMessage&& from) noexcept
    : TimePaginatedMessage() {
    *this = ::std::move(from);
  }

  inline TimePaginatedMessage& operator=(const TimePaginatedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimePaginatedMessage& operator=(TimePaginatedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimePaginatedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimePaginatedMessage* internal_default_instance() {
    return reinterpret_cast<const TimePaginatedMessage*>(
               &_TimePaginatedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TimePaginatedMessage& a, TimePaginatedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TimePaginatedMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimePaginatedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimePaginatedMessage* New() const final {
    return new TimePaginatedMessage();
  }

  TimePaginatedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimePaginatedMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimePaginatedMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TimePaginatedMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimePaginatedMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TimePaginatedMessage";
  }
  protected:
  explicit TimePaginatedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeMessageFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kLimitFieldNumber = 3,
  };
  // .protocol.TimeMessage timeMessage = 1;
  bool has_timemessage() const;
  private:
  bool _internal_has_timemessage() const;
  public:
  void clear_timemessage();
  const ::protocol::TimeMessage& timemessage() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::TimeMessage* release_timemessage();
  ::protocol::TimeMessage* mutable_timemessage();
  void set_allocated_timemessage(::protocol::TimeMessage* timemessage);
  private:
  const ::protocol::TimeMessage& _internal_timemessage() const;
  ::protocol::TimeMessage* _internal_mutable_timemessage();
  public:
  void unsafe_arena_set_allocated_timemessage(
      ::protocol::TimeMessage* timemessage);
  ::protocol::TimeMessage* unsafe_arena_release_timemessage();

  // int64 offset = 2;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 limit = 3;
  void clear_limit();
  ::PROTOBUF_NAMESPACE_ID::int64 limit() const;
  void set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_limit() const;
  void _internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TimePaginatedMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::TimeMessage* timemessage_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  ::PROTOBUF_NAMESPACE_ID::int64 limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class AccountNetMessage_AssetNetUsedEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountNetMessage_AssetNetUsedEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountNetMessage_AssetNetUsedEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  AccountNetMessage_AssetNetUsedEntry_DoNotUse();
  explicit constexpr AccountNetMessage_AssetNetUsedEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AccountNetMessage_AssetNetUsedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AccountNetMessage_AssetNetUsedEntry_DoNotUse& other);
  static const AccountNetMessage_AssetNetUsedEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AccountNetMessage_AssetNetUsedEntry_DoNotUse*>(&_AccountNetMessage_AssetNetUsedEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.AccountNetMessage.AssetNetUsedEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AccountNetMessage_AssetNetLimitEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountNetMessage_AssetNetLimitEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountNetMessage_AssetNetLimitEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  AccountNetMessage_AssetNetLimitEntry_DoNotUse();
  explicit constexpr AccountNetMessage_AssetNetLimitEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AccountNetMessage_AssetNetLimitEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AccountNetMessage_AssetNetLimitEntry_DoNotUse& other);
  static const AccountNetMessage_AssetNetLimitEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AccountNetMessage_AssetNetLimitEntry_DoNotUse*>(&_AccountNetMessage_AssetNetLimitEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.AccountNetMessage.AssetNetLimitEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AccountNetMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountNetMessage) */ {
 public:
  inline AccountNetMessage() : AccountNetMessage(nullptr) {}
  ~AccountNetMessage() override;
  explicit constexpr AccountNetMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountNetMessage(const AccountNetMessage& from);
  AccountNetMessage(AccountNetMessage&& from) noexcept
    : AccountNetMessage() {
    *this = ::std::move(from);
  }

  inline AccountNetMessage& operator=(const AccountNetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountNetMessage& operator=(AccountNetMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountNetMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountNetMessage* internal_default_instance() {
    return reinterpret_cast<const AccountNetMessage*>(
               &_AccountNetMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(AccountNetMessage& a, AccountNetMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountNetMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountNetMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountNetMessage* New() const final {
    return new AccountNetMessage();
  }

  AccountNetMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountNetMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountNetMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountNetMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountNetMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountNetMessage";
  }
  protected:
  explicit AccountNetMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAssetNetUsedFieldNumber = 5,
    kAssetNetLimitFieldNumber = 6,
    kFreeNetUsedFieldNumber = 1,
    kFreeNetLimitFieldNumber = 2,
    kNetUsedFieldNumber = 3,
    kNetLimitFieldNumber = 4,
    kTotalNetLimitFieldNumber = 7,
    kTotalNetWeightFieldNumber = 8,
  };
  // map<string, int64> assetNetUsed = 5;
  int assetnetused_size() const;
  private:
  int _internal_assetnetused_size() const;
  public:
  void clear_assetnetused();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_assetnetused() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_assetnetused();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
      assetnetused() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_assetnetused();

  // map<string, int64> assetNetLimit = 6;
  int assetnetlimit_size() const;
  private:
  int _internal_assetnetlimit_size() const;
  public:
  void clear_assetnetlimit();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_assetnetlimit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_assetnetlimit();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
      assetnetlimit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_assetnetlimit();

  // int64 freeNetUsed = 1;
  void clear_freenetused();
  ::PROTOBUF_NAMESPACE_ID::int64 freenetused() const;
  void set_freenetused(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_freenetused() const;
  void _internal_set_freenetused(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 freeNetLimit = 2;
  void clear_freenetlimit();
  ::PROTOBUF_NAMESPACE_ID::int64 freenetlimit() const;
  void set_freenetlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_freenetlimit() const;
  void _internal_set_freenetlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 NetUsed = 3;
  void clear_netused();
  ::PROTOBUF_NAMESPACE_ID::int64 netused() const;
  void set_netused(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_netused() const;
  void _internal_set_netused(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 NetLimit = 4;
  void clear_netlimit();
  ::PROTOBUF_NAMESPACE_ID::int64 netlimit() const;
  void set_netlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_netlimit() const;
  void _internal_set_netlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 TotalNetLimit = 7;
  void clear_totalnetlimit();
  ::PROTOBUF_NAMESPACE_ID::int64 totalnetlimit() const;
  void set_totalnetlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_totalnetlimit() const;
  void _internal_set_totalnetlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 TotalNetWeight = 8;
  void clear_totalnetweight();
  ::PROTOBUF_NAMESPACE_ID::int64 totalnetweight() const;
  void set_totalnetweight(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_totalnetweight() const;
  void _internal_set_totalnetweight(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.AccountNetMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AccountNetMessage_AssetNetUsedEntry_DoNotUse,
      std::string, ::PROTOBUF_NAMESPACE_ID::int64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> assetnetused_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AccountNetMessage_AssetNetLimitEntry_DoNotUse,
      std::string, ::PROTOBUF_NAMESPACE_ID::int64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> assetnetlimit_;
  ::PROTOBUF_NAMESPACE_ID::int64 freenetused_;
  ::PROTOBUF_NAMESPACE_ID::int64 freenetlimit_;
  ::PROTOBUF_NAMESPACE_ID::int64 netused_;
  ::PROTOBUF_NAMESPACE_ID::int64 netlimit_;
  ::PROTOBUF_NAMESPACE_ID::int64 totalnetlimit_;
  ::PROTOBUF_NAMESPACE_ID::int64 totalnetweight_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class AccountResourceMessage_AssetNetUsedEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountResourceMessage_AssetNetUsedEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountResourceMessage_AssetNetUsedEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  AccountResourceMessage_AssetNetUsedEntry_DoNotUse();
  explicit constexpr AccountResourceMessage_AssetNetUsedEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AccountResourceMessage_AssetNetUsedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AccountResourceMessage_AssetNetUsedEntry_DoNotUse& other);
  static const AccountResourceMessage_AssetNetUsedEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AccountResourceMessage_AssetNetUsedEntry_DoNotUse*>(&_AccountResourceMessage_AssetNetUsedEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.AccountResourceMessage.AssetNetUsedEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AccountResourceMessage_AssetNetLimitEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountResourceMessage_AssetNetLimitEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountResourceMessage_AssetNetLimitEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  AccountResourceMessage_AssetNetLimitEntry_DoNotUse();
  explicit constexpr AccountResourceMessage_AssetNetLimitEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AccountResourceMessage_AssetNetLimitEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AccountResourceMessage_AssetNetLimitEntry_DoNotUse& other);
  static const AccountResourceMessage_AssetNetLimitEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AccountResourceMessage_AssetNetLimitEntry_DoNotUse*>(&_AccountResourceMessage_AssetNetLimitEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.AccountResourceMessage.AssetNetLimitEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AccountResourceMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountResourceMessage) */ {
 public:
  inline AccountResourceMessage() : AccountResourceMessage(nullptr) {}
  ~AccountResourceMessage() override;
  explicit constexpr AccountResourceMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountResourceMessage(const AccountResourceMessage& from);
  AccountResourceMessage(AccountResourceMessage&& from) noexcept
    : AccountResourceMessage() {
    *this = ::std::move(from);
  }

  inline AccountResourceMessage& operator=(const AccountResourceMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountResourceMessage& operator=(AccountResourceMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountResourceMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountResourceMessage* internal_default_instance() {
    return reinterpret_cast<const AccountResourceMessage*>(
               &_AccountResourceMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(AccountResourceMessage& a, AccountResourceMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountResourceMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountResourceMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountResourceMessage* New() const final {
    return new AccountResourceMessage();
  }

  AccountResourceMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountResourceMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountResourceMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountResourceMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountResourceMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountResourceMessage";
  }
  protected:
  explicit AccountResourceMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAssetNetUsedFieldNumber = 5,
    kAssetNetLimitFieldNumber = 6,
    kFreeNetUsedFieldNumber = 1,
    kFreeNetLimitFieldNumber = 2,
    kNetUsedFieldNumber = 3,
    kNetLimitFieldNumber = 4,
    kTotalNetLimitFieldNumber = 7,
    kTotalNetWeightFieldNumber = 8,
    kTotalTronPowerWeightFieldNumber = 9,
    kTronPowerUsedFieldNumber = 10,
    kTronPowerLimitFieldNumber = 11,
    kEnergyUsedFieldNumber = 13,
    kEnergyLimitFieldNumber = 14,
    kTotalEnergyLimitFieldNumber = 15,
    kTotalEnergyWeightFieldNumber = 16,
    kStorageUsedFieldNumber = 21,
    kStorageLimitFieldNumber = 22,
  };
  // map<string, int64> assetNetUsed = 5;
  int assetnetused_size() const;
  private:
  int _internal_assetnetused_size() const;
  public:
  void clear_assetnetused();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_assetnetused() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_assetnetused();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
      assetnetused() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_assetnetused();

  // map<string, int64> assetNetLimit = 6;
  int assetnetlimit_size() const;
  private:
  int _internal_assetnetlimit_size() const;
  public:
  void clear_assetnetlimit();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_assetnetlimit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_assetnetlimit();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
      assetnetlimit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_assetnetlimit();

  // int64 freeNetUsed = 1;
  void clear_freenetused();
  ::PROTOBUF_NAMESPACE_ID::int64 freenetused() const;
  void set_freenetused(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_freenetused() const;
  void _internal_set_freenetused(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 freeNetLimit = 2;
  void clear_freenetlimit();
  ::PROTOBUF_NAMESPACE_ID::int64 freenetlimit() const;
  void set_freenetlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_freenetlimit() const;
  void _internal_set_freenetlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 NetUsed = 3;
  void clear_netused();
  ::PROTOBUF_NAMESPACE_ID::int64 netused() const;
  void set_netused(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_netused() const;
  void _internal_set_netused(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 NetLimit = 4;
  void clear_netlimit();
  ::PROTOBUF_NAMESPACE_ID::int64 netlimit() const;
  void set_netlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_netlimit() const;
  void _internal_set_netlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 TotalNetLimit = 7;
  void clear_totalnetlimit();
  ::PROTOBUF_NAMESPACE_ID::int64 totalnetlimit() const;
  void set_totalnetlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_totalnetlimit() const;
  void _internal_set_totalnetlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 TotalNetWeight = 8;
  void clear_totalnetweight();
  ::PROTOBUF_NAMESPACE_ID::int64 totalnetweight() const;
  void set_totalnetweight(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_totalnetweight() const;
  void _internal_set_totalnetweight(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 TotalTronPowerWeight = 9;
  void clear_totaltronpowerweight();
  ::PROTOBUF_NAMESPACE_ID::int64 totaltronpowerweight() const;
  void set_totaltronpowerweight(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_totaltronpowerweight() const;
  void _internal_set_totaltronpowerweight(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 tronPowerUsed = 10;
  void clear_tronpowerused();
  ::PROTOBUF_NAMESPACE_ID::int64 tronpowerused() const;
  void set_tronpowerused(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tronpowerused() const;
  void _internal_set_tronpowerused(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 tronPowerLimit = 11;
  void clear_tronpowerlimit();
  ::PROTOBUF_NAMESPACE_ID::int64 tronpowerlimit() const;
  void set_tronpowerlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tronpowerlimit() const;
  void _internal_set_tronpowerlimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 EnergyUsed = 13;
  void clear_energyused();
  ::PROTOBUF_NAMESPACE_ID::int64 energyused() const;
  void set_energyused(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_energyused() const;
  void _internal_set_energyused(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 EnergyLimit = 14;
  void clear_energylimit();
  ::PROTOBUF_NAMESPACE_ID::int64 energylimit() const;
  void set_energylimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_energylimit() const;
  void _internal_set_energylimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 TotalEnergyLimit = 15;
  void clear_totalenergylimit();
  ::PROTOBUF_NAMESPACE_ID::int64 totalenergylimit() const;
  void set_totalenergylimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_totalenergylimit() const;
  void _internal_set_totalenergylimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 TotalEnergyWeight = 16;
  void clear_totalenergyweight();
  ::PROTOBUF_NAMESPACE_ID::int64 totalenergyweight() const;
  void set_totalenergyweight(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_totalenergyweight() const;
  void _internal_set_totalenergyweight(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 storageUsed = 21;
  void clear_storageused();
  ::PROTOBUF_NAMESPACE_ID::int64 storageused() const;
  void set_storageused(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_storageused() const;
  void _internal_set_storageused(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 storageLimit = 22;
  void clear_storagelimit();
  ::PROTOBUF_NAMESPACE_ID::int64 storagelimit() const;
  void set_storagelimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_storagelimit() const;
  void _internal_set_storagelimit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.AccountResourceMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AccountResourceMessage_AssetNetUsedEntry_DoNotUse,
      std::string, ::PROTOBUF_NAMESPACE_ID::int64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> assetnetused_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AccountResourceMessage_AssetNetLimitEntry_DoNotUse,
      std::string, ::PROTOBUF_NAMESPACE_ID::int64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> assetnetlimit_;
  ::PROTOBUF_NAMESPACE_ID::int64 freenetused_;
  ::PROTOBUF_NAMESPACE_ID::int64 freenetlimit_;
  ::PROTOBUF_NAMESPACE_ID::int64 netused_;
  ::PROTOBUF_NAMESPACE_ID::int64 netlimit_;
  ::PROTOBUF_NAMESPACE_ID::int64 totalnetlimit_;
  ::PROTOBUF_NAMESPACE_ID::int64 totalnetweight_;
  ::PROTOBUF_NAMESPACE_ID::int64 totaltronpowerweight_;
  ::PROTOBUF_NAMESPACE_ID::int64 tronpowerused_;
  ::PROTOBUF_NAMESPACE_ID::int64 tronpowerlimit_;
  ::PROTOBUF_NAMESPACE_ID::int64 energyused_;
  ::PROTOBUF_NAMESPACE_ID::int64 energylimit_;
  ::PROTOBUF_NAMESPACE_ID::int64 totalenergylimit_;
  ::PROTOBUF_NAMESPACE_ID::int64 totalenergyweight_;
  ::PROTOBUF_NAMESPACE_ID::int64 storageused_;
  ::PROTOBUF_NAMESPACE_ID::int64 storagelimit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PaginatedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.PaginatedMessage) */ {
 public:
  inline PaginatedMessage() : PaginatedMessage(nullptr) {}
  ~PaginatedMessage() override;
  explicit constexpr PaginatedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaginatedMessage(const PaginatedMessage& from);
  PaginatedMessage(PaginatedMessage&& from) noexcept
    : PaginatedMessage() {
    *this = ::std::move(from);
  }

  inline PaginatedMessage& operator=(const PaginatedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaginatedMessage& operator=(PaginatedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaginatedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaginatedMessage* internal_default_instance() {
    return reinterpret_cast<const PaginatedMessage*>(
               &_PaginatedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PaginatedMessage& a, PaginatedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PaginatedMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaginatedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaginatedMessage* New() const final {
    return new PaginatedMessage();
  }

  PaginatedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaginatedMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaginatedMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PaginatedMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaginatedMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.PaginatedMessage";
  }
  protected:
  explicit PaginatedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
    kLimitFieldNumber = 2,
  };
  // int64 offset = 1;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 limit = 2;
  void clear_limit();
  ::PROTOBUF_NAMESPACE_ID::int64 limit() const;
  void set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_limit() const;
  void _internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.PaginatedMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  ::PROTOBUF_NAMESPACE_ID::int64 limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class EasyTransferMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.EasyTransferMessage) */ {
 public:
  inline EasyTransferMessage() : EasyTransferMessage(nullptr) {}
  ~EasyTransferMessage() override;
  explicit constexpr EasyTransferMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EasyTransferMessage(const EasyTransferMessage& from);
  EasyTransferMessage(EasyTransferMessage&& from) noexcept
    : EasyTransferMessage() {
    *this = ::std::move(from);
  }

  inline EasyTransferMessage& operator=(const EasyTransferMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EasyTransferMessage& operator=(EasyTransferMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EasyTransferMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EasyTransferMessage* internal_default_instance() {
    return reinterpret_cast<const EasyTransferMessage*>(
               &_EasyTransferMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(EasyTransferMessage& a, EasyTransferMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EasyTransferMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EasyTransferMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EasyTransferMessage* New() const final {
    return new EasyTransferMessage();
  }

  EasyTransferMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EasyTransferMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EasyTransferMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EasyTransferMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EasyTransferMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.EasyTransferMessage";
  }
  protected:
  explicit EasyTransferMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPassPhraseFieldNumber = 1,
    kToAddressFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // bytes passPhrase = 1;
  void clear_passphrase();
  const std::string& passphrase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passphrase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passphrase();
  PROTOBUF_MUST_USE_RESULT std::string* release_passphrase();
  void set_allocated_passphrase(std::string* passphrase);
  private:
  const std::string& _internal_passphrase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passphrase(const std::string& value);
  std::string* _internal_mutable_passphrase();
  public:

  // bytes toAddress = 2;
  void clear_toaddress();
  const std::string& toaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_toaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_toaddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_toaddress();
  void set_allocated_toaddress(std::string* toaddress);
  private:
  const std::string& _internal_toaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toaddress(const std::string& value);
  std::string* _internal_mutable_toaddress();
  public:

  // int64 amount = 3;
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::int64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.EasyTransferMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passphrase_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr toaddress_;
  ::PROTOBUF_NAMESPACE_ID::int64 amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class EasyTransferAssetMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.EasyTransferAssetMessage) */ {
 public:
  inline EasyTransferAssetMessage() : EasyTransferAssetMessage(nullptr) {}
  ~EasyTransferAssetMessage() override;
  explicit constexpr EasyTransferAssetMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EasyTransferAssetMessage(const EasyTransferAssetMessage& from);
  EasyTransferAssetMessage(EasyTransferAssetMessage&& from) noexcept
    : EasyTransferAssetMessage() {
    *this = ::std::move(from);
  }

  inline EasyTransferAssetMessage& operator=(const EasyTransferAssetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EasyTransferAssetMessage& operator=(EasyTransferAssetMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EasyTransferAssetMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EasyTransferAssetMessage* internal_default_instance() {
    return reinterpret_cast<const EasyTransferAssetMessage*>(
               &_EasyTransferAssetMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(EasyTransferAssetMessage& a, EasyTransferAssetMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EasyTransferAssetMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EasyTransferAssetMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EasyTransferAssetMessage* New() const final {
    return new EasyTransferAssetMessage();
  }

  EasyTransferAssetMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EasyTransferAssetMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EasyTransferAssetMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EasyTransferAssetMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EasyTransferAssetMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.EasyTransferAssetMessage";
  }
  protected:
  explicit EasyTransferAssetMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPassPhraseFieldNumber = 1,
    kToAddressFieldNumber = 2,
    kAssetIdFieldNumber = 3,
    kAmountFieldNumber = 4,
  };
  // bytes passPhrase = 1;
  void clear_passphrase();
  const std::string& passphrase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passphrase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passphrase();
  PROTOBUF_MUST_USE_RESULT std::string* release_passphrase();
  void set_allocated_passphrase(std::string* passphrase);
  private:
  const std::string& _internal_passphrase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passphrase(const std::string& value);
  std::string* _internal_mutable_passphrase();
  public:

  // bytes toAddress = 2;
  void clear_toaddress();
  const std::string& toaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_toaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_toaddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_toaddress();
  void set_allocated_toaddress(std::string* toaddress);
  private:
  const std::string& _internal_toaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toaddress(const std::string& value);
  std::string* _internal_mutable_toaddress();
  public:

  // string assetId = 3;
  void clear_assetid();
  const std::string& assetid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assetid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assetid();
  PROTOBUF_MUST_USE_RESULT std::string* release_assetid();
  void set_allocated_assetid(std::string* assetid);
  private:
  const std::string& _internal_assetid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assetid(const std::string& value);
  std::string* _internal_mutable_assetid();
  public:

  // int64 amount = 4;
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::int64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.EasyTransferAssetMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passphrase_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr toaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assetid_;
  ::PROTOBUF_NAMESPACE_ID::int64 amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class EasyTransferByPrivateMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.EasyTransferByPrivateMessage) */ {
 public:
  inline EasyTransferByPrivateMessage() : EasyTransferByPrivateMessage(nullptr) {}
  ~EasyTransferByPrivateMessage() override;
  explicit constexpr EasyTransferByPrivateMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EasyTransferByPrivateMessage(const EasyTransferByPrivateMessage& from);
  EasyTransferByPrivateMessage(EasyTransferByPrivateMessage&& from) noexcept
    : EasyTransferByPrivateMessage() {
    *this = ::std::move(from);
  }

  inline EasyTransferByPrivateMessage& operator=(const EasyTransferByPrivateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EasyTransferByPrivateMessage& operator=(EasyTransferByPrivateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EasyTransferByPrivateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EasyTransferByPrivateMessage* internal_default_instance() {
    return reinterpret_cast<const EasyTransferByPrivateMessage*>(
               &_EasyTransferByPrivateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(EasyTransferByPrivateMessage& a, EasyTransferByPrivateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EasyTransferByPrivateMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EasyTransferByPrivateMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EasyTransferByPrivateMessage* New() const final {
    return new EasyTransferByPrivateMessage();
  }

  EasyTransferByPrivateMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EasyTransferByPrivateMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EasyTransferByPrivateMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EasyTransferByPrivateMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EasyTransferByPrivateMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.EasyTransferByPrivateMessage";
  }
  protected:
  explicit EasyTransferByPrivateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrivateKeyFieldNumber = 1,
    kToAddressFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // bytes privateKey = 1;
  void clear_privatekey();
  const std::string& privatekey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_privatekey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_privatekey();
  PROTOBUF_MUST_USE_RESULT std::string* release_privatekey();
  void set_allocated_privatekey(std::string* privatekey);
  private:
  const std::string& _internal_privatekey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_privatekey(const std::string& value);
  std::string* _internal_mutable_privatekey();
  public:

  // bytes toAddress = 2;
  void clear_toaddress();
  const std::string& toaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_toaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_toaddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_toaddress();
  void set_allocated_toaddress(std::string* toaddress);
  private:
  const std::string& _internal_toaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toaddress(const std::string& value);
  std::string* _internal_mutable_toaddress();
  public:

  // int64 amount = 3;
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::int64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.EasyTransferByPrivateMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privatekey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr toaddress_;
  ::PROTOBUF_NAMESPACE_ID::int64 amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class EasyTransferAssetByPrivateMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.EasyTransferAssetByPrivateMessage) */ {
 public:
  inline EasyTransferAssetByPrivateMessage() : EasyTransferAssetByPrivateMessage(nullptr) {}
  ~EasyTransferAssetByPrivateMessage() override;
  explicit constexpr EasyTransferAssetByPrivateMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EasyTransferAssetByPrivateMessage(const EasyTransferAssetByPrivateMessage& from);
  EasyTransferAssetByPrivateMessage(EasyTransferAssetByPrivateMessage&& from) noexcept
    : EasyTransferAssetByPrivateMessage() {
    *this = ::std::move(from);
  }

  inline EasyTransferAssetByPrivateMessage& operator=(const EasyTransferAssetByPrivateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline EasyTransferAssetByPrivateMessage& operator=(EasyTransferAssetByPrivateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EasyTransferAssetByPrivateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const EasyTransferAssetByPrivateMessage* internal_default_instance() {
    return reinterpret_cast<const EasyTransferAssetByPrivateMessage*>(
               &_EasyTransferAssetByPrivateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(EasyTransferAssetByPrivateMessage& a, EasyTransferAssetByPrivateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(EasyTransferAssetByPrivateMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EasyTransferAssetByPrivateMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EasyTransferAssetByPrivateMessage* New() const final {
    return new EasyTransferAssetByPrivateMessage();
  }

  EasyTransferAssetByPrivateMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EasyTransferAssetByPrivateMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EasyTransferAssetByPrivateMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EasyTransferAssetByPrivateMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EasyTransferAssetByPrivateMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.EasyTransferAssetByPrivateMessage";
  }
  protected:
  explicit EasyTransferAssetByPrivateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrivateKeyFieldNumber = 1,
    kToAddressFieldNumber = 2,
    kAssetIdFieldNumber = 3,
    kAmountFieldNumber = 4,
  };
  // bytes privateKey = 1;
  void clear_privatekey();
  const std::string& privatekey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_privatekey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_privatekey();
  PROTOBUF_MUST_USE_RESULT std::string* release_privatekey();
  void set_allocated_privatekey(std::string* privatekey);
  private:
  const std::string& _internal_privatekey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_privatekey(const std::string& value);
  std::string* _internal_mutable_privatekey();
  public:

  // bytes toAddress = 2;
  void clear_toaddress();
  const std::string& toaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_toaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_toaddress();
  PROTOBUF_MUST_USE_RESULT std::string* release_toaddress();
  void set_allocated_toaddress(std::string* toaddress);
  private:
  const std::string& _internal_toaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toaddress(const std::string& value);
  std::string* _internal_mutable_toaddress();
  public:

  // string assetId = 3;
  void clear_assetid();
  const std::string& assetid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assetid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assetid();
  PROTOBUF_MUST_USE_RESULT std::string* release_assetid();
  void set_allocated_assetid(std::string* assetid);
  private:
  const std::string& _internal_assetid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assetid(const std::string& value);
  std::string* _internal_mutable_assetid();
  public:

  // int64 amount = 4;
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::int64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.EasyTransferAssetByPrivateMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privatekey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr toaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assetid_;
  ::PROTOBUF_NAMESPACE_ID::int64 amount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class EasyTransferResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.EasyTransferResponse) */ {
 public:
  inline EasyTransferResponse() : EasyTransferResponse(nullptr) {}
  ~EasyTransferResponse() override;
  explicit constexpr EasyTransferResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EasyTransferResponse(const EasyTransferResponse& from);
  EasyTransferResponse(EasyTransferResponse&& from) noexcept
    : EasyTransferResponse() {
    *this = ::std::move(from);
  }

  inline EasyTransferResponse& operator=(const EasyTransferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EasyTransferResponse& operator=(EasyTransferResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EasyTransferResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EasyTransferResponse* internal_default_instance() {
    return reinterpret_cast<const EasyTransferResponse*>(
               &_EasyTransferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(EasyTransferResponse& a, EasyTransferResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EasyTransferResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EasyTransferResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EasyTransferResponse* New() const final {
    return new EasyTransferResponse();
  }

  EasyTransferResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EasyTransferResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EasyTransferResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EasyTransferResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EasyTransferResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.EasyTransferResponse";
  }
  protected:
  explicit EasyTransferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxidFieldNumber = 3,
    kTransactionFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // bytes txid = 3;
  void clear_txid();
  const std::string& txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txid();
  PROTOBUF_MUST_USE_RESULT std::string* release_txid();
  void set_allocated_txid(std::string* txid);
  private:
  const std::string& _internal_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txid(const std::string& value);
  std::string* _internal_mutable_txid();
  public:

  // .protocol.Transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::protocol::Transaction& transaction() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Transaction* release_transaction();
  ::protocol::Transaction* mutable_transaction();
  void set_allocated_transaction(::protocol::Transaction* transaction);
  private:
  const ::protocol::Transaction& _internal_transaction() const;
  ::protocol::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::protocol::Transaction* transaction);
  ::protocol::Transaction* unsafe_arena_release_transaction();

  // .protocol.Return result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::protocol::Return& result() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Return* release_result();
  ::protocol::Return* mutable_result();
  void set_allocated_result(::protocol::Return* result);
  private:
  const ::protocol::Return& _internal_result() const;
  ::protocol::Return* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::protocol::Return* result);
  ::protocol::Return* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:protocol.EasyTransferResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txid_;
  ::protocol::Transaction* transaction_;
  ::protocol::Return* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class AddressPrKeyPairMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AddressPrKeyPairMessage) */ {
 public:
  inline AddressPrKeyPairMessage() : AddressPrKeyPairMessage(nullptr) {}
  ~AddressPrKeyPairMessage() override;
  explicit constexpr AddressPrKeyPairMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddressPrKeyPairMessage(const AddressPrKeyPairMessage& from);
  AddressPrKeyPairMessage(AddressPrKeyPairMessage&& from) noexcept
    : AddressPrKeyPairMessage() {
    *this = ::std::move(from);
  }

  inline AddressPrKeyPairMessage& operator=(const AddressPrKeyPairMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressPrKeyPairMessage& operator=(AddressPrKeyPairMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddressPrKeyPairMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddressPrKeyPairMessage* internal_default_instance() {
    return reinterpret_cast<const AddressPrKeyPairMessage*>(
               &_AddressPrKeyPairMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(AddressPrKeyPairMessage& a, AddressPrKeyPairMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressPrKeyPairMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressPrKeyPairMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddressPrKeyPairMessage* New() const final {
    return new AddressPrKeyPairMessage();
  }

  AddressPrKeyPairMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddressPrKeyPairMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddressPrKeyPairMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddressPrKeyPairMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressPrKeyPairMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AddressPrKeyPairMessage";
  }
  protected:
  explicit AddressPrKeyPairMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPrivateKeyFieldNumber = 2,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string privateKey = 2;
  void clear_privatekey();
  const std::string& privatekey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_privatekey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_privatekey();
  PROTOBUF_MUST_USE_RESULT std::string* release_privatekey();
  void set_allocated_privatekey(std::string* privatekey);
  private:
  const std::string& _internal_privatekey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_privatekey(const std::string& value);
  std::string* _internal_mutable_privatekey();
  public:

  // @@protoc_insertion_point(class_scope:protocol.AddressPrKeyPairMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privatekey_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class TransactionExtention final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionExtention) */ {
 public:
  inline TransactionExtention() : TransactionExtention(nullptr) {}
  ~TransactionExtention() override;
  explicit constexpr TransactionExtention(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionExtention(const TransactionExtention& from);
  TransactionExtention(TransactionExtention&& from) noexcept
    : TransactionExtention() {
    *this = ::std::move(from);
  }

  inline TransactionExtention& operator=(const TransactionExtention& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionExtention& operator=(TransactionExtention&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionExtention& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionExtention* internal_default_instance() {
    return reinterpret_cast<const TransactionExtention*>(
               &_TransactionExtention_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(TransactionExtention& a, TransactionExtention& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionExtention* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionExtention* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionExtention* New() const final {
    return new TransactionExtention();
  }

  TransactionExtention* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionExtention>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionExtention& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionExtention& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionExtention* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionExtention";
  }
  protected:
  explicit TransactionExtention(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstantResultFieldNumber = 3,
    kTxidFieldNumber = 2,
    kTransactionFieldNumber = 1,
    kResultFieldNumber = 4,
    kEnergyUsedFieldNumber = 5,
  };
  // repeated bytes constant_result = 3;
  int constant_result_size() const;
  private:
  int _internal_constant_result_size() const;
  public:
  void clear_constant_result();
  const std::string& constant_result(int index) const;
  std::string* mutable_constant_result(int index);
  void set_constant_result(int index, const std::string& value);
  void set_constant_result(int index, std::string&& value);
  void set_constant_result(int index, const char* value);
  void set_constant_result(int index, const void* value, size_t size);
  std::string* add_constant_result();
  void add_constant_result(const std::string& value);
  void add_constant_result(std::string&& value);
  void add_constant_result(const char* value);
  void add_constant_result(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& constant_result() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_constant_result();
  private:
  const std::string& _internal_constant_result(int index) const;
  std::string* _internal_add_constant_result();
  public:

  // bytes txid = 2;
  void clear_txid();
  const std::string& txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txid();
  PROTOBUF_MUST_USE_RESULT std::string* release_txid();
  void set_allocated_txid(std::string* txid);
  private:
  const std::string& _internal_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txid(const std::string& value);
  std::string* _internal_mutable_txid();
  public:

  // .protocol.Transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::protocol::Transaction& transaction() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Transaction* release_transaction();
  ::protocol::Transaction* mutable_transaction();
  void set_allocated_transaction(::protocol::Transaction* transaction);
  private:
  const ::protocol::Transaction& _internal_transaction() const;
  ::protocol::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::protocol::Transaction* transaction);
  ::protocol::Transaction* unsafe_arena_release_transaction();

  // .protocol.Return result = 4;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::protocol::Return& result() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Return* release_result();
  ::protocol::Return* mutable_result();
  void set_allocated_result(::protocol::Return* result);
  private:
  const ::protocol::Return& _internal_result() const;
  ::protocol::Return* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::protocol::Return* result);
  ::protocol::Return* unsafe_arena_release_result();

  // int64 energy_used = 5;
  void clear_energy_used();
  ::PROTOBUF_NAMESPACE_ID::int64 energy_used() const;
  void set_energy_used(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_energy_used() const;
  void _internal_set_energy_used(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TransactionExtention)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> constant_result_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txid_;
  ::protocol::Transaction* transaction_;
  ::protocol::Return* result_;
  ::PROTOBUF_NAMESPACE_ID::int64 energy_used_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class BlockExtention final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockExtention) */ {
 public:
  inline BlockExtention() : BlockExtention(nullptr) {}
  ~BlockExtention() override;
  explicit constexpr BlockExtention(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockExtention(const BlockExtention& from);
  BlockExtention(BlockExtention&& from) noexcept
    : BlockExtention() {
    *this = ::std::move(from);
  }

  inline BlockExtention& operator=(const BlockExtention& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockExtention& operator=(BlockExtention&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockExtention& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockExtention* internal_default_instance() {
    return reinterpret_cast<const BlockExtention*>(
               &_BlockExtention_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(BlockExtention& a, BlockExtention& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockExtention* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockExtention* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockExtention* New() const final {
    return new BlockExtention();
  }

  BlockExtention* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockExtention>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockExtention& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockExtention& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockExtention* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockExtention";
  }
  protected:
  explicit BlockExtention(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 1,
    kBlockidFieldNumber = 3,
    kBlockHeaderFieldNumber = 2,
  };
  // repeated .protocol.TransactionExtention transactions = 1;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  ::protocol::TransactionExtention* mutable_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionExtention >*
      mutable_transactions();
  private:
  const ::protocol::TransactionExtention& _internal_transactions(int index) const;
  ::protocol::TransactionExtention* _internal_add_transactions();
  public:
  const ::protocol::TransactionExtention& transactions(int index) const;
  ::protocol::TransactionExtention* add_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionExtention >&
      transactions() const;

  // bytes blockid = 3;
  void clear_blockid();
  const std::string& blockid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blockid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blockid();
  PROTOBUF_MUST_USE_RESULT std::string* release_blockid();
  void set_allocated_blockid(std::string* blockid);
  private:
  const std::string& _internal_blockid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blockid(const std::string& value);
  std::string* _internal_mutable_blockid();
  public:

  // .protocol.BlockHeader block_header = 2;
  bool has_block_header() const;
  private:
  bool _internal_has_block_header() const;
  public:
  void clear_block_header();
  const ::protocol::BlockHeader& block_header() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::BlockHeader* release_block_header();
  ::protocol::BlockHeader* mutable_block_header();
  void set_allocated_block_header(::protocol::BlockHeader* block_header);
  private:
  const ::protocol::BlockHeader& _internal_block_header() const;
  ::protocol::BlockHeader* _internal_mutable_block_header();
  public:
  void unsafe_arena_set_allocated_block_header(
      ::protocol::BlockHeader* block_header);
  ::protocol::BlockHeader* unsafe_arena_release_block_header();

  // @@protoc_insertion_point(class_scope:protocol.BlockExtention)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionExtention > transactions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blockid_;
  ::protocol::BlockHeader* block_header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class BlockListExtention final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockListExtention) */ {
 public:
  inline BlockListExtention() : BlockListExtention(nullptr) {}
  ~BlockListExtention() override;
  explicit constexpr BlockListExtention(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockListExtention(const BlockListExtention& from);
  BlockListExtention(BlockListExtention&& from) noexcept
    : BlockListExtention() {
    *this = ::std::move(from);
  }

  inline BlockListExtention& operator=(const BlockListExtention& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockListExtention& operator=(BlockListExtention&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockListExtention& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockListExtention* internal_default_instance() {
    return reinterpret_cast<const BlockListExtention*>(
               &_BlockListExtention_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(BlockListExtention& a, BlockListExtention& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockListExtention* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockListExtention* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockListExtention* New() const final {
    return new BlockListExtention();
  }

  BlockListExtention* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockListExtention>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockListExtention& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockListExtention& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockListExtention* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockListExtention";
  }
  protected:
  explicit BlockListExtention(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // repeated .protocol.BlockExtention block = 1;
  int block_size() const;
  private:
  int _internal_block_size() const;
  public:
  void clear_block();
  ::protocol::BlockExtention* mutable_block(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockExtention >*
      mutable_block();
  private:
  const ::protocol::BlockExtention& _internal_block(int index) const;
  ::protocol::BlockExtention* _internal_add_block();
  public:
  const ::protocol::BlockExtention& block(int index) const;
  ::protocol::BlockExtention* add_block();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockExtention >&
      block() const;

  // @@protoc_insertion_point(class_scope:protocol.BlockListExtention)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockExtention > block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class TransactionListExtention final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionListExtention) */ {
 public:
  inline TransactionListExtention() : TransactionListExtention(nullptr) {}
  ~TransactionListExtention() override;
  explicit constexpr TransactionListExtention(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionListExtention(const TransactionListExtention& from);
  TransactionListExtention(TransactionListExtention&& from) noexcept
    : TransactionListExtention() {
    *this = ::std::move(from);
  }

  inline TransactionListExtention& operator=(const TransactionListExtention& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionListExtention& operator=(TransactionListExtention&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionListExtention& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionListExtention* internal_default_instance() {
    return reinterpret_cast<const TransactionListExtention*>(
               &_TransactionListExtention_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(TransactionListExtention& a, TransactionListExtention& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionListExtention* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionListExtention* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionListExtention* New() const final {
    return new TransactionListExtention();
  }

  TransactionListExtention* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionListExtention>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionListExtention& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionListExtention& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionListExtention* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionListExtention";
  }
  protected:
  explicit TransactionListExtention(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 1,
  };
  // repeated .protocol.TransactionExtention transaction = 1;
  int transaction_size() const;
  private:
  int _internal_transaction_size() const;
  public:
  void clear_transaction();
  ::protocol::TransactionExtention* mutable_transaction(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionExtention >*
      mutable_transaction();
  private:
  const ::protocol::TransactionExtention& _internal_transaction(int index) const;
  ::protocol::TransactionExtention* _internal_add_transaction();
  public:
  const ::protocol::TransactionExtention& transaction(int index) const;
  ::protocol::TransactionExtention* add_transaction();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionExtention >&
      transaction() const;

  // @@protoc_insertion_point(class_scope:protocol.TransactionListExtention)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionExtention > transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class BlockIncrementalMerkleTree final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockIncrementalMerkleTree) */ {
 public:
  inline BlockIncrementalMerkleTree() : BlockIncrementalMerkleTree(nullptr) {}
  ~BlockIncrementalMerkleTree() override;
  explicit constexpr BlockIncrementalMerkleTree(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockIncrementalMerkleTree(const BlockIncrementalMerkleTree& from);
  BlockIncrementalMerkleTree(BlockIncrementalMerkleTree&& from) noexcept
    : BlockIncrementalMerkleTree() {
    *this = ::std::move(from);
  }

  inline BlockIncrementalMerkleTree& operator=(const BlockIncrementalMerkleTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockIncrementalMerkleTree& operator=(BlockIncrementalMerkleTree&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockIncrementalMerkleTree& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockIncrementalMerkleTree* internal_default_instance() {
    return reinterpret_cast<const BlockIncrementalMerkleTree*>(
               &_BlockIncrementalMerkleTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(BlockIncrementalMerkleTree& a, BlockIncrementalMerkleTree& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockIncrementalMerkleTree* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockIncrementalMerkleTree* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockIncrementalMerkleTree* New() const final {
    return new BlockIncrementalMerkleTree();
  }

  BlockIncrementalMerkleTree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockIncrementalMerkleTree>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockIncrementalMerkleTree& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockIncrementalMerkleTree& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockIncrementalMerkleTree* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockIncrementalMerkleTree";
  }
  protected:
  explicit BlockIncrementalMerkleTree(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMerkleTreeFieldNumber = 2,
    kNumberFieldNumber = 1,
  };
  // .protocol.IncrementalMerkleTree merkleTree = 2;
  bool has_merkletree() const;
  private:
  bool _internal_has_merkletree() const;
  public:
  void clear_merkletree();
  const ::protocol::IncrementalMerkleTree& merkletree() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::IncrementalMerkleTree* release_merkletree();
  ::protocol::IncrementalMerkleTree* mutable_merkletree();
  void set_allocated_merkletree(::protocol::IncrementalMerkleTree* merkletree);
  private:
  const ::protocol::IncrementalMerkleTree& _internal_merkletree() const;
  ::protocol::IncrementalMerkleTree* _internal_mutable_merkletree();
  public:
  void unsafe_arena_set_allocated_merkletree(
      ::protocol::IncrementalMerkleTree* merkletree);
  ::protocol::IncrementalMerkleTree* unsafe_arena_release_merkletree();

  // int64 number = 1;
  void clear_number();
  ::PROTOBUF_NAMESPACE_ID::int64 number() const;
  void set_number(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_number() const;
  void _internal_set_number(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.BlockIncrementalMerkleTree)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::IncrementalMerkleTree* merkletree_;
  ::PROTOBUF_NAMESPACE_ID::int64 number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class TransactionSignWeight_Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionSignWeight.Result) */ {
 public:
  inline TransactionSignWeight_Result() : TransactionSignWeight_Result(nullptr) {}
  ~TransactionSignWeight_Result() override;
  explicit constexpr TransactionSignWeight_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionSignWeight_Result(const TransactionSignWeight_Result& from);
  TransactionSignWeight_Result(TransactionSignWeight_Result&& from) noexcept
    : TransactionSignWeight_Result() {
    *this = ::std::move(from);
  }

  inline TransactionSignWeight_Result& operator=(const TransactionSignWeight_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionSignWeight_Result& operator=(TransactionSignWeight_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionSignWeight_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionSignWeight_Result* internal_default_instance() {
    return reinterpret_cast<const TransactionSignWeight_Result*>(
               &_TransactionSignWeight_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(TransactionSignWeight_Result& a, TransactionSignWeight_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionSignWeight_Result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionSignWeight_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionSignWeight_Result* New() const final {
    return new TransactionSignWeight_Result();
  }

  TransactionSignWeight_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionSignWeight_Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionSignWeight_Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionSignWeight_Result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionSignWeight_Result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionSignWeight.Result";
  }
  protected:
  explicit TransactionSignWeight_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionSignWeight_Result_response_code response_code;
  static constexpr response_code ENOUGH_PERMISSION =
    TransactionSignWeight_Result_response_code_ENOUGH_PERMISSION;
  static constexpr response_code NOT_ENOUGH_PERMISSION =
    TransactionSignWeight_Result_response_code_NOT_ENOUGH_PERMISSION;
  static constexpr response_code SIGNATURE_FORMAT_ERROR =
    TransactionSignWeight_Result_response_code_SIGNATURE_FORMAT_ERROR;
  static constexpr response_code COMPUTE_ADDRESS_ERROR =
    TransactionSignWeight_Result_response_code_COMPUTE_ADDRESS_ERROR;
  static constexpr response_code PERMISSION_ERROR =
    TransactionSignWeight_Result_response_code_PERMISSION_ERROR;
  static constexpr response_code OTHER_ERROR =
    TransactionSignWeight_Result_response_code_OTHER_ERROR;
  static inline bool response_code_IsValid(int value) {
    return TransactionSignWeight_Result_response_code_IsValid(value);
  }
  static constexpr response_code response_code_MIN =
    TransactionSignWeight_Result_response_code_response_code_MIN;
  static constexpr response_code response_code_MAX =
    TransactionSignWeight_Result_response_code_response_code_MAX;
  static constexpr int response_code_ARRAYSIZE =
    TransactionSignWeight_Result_response_code_response_code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  response_code_descriptor() {
    return TransactionSignWeight_Result_response_code_descriptor();
  }
  template<typename T>
  static inline const std::string& response_code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, response_code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function response_code_Name.");
    return TransactionSignWeight_Result_response_code_Name(enum_t_value);
  }
  static inline bool response_code_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      response_code* value) {
    return TransactionSignWeight_Result_response_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .protocol.TransactionSignWeight.Result.response_code code = 1;
  void clear_code();
  ::protocol::TransactionSignWeight_Result_response_code code() const;
  void set_code(::protocol::TransactionSignWeight_Result_response_code value);
  private:
  ::protocol::TransactionSignWeight_Result_response_code _internal_code() const;
  void _internal_set_code(::protocol::TransactionSignWeight_Result_response_code value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TransactionSignWeight.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class TransactionSignWeight final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionSignWeight) */ {
 public:
  inline TransactionSignWeight() : TransactionSignWeight(nullptr) {}
  ~TransactionSignWeight() override;
  explicit constexpr TransactionSignWeight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionSignWeight(const TransactionSignWeight& from);
  TransactionSignWeight(TransactionSignWeight&& from) noexcept
    : TransactionSignWeight() {
    *this = ::std::move(from);
  }

  inline TransactionSignWeight& operator=(const TransactionSignWeight& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionSignWeight& operator=(TransactionSignWeight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionSignWeight& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionSignWeight* internal_default_instance() {
    return reinterpret_cast<const TransactionSignWeight*>(
               &_TransactionSignWeight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(TransactionSignWeight& a, TransactionSignWeight& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionSignWeight* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionSignWeight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionSignWeight* New() const final {
    return new TransactionSignWeight();
  }

  TransactionSignWeight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionSignWeight>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionSignWeight& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionSignWeight& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionSignWeight* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionSignWeight";
  }
  protected:
  explicit TransactionSignWeight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionSignWeight_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kApprovedListFieldNumber = 2,
    kPermissionFieldNumber = 1,
    kResultFieldNumber = 4,
    kTransactionFieldNumber = 5,
    kCurrentWeightFieldNumber = 3,
  };
  // repeated bytes approved_list = 2;
  int approved_list_size() const;
  private:
  int _internal_approved_list_size() const;
  public:
  void clear_approved_list();
  const std::string& approved_list(int index) const;
  std::string* mutable_approved_list(int index);
  void set_approved_list(int index, const std::string& value);
  void set_approved_list(int index, std::string&& value);
  void set_approved_list(int index, const char* value);
  void set_approved_list(int index, const void* value, size_t size);
  std::string* add_approved_list();
  void add_approved_list(const std::string& value);
  void add_approved_list(std::string&& value);
  void add_approved_list(const char* value);
  void add_approved_list(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& approved_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_approved_list();
  private:
  const std::string& _internal_approved_list(int index) const;
  std::string* _internal_add_approved_list();
  public:

  // .protocol.Permission permission = 1;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  const ::protocol::Permission& permission() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Permission* release_permission();
  ::protocol::Permission* mutable_permission();
  void set_allocated_permission(::protocol::Permission* permission);
  private:
  const ::protocol::Permission& _internal_permission() const;
  ::protocol::Permission* _internal_mutable_permission();
  public:
  void unsafe_arena_set_allocated_permission(
      ::protocol::Permission* permission);
  ::protocol::Permission* unsafe_arena_release_permission();

  // .protocol.TransactionSignWeight.Result result = 4;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::protocol::TransactionSignWeight_Result& result() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::TransactionSignWeight_Result* release_result();
  ::protocol::TransactionSignWeight_Result* mutable_result();
  void set_allocated_result(::protocol::TransactionSignWeight_Result* result);
  private:
  const ::protocol::TransactionSignWeight_Result& _internal_result() const;
  ::protocol::TransactionSignWeight_Result* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::protocol::TransactionSignWeight_Result* result);
  ::protocol::TransactionSignWeight_Result* unsafe_arena_release_result();

  // .protocol.TransactionExtention transaction = 5;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::protocol::TransactionExtention& transaction() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::TransactionExtention* release_transaction();
  ::protocol::TransactionExtention* mutable_transaction();
  void set_allocated_transaction(::protocol::TransactionExtention* transaction);
  private:
  const ::protocol::TransactionExtention& _internal_transaction() const;
  ::protocol::TransactionExtention* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::protocol::TransactionExtention* transaction);
  ::protocol::TransactionExtention* unsafe_arena_release_transaction();

  // int64 current_weight = 3;
  void clear_current_weight();
  ::PROTOBUF_NAMESPACE_ID::int64 current_weight() const;
  void set_current_weight(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_current_weight() const;
  void _internal_set_current_weight(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TransactionSignWeight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> approved_list_;
  ::protocol::Permission* permission_;
  ::protocol::TransactionSignWeight_Result* result_;
  ::protocol::TransactionExtention* transaction_;
  ::PROTOBUF_NAMESPACE_ID::int64 current_weight_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class TransactionApprovedList_Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionApprovedList.Result) */ {
 public:
  inline TransactionApprovedList_Result() : TransactionApprovedList_Result(nullptr) {}
  ~TransactionApprovedList_Result() override;
  explicit constexpr TransactionApprovedList_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionApprovedList_Result(const TransactionApprovedList_Result& from);
  TransactionApprovedList_Result(TransactionApprovedList_Result&& from) noexcept
    : TransactionApprovedList_Result() {
    *this = ::std::move(from);
  }

  inline TransactionApprovedList_Result& operator=(const TransactionApprovedList_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionApprovedList_Result& operator=(TransactionApprovedList_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionApprovedList_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionApprovedList_Result* internal_default_instance() {
    return reinterpret_cast<const TransactionApprovedList_Result*>(
               &_TransactionApprovedList_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(TransactionApprovedList_Result& a, TransactionApprovedList_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionApprovedList_Result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionApprovedList_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionApprovedList_Result* New() const final {
    return new TransactionApprovedList_Result();
  }

  TransactionApprovedList_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionApprovedList_Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionApprovedList_Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionApprovedList_Result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionApprovedList_Result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionApprovedList.Result";
  }
  protected:
  explicit TransactionApprovedList_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionApprovedList_Result_response_code response_code;
  static constexpr response_code SUCCESS =
    TransactionApprovedList_Result_response_code_SUCCESS;
  static constexpr response_code SIGNATURE_FORMAT_ERROR =
    TransactionApprovedList_Result_response_code_SIGNATURE_FORMAT_ERROR;
  static constexpr response_code COMPUTE_ADDRESS_ERROR =
    TransactionApprovedList_Result_response_code_COMPUTE_ADDRESS_ERROR;
  static constexpr response_code OTHER_ERROR =
    TransactionApprovedList_Result_response_code_OTHER_ERROR;
  static inline bool response_code_IsValid(int value) {
    return TransactionApprovedList_Result_response_code_IsValid(value);
  }
  static constexpr response_code response_code_MIN =
    TransactionApprovedList_Result_response_code_response_code_MIN;
  static constexpr response_code response_code_MAX =
    TransactionApprovedList_Result_response_code_response_code_MAX;
  static constexpr int response_code_ARRAYSIZE =
    TransactionApprovedList_Result_response_code_response_code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  response_code_descriptor() {
    return TransactionApprovedList_Result_response_code_descriptor();
  }
  template<typename T>
  static inline const std::string& response_code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, response_code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function response_code_Name.");
    return TransactionApprovedList_Result_response_code_Name(enum_t_value);
  }
  static inline bool response_code_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      response_code* value) {
    return TransactionApprovedList_Result_response_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .protocol.TransactionApprovedList.Result.response_code code = 1;
  void clear_code();
  ::protocol::TransactionApprovedList_Result_response_code code() const;
  void set_code(::protocol::TransactionApprovedList_Result_response_code value);
  private:
  ::protocol::TransactionApprovedList_Result_response_code _internal_code() const;
  void _internal_set_code(::protocol::TransactionApprovedList_Result_response_code value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TransactionApprovedList.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class TransactionApprovedList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionApprovedList) */ {
 public:
  inline TransactionApprovedList() : TransactionApprovedList(nullptr) {}
  ~TransactionApprovedList() override;
  explicit constexpr TransactionApprovedList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionApprovedList(const TransactionApprovedList& from);
  TransactionApprovedList(TransactionApprovedList&& from) noexcept
    : TransactionApprovedList() {
    *this = ::std::move(from);
  }

  inline TransactionApprovedList& operator=(const TransactionApprovedList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionApprovedList& operator=(TransactionApprovedList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionApprovedList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionApprovedList* internal_default_instance() {
    return reinterpret_cast<const TransactionApprovedList*>(
               &_TransactionApprovedList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(TransactionApprovedList& a, TransactionApprovedList& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionApprovedList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionApprovedList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionApprovedList* New() const final {
    return new TransactionApprovedList();
  }

  TransactionApprovedList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionApprovedList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionApprovedList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionApprovedList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionApprovedList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionApprovedList";
  }
  protected:
  explicit TransactionApprovedList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionApprovedList_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kApprovedListFieldNumber = 2,
    kResultFieldNumber = 4,
    kTransactionFieldNumber = 5,
  };
  // repeated bytes approved_list = 2;
  int approved_list_size() const;
  private:
  int _internal_approved_list_size() const;
  public:
  void clear_approved_list();
  const std::string& approved_list(int index) const;
  std::string* mutable_approved_list(int index);
  void set_approved_list(int index, const std::string& value);
  void set_approved_list(int index, std::string&& value);
  void set_approved_list(int index, const char* value);
  void set_approved_list(int index, const void* value, size_t size);
  std::string* add_approved_list();
  void add_approved_list(const std::string& value);
  void add_approved_list(std::string&& value);
  void add_approved_list(const char* value);
  void add_approved_list(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& approved_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_approved_list();
  private:
  const std::string& _internal_approved_list(int index) const;
  std::string* _internal_add_approved_list();
  public:

  // .protocol.TransactionApprovedList.Result result = 4;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::protocol::TransactionApprovedList_Result& result() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::TransactionApprovedList_Result* release_result();
  ::protocol::TransactionApprovedList_Result* mutable_result();
  void set_allocated_result(::protocol::TransactionApprovedList_Result* result);
  private:
  const ::protocol::TransactionApprovedList_Result& _internal_result() const;
  ::protocol::TransactionApprovedList_Result* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::protocol::TransactionApprovedList_Result* result);
  ::protocol::TransactionApprovedList_Result* unsafe_arena_release_result();

  // .protocol.TransactionExtention transaction = 5;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::protocol::TransactionExtention& transaction() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::TransactionExtention* release_transaction();
  ::protocol::TransactionExtention* mutable_transaction();
  void set_allocated_transaction(::protocol::TransactionExtention* transaction);
  private:
  const ::protocol::TransactionExtention& _internal_transaction() const;
  ::protocol::TransactionExtention* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::protocol::TransactionExtention* transaction);
  ::protocol::TransactionExtention* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:protocol.TransactionApprovedList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> approved_list_;
  ::protocol::TransactionApprovedList_Result* result_;
  ::protocol::TransactionExtention* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class IvkDecryptParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.IvkDecryptParameters) */ {
 public:
  inline IvkDecryptParameters() : IvkDecryptParameters(nullptr) {}
  ~IvkDecryptParameters() override;
  explicit constexpr IvkDecryptParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IvkDecryptParameters(const IvkDecryptParameters& from);
  IvkDecryptParameters(IvkDecryptParameters&& from) noexcept
    : IvkDecryptParameters() {
    *this = ::std::move(from);
  }

  inline IvkDecryptParameters& operator=(const IvkDecryptParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline IvkDecryptParameters& operator=(IvkDecryptParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IvkDecryptParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const IvkDecryptParameters* internal_default_instance() {
    return reinterpret_cast<const IvkDecryptParameters*>(
               &_IvkDecryptParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(IvkDecryptParameters& a, IvkDecryptParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(IvkDecryptParameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IvkDecryptParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IvkDecryptParameters* New() const final {
    return new IvkDecryptParameters();
  }

  IvkDecryptParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IvkDecryptParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IvkDecryptParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IvkDecryptParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IvkDecryptParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.IvkDecryptParameters";
  }
  protected:
  explicit IvkDecryptParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIvkFieldNumber = 3,
    kStartBlockIndexFieldNumber = 1,
    kEndBlockIndexFieldNumber = 2,
  };
  // bytes ivk = 3;
  void clear_ivk();
  const std::string& ivk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ivk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ivk();
  PROTOBUF_MUST_USE_RESULT std::string* release_ivk();
  void set_allocated_ivk(std::string* ivk);
  private:
  const std::string& _internal_ivk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ivk(const std::string& value);
  std::string* _internal_mutable_ivk();
  public:

  // int64 start_block_index = 1;
  void clear_start_block_index();
  ::PROTOBUF_NAMESPACE_ID::int64 start_block_index() const;
  void set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_block_index() const;
  void _internal_set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 end_block_index = 2;
  void clear_end_block_index();
  ::PROTOBUF_NAMESPACE_ID::int64 end_block_index() const;
  void set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end_block_index() const;
  void _internal_set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.IvkDecryptParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ivk_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_block_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_block_index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class IvkDecryptAndMarkParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.IvkDecryptAndMarkParameters) */ {
 public:
  inline IvkDecryptAndMarkParameters() : IvkDecryptAndMarkParameters(nullptr) {}
  ~IvkDecryptAndMarkParameters() override;
  explicit constexpr IvkDecryptAndMarkParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IvkDecryptAndMarkParameters(const IvkDecryptAndMarkParameters& from);
  IvkDecryptAndMarkParameters(IvkDecryptAndMarkParameters&& from) noexcept
    : IvkDecryptAndMarkParameters() {
    *this = ::std::move(from);
  }

  inline IvkDecryptAndMarkParameters& operator=(const IvkDecryptAndMarkParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline IvkDecryptAndMarkParameters& operator=(IvkDecryptAndMarkParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IvkDecryptAndMarkParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const IvkDecryptAndMarkParameters* internal_default_instance() {
    return reinterpret_cast<const IvkDecryptAndMarkParameters*>(
               &_IvkDecryptAndMarkParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(IvkDecryptAndMarkParameters& a, IvkDecryptAndMarkParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(IvkDecryptAndMarkParameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IvkDecryptAndMarkParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IvkDecryptAndMarkParameters* New() const final {
    return new IvkDecryptAndMarkParameters();
  }

  IvkDecryptAndMarkParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IvkDecryptAndMarkParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IvkDecryptAndMarkParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IvkDecryptAndMarkParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IvkDecryptAndMarkParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.IvkDecryptAndMarkParameters";
  }
  protected:
  explicit IvkDecryptAndMarkParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAkFieldNumber = 3,
    kNkFieldNumber = 4,
    kIvkFieldNumber = 5,
    kStartBlockIndexFieldNumber = 1,
    kEndBlockIndexFieldNumber = 2,
  };
  // bytes ak = 3;
  void clear_ak();
  const std::string& ak() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ak(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ak();
  PROTOBUF_MUST_USE_RESULT std::string* release_ak();
  void set_allocated_ak(std::string* ak);
  private:
  const std::string& _internal_ak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ak(const std::string& value);
  std::string* _internal_mutable_ak();
  public:

  // bytes nk = 4;
  void clear_nk();
  const std::string& nk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nk();
  PROTOBUF_MUST_USE_RESULT std::string* release_nk();
  void set_allocated_nk(std::string* nk);
  private:
  const std::string& _internal_nk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nk(const std::string& value);
  std::string* _internal_mutable_nk();
  public:

  // bytes ivk = 5;
  void clear_ivk();
  const std::string& ivk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ivk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ivk();
  PROTOBUF_MUST_USE_RESULT std::string* release_ivk();
  void set_allocated_ivk(std::string* ivk);
  private:
  const std::string& _internal_ivk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ivk(const std::string& value);
  std::string* _internal_mutable_ivk();
  public:

  // int64 start_block_index = 1;
  void clear_start_block_index();
  ::PROTOBUF_NAMESPACE_ID::int64 start_block_index() const;
  void set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_block_index() const;
  void _internal_set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 end_block_index = 2;
  void clear_end_block_index();
  ::PROTOBUF_NAMESPACE_ID::int64 end_block_index() const;
  void set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end_block_index() const;
  void _internal_set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.IvkDecryptAndMarkParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ak_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ivk_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_block_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_block_index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class OvkDecryptParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.OvkDecryptParameters) */ {
 public:
  inline OvkDecryptParameters() : OvkDecryptParameters(nullptr) {}
  ~OvkDecryptParameters() override;
  explicit constexpr OvkDecryptParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OvkDecryptParameters(const OvkDecryptParameters& from);
  OvkDecryptParameters(OvkDecryptParameters&& from) noexcept
    : OvkDecryptParameters() {
    *this = ::std::move(from);
  }

  inline OvkDecryptParameters& operator=(const OvkDecryptParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline OvkDecryptParameters& operator=(OvkDecryptParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OvkDecryptParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const OvkDecryptParameters* internal_default_instance() {
    return reinterpret_cast<const OvkDecryptParameters*>(
               &_OvkDecryptParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(OvkDecryptParameters& a, OvkDecryptParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(OvkDecryptParameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OvkDecryptParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OvkDecryptParameters* New() const final {
    return new OvkDecryptParameters();
  }

  OvkDecryptParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OvkDecryptParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OvkDecryptParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OvkDecryptParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OvkDecryptParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.OvkDecryptParameters";
  }
  protected:
  explicit OvkDecryptParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOvkFieldNumber = 3,
    kStartBlockIndexFieldNumber = 1,
    kEndBlockIndexFieldNumber = 2,
  };
  // bytes ovk = 3;
  void clear_ovk();
  const std::string& ovk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ovk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ovk();
  PROTOBUF_MUST_USE_RESULT std::string* release_ovk();
  void set_allocated_ovk(std::string* ovk);
  private:
  const std::string& _internal_ovk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ovk(const std::string& value);
  std::string* _internal_mutable_ovk();
  public:

  // int64 start_block_index = 1;
  void clear_start_block_index();
  ::PROTOBUF_NAMESPACE_ID::int64 start_block_index() const;
  void set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_block_index() const;
  void _internal_set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 end_block_index = 2;
  void clear_end_block_index();
  ::PROTOBUF_NAMESPACE_ID::int64 end_block_index() const;
  void set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end_block_index() const;
  void _internal_set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.OvkDecryptParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ovk_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_block_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_block_index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class DecryptNotes_NoteTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DecryptNotes.NoteTx) */ {
 public:
  inline DecryptNotes_NoteTx() : DecryptNotes_NoteTx(nullptr) {}
  ~DecryptNotes_NoteTx() override;
  explicit constexpr DecryptNotes_NoteTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecryptNotes_NoteTx(const DecryptNotes_NoteTx& from);
  DecryptNotes_NoteTx(DecryptNotes_NoteTx&& from) noexcept
    : DecryptNotes_NoteTx() {
    *this = ::std::move(from);
  }

  inline DecryptNotes_NoteTx& operator=(const DecryptNotes_NoteTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecryptNotes_NoteTx& operator=(DecryptNotes_NoteTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecryptNotes_NoteTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecryptNotes_NoteTx* internal_default_instance() {
    return reinterpret_cast<const DecryptNotes_NoteTx*>(
               &_DecryptNotes_NoteTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(DecryptNotes_NoteTx& a, DecryptNotes_NoteTx& b) {
    a.Swap(&b);
  }
  inline void Swap(DecryptNotes_NoteTx* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecryptNotes_NoteTx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecryptNotes_NoteTx* New() const final {
    return new DecryptNotes_NoteTx();
  }

  DecryptNotes_NoteTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecryptNotes_NoteTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecryptNotes_NoteTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DecryptNotes_NoteTx& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecryptNotes_NoteTx* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DecryptNotes.NoteTx";
  }
  protected:
  explicit DecryptNotes_NoteTx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxidFieldNumber = 2,
    kNoteFieldNumber = 1,
    kIndexFieldNumber = 3,
  };
  // bytes txid = 2;
  void clear_txid();
  const std::string& txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txid();
  PROTOBUF_MUST_USE_RESULT std::string* release_txid();
  void set_allocated_txid(std::string* txid);
  private:
  const std::string& _internal_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txid(const std::string& value);
  std::string* _internal_mutable_txid();
  public:

  // .protocol.Note note = 1;
  bool has_note() const;
  private:
  bool _internal_has_note() const;
  public:
  void clear_note();
  const ::protocol::Note& note() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Note* release_note();
  ::protocol::Note* mutable_note();
  void set_allocated_note(::protocol::Note* note);
  private:
  const ::protocol::Note& _internal_note() const;
  ::protocol::Note* _internal_mutable_note();
  public:
  void unsafe_arena_set_allocated_note(
      ::protocol::Note* note);
  ::protocol::Note* unsafe_arena_release_note();

  // int32 index = 3;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::int32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.DecryptNotes.NoteTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txid_;
  ::protocol::Note* note_;
  ::PROTOBUF_NAMESPACE_ID::int32 index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class DecryptNotes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DecryptNotes) */ {
 public:
  inline DecryptNotes() : DecryptNotes(nullptr) {}
  ~DecryptNotes() override;
  explicit constexpr DecryptNotes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecryptNotes(const DecryptNotes& from);
  DecryptNotes(DecryptNotes&& from) noexcept
    : DecryptNotes() {
    *this = ::std::move(from);
  }

  inline DecryptNotes& operator=(const DecryptNotes& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecryptNotes& operator=(DecryptNotes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecryptNotes& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecryptNotes* internal_default_instance() {
    return reinterpret_cast<const DecryptNotes*>(
               &_DecryptNotes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(DecryptNotes& a, DecryptNotes& b) {
    a.Swap(&b);
  }
  inline void Swap(DecryptNotes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecryptNotes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecryptNotes* New() const final {
    return new DecryptNotes();
  }

  DecryptNotes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecryptNotes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecryptNotes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DecryptNotes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecryptNotes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DecryptNotes";
  }
  protected:
  explicit DecryptNotes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DecryptNotes_NoteTx NoteTx;

  // accessors -------------------------------------------------------

  enum : int {
    kNoteTxsFieldNumber = 1,
  };
  // repeated .protocol.DecryptNotes.NoteTx noteTxs = 1;
  int notetxs_size() const;
  private:
  int _internal_notetxs_size() const;
  public:
  void clear_notetxs();
  ::protocol::DecryptNotes_NoteTx* mutable_notetxs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotes_NoteTx >*
      mutable_notetxs();
  private:
  const ::protocol::DecryptNotes_NoteTx& _internal_notetxs(int index) const;
  ::protocol::DecryptNotes_NoteTx* _internal_add_notetxs();
  public:
  const ::protocol::DecryptNotes_NoteTx& notetxs(int index) const;
  ::protocol::DecryptNotes_NoteTx* add_notetxs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotes_NoteTx >&
      notetxs() const;

  // @@protoc_insertion_point(class_scope:protocol.DecryptNotes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotes_NoteTx > notetxs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class DecryptNotesMarked_NoteTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DecryptNotesMarked.NoteTx) */ {
 public:
  inline DecryptNotesMarked_NoteTx() : DecryptNotesMarked_NoteTx(nullptr) {}
  ~DecryptNotesMarked_NoteTx() override;
  explicit constexpr DecryptNotesMarked_NoteTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecryptNotesMarked_NoteTx(const DecryptNotesMarked_NoteTx& from);
  DecryptNotesMarked_NoteTx(DecryptNotesMarked_NoteTx&& from) noexcept
    : DecryptNotesMarked_NoteTx() {
    *this = ::std::move(from);
  }

  inline DecryptNotesMarked_NoteTx& operator=(const DecryptNotesMarked_NoteTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecryptNotesMarked_NoteTx& operator=(DecryptNotesMarked_NoteTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecryptNotesMarked_NoteTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecryptNotesMarked_NoteTx* internal_default_instance() {
    return reinterpret_cast<const DecryptNotesMarked_NoteTx*>(
               &_DecryptNotesMarked_NoteTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(DecryptNotesMarked_NoteTx& a, DecryptNotesMarked_NoteTx& b) {
    a.Swap(&b);
  }
  inline void Swap(DecryptNotesMarked_NoteTx* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecryptNotesMarked_NoteTx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecryptNotesMarked_NoteTx* New() const final {
    return new DecryptNotesMarked_NoteTx();
  }

  DecryptNotesMarked_NoteTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecryptNotesMarked_NoteTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecryptNotesMarked_NoteTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DecryptNotesMarked_NoteTx& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecryptNotesMarked_NoteTx* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DecryptNotesMarked.NoteTx";
  }
  protected:
  explicit DecryptNotesMarked_NoteTx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxidFieldNumber = 2,
    kNoteFieldNumber = 1,
    kIndexFieldNumber = 3,
    kIsSpendFieldNumber = 4,
  };
  // bytes txid = 2;
  void clear_txid();
  const std::string& txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txid();
  PROTOBUF_MUST_USE_RESULT std::string* release_txid();
  void set_allocated_txid(std::string* txid);
  private:
  const std::string& _internal_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txid(const std::string& value);
  std::string* _internal_mutable_txid();
  public:

  // .protocol.Note note = 1;
  bool has_note() const;
  private:
  bool _internal_has_note() const;
  public:
  void clear_note();
  const ::protocol::Note& note() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Note* release_note();
  ::protocol::Note* mutable_note();
  void set_allocated_note(::protocol::Note* note);
  private:
  const ::protocol::Note& _internal_note() const;
  ::protocol::Note* _internal_mutable_note();
  public:
  void unsafe_arena_set_allocated_note(
      ::protocol::Note* note);
  ::protocol::Note* unsafe_arena_release_note();

  // int32 index = 3;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::int32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool is_spend = 4;
  void clear_is_spend();
  bool is_spend() const;
  void set_is_spend(bool value);
  private:
  bool _internal_is_spend() const;
  void _internal_set_is_spend(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.DecryptNotesMarked.NoteTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txid_;
  ::protocol::Note* note_;
  ::PROTOBUF_NAMESPACE_ID::int32 index_;
  bool is_spend_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class DecryptNotesMarked final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DecryptNotesMarked) */ {
 public:
  inline DecryptNotesMarked() : DecryptNotesMarked(nullptr) {}
  ~DecryptNotesMarked() override;
  explicit constexpr DecryptNotesMarked(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecryptNotesMarked(const DecryptNotesMarked& from);
  DecryptNotesMarked(DecryptNotesMarked&& from) noexcept
    : DecryptNotesMarked() {
    *this = ::std::move(from);
  }

  inline DecryptNotesMarked& operator=(const DecryptNotesMarked& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecryptNotesMarked& operator=(DecryptNotesMarked&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecryptNotesMarked& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecryptNotesMarked* internal_default_instance() {
    return reinterpret_cast<const DecryptNotesMarked*>(
               &_DecryptNotesMarked_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(DecryptNotesMarked& a, DecryptNotesMarked& b) {
    a.Swap(&b);
  }
  inline void Swap(DecryptNotesMarked* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecryptNotesMarked* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecryptNotesMarked* New() const final {
    return new DecryptNotesMarked();
  }

  DecryptNotesMarked* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecryptNotesMarked>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecryptNotesMarked& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DecryptNotesMarked& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecryptNotesMarked* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DecryptNotesMarked";
  }
  protected:
  explicit DecryptNotesMarked(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DecryptNotesMarked_NoteTx NoteTx;

  // accessors -------------------------------------------------------

  enum : int {
    kNoteTxsFieldNumber = 1,
  };
  // repeated .protocol.DecryptNotesMarked.NoteTx noteTxs = 1;
  int notetxs_size() const;
  private:
  int _internal_notetxs_size() const;
  public:
  void clear_notetxs();
  ::protocol::DecryptNotesMarked_NoteTx* mutable_notetxs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotesMarked_NoteTx >*
      mutable_notetxs();
  private:
  const ::protocol::DecryptNotesMarked_NoteTx& _internal_notetxs(int index) const;
  ::protocol::DecryptNotesMarked_NoteTx* _internal_add_notetxs();
  public:
  const ::protocol::DecryptNotesMarked_NoteTx& notetxs(int index) const;
  ::protocol::DecryptNotesMarked_NoteTx* add_notetxs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotesMarked_NoteTx >&
      notetxs() const;

  // @@protoc_insertion_point(class_scope:protocol.DecryptNotesMarked)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotesMarked_NoteTx > notetxs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class Note final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Note) */ {
 public:
  inline Note() : Note(nullptr) {}
  ~Note() override;
  explicit constexpr Note(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Note(const Note& from);
  Note(Note&& from) noexcept
    : Note() {
    *this = ::std::move(from);
  }

  inline Note& operator=(const Note& from) {
    CopyFrom(from);
    return *this;
  }
  inline Note& operator=(Note&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Note& default_instance() {
    return *internal_default_instance();
  }
  static inline const Note* internal_default_instance() {
    return reinterpret_cast<const Note*>(
               &_Note_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(Note& a, Note& b) {
    a.Swap(&b);
  }
  inline void Swap(Note* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Note* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Note* New() const final {
    return new Note();
  }

  Note* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Note>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Note& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Note& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Note* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Note";
  }
  protected:
  explicit Note(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPaymentAddressFieldNumber = 2,
    kRcmFieldNumber = 3,
    kMemoFieldNumber = 4,
    kValueFieldNumber = 1,
  };
  // string payment_address = 2;
  void clear_payment_address();
  const std::string& payment_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payment_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payment_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_payment_address();
  void set_allocated_payment_address(std::string* payment_address);
  private:
  const std::string& _internal_payment_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payment_address(const std::string& value);
  std::string* _internal_mutable_payment_address();
  public:

  // bytes rcm = 3;
  void clear_rcm();
  const std::string& rcm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rcm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rcm();
  PROTOBUF_MUST_USE_RESULT std::string* release_rcm();
  void set_allocated_rcm(std::string* rcm);
  private:
  const std::string& _internal_rcm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rcm(const std::string& value);
  std::string* _internal_mutable_rcm();
  public:

  // bytes memo = 4;
  void clear_memo();
  const std::string& memo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memo();
  PROTOBUF_MUST_USE_RESULT std::string* release_memo();
  void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // int64 value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Note)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payment_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rcm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
  ::PROTOBUF_NAMESPACE_ID::int64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class SpendNote final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SpendNote) */ {
 public:
  inline SpendNote() : SpendNote(nullptr) {}
  ~SpendNote() override;
  explicit constexpr SpendNote(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpendNote(const SpendNote& from);
  SpendNote(SpendNote&& from) noexcept
    : SpendNote() {
    *this = ::std::move(from);
  }

  inline SpendNote& operator=(const SpendNote& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpendNote& operator=(SpendNote&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpendNote& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpendNote* internal_default_instance() {
    return reinterpret_cast<const SpendNote*>(
               &_SpendNote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(SpendNote& a, SpendNote& b) {
    a.Swap(&b);
  }
  inline void Swap(SpendNote* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpendNote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpendNote* New() const final {
    return new SpendNote();
  }

  SpendNote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpendNote>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpendNote& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpendNote& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpendNote* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SpendNote";
  }
  protected:
  explicit SpendNote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlphaFieldNumber = 4,
    kPathFieldNumber = 6,
    kNoteFieldNumber = 3,
    kVoucherFieldNumber = 5,
  };
  // bytes alpha = 4;
  void clear_alpha();
  const std::string& alpha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alpha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alpha();
  PROTOBUF_MUST_USE_RESULT std::string* release_alpha();
  void set_allocated_alpha(std::string* alpha);
  private:
  const std::string& _internal_alpha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alpha(const std::string& value);
  std::string* _internal_mutable_alpha();
  public:

  // bytes path = 6;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .protocol.Note note = 3;
  bool has_note() const;
  private:
  bool _internal_has_note() const;
  public:
  void clear_note();
  const ::protocol::Note& note() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Note* release_note();
  ::protocol::Note* mutable_note();
  void set_allocated_note(::protocol::Note* note);
  private:
  const ::protocol::Note& _internal_note() const;
  ::protocol::Note* _internal_mutable_note();
  public:
  void unsafe_arena_set_allocated_note(
      ::protocol::Note* note);
  ::protocol::Note* unsafe_arena_release_note();

  // .protocol.IncrementalMerkleVoucher voucher = 5;
  bool has_voucher() const;
  private:
  bool _internal_has_voucher() const;
  public:
  void clear_voucher();
  const ::protocol::IncrementalMerkleVoucher& voucher() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::IncrementalMerkleVoucher* release_voucher();
  ::protocol::IncrementalMerkleVoucher* mutable_voucher();
  void set_allocated_voucher(::protocol::IncrementalMerkleVoucher* voucher);
  private:
  const ::protocol::IncrementalMerkleVoucher& _internal_voucher() const;
  ::protocol::IncrementalMerkleVoucher* _internal_mutable_voucher();
  public:
  void unsafe_arena_set_allocated_voucher(
      ::protocol::IncrementalMerkleVoucher* voucher);
  ::protocol::IncrementalMerkleVoucher* unsafe_arena_release_voucher();

  // @@protoc_insertion_point(class_scope:protocol.SpendNote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alpha_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::protocol::Note* note_;
  ::protocol::IncrementalMerkleVoucher* voucher_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ReceiveNote final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ReceiveNote) */ {
 public:
  inline ReceiveNote() : ReceiveNote(nullptr) {}
  ~ReceiveNote() override;
  explicit constexpr ReceiveNote(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveNote(const ReceiveNote& from);
  ReceiveNote(ReceiveNote&& from) noexcept
    : ReceiveNote() {
    *this = ::std::move(from);
  }

  inline ReceiveNote& operator=(const ReceiveNote& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveNote& operator=(ReceiveNote&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveNote& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveNote* internal_default_instance() {
    return reinterpret_cast<const ReceiveNote*>(
               &_ReceiveNote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ReceiveNote& a, ReceiveNote& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveNote* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveNote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReceiveNote* New() const final {
    return new ReceiveNote();
  }

  ReceiveNote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReceiveNote>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveNote& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReceiveNote& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveNote* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ReceiveNote";
  }
  protected:
  explicit ReceiveNote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoteFieldNumber = 1,
  };
  // .protocol.Note note = 1;
  bool has_note() const;
  private:
  bool _internal_has_note() const;
  public:
  void clear_note();
  const ::protocol::Note& note() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Note* release_note();
  ::protocol::Note* mutable_note();
  void set_allocated_note(::protocol::Note* note);
  private:
  const ::protocol::Note& _internal_note() const;
  ::protocol::Note* _internal_mutable_note();
  public:
  void unsafe_arena_set_allocated_note(
      ::protocol::Note* note);
  ::protocol::Note* unsafe_arena_release_note();

  // @@protoc_insertion_point(class_scope:protocol.ReceiveNote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Note* note_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PrivateParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.PrivateParameters) */ {
 public:
  inline PrivateParameters() : PrivateParameters(nullptr) {}
  ~PrivateParameters() override;
  explicit constexpr PrivateParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivateParameters(const PrivateParameters& from);
  PrivateParameters(PrivateParameters&& from) noexcept
    : PrivateParameters() {
    *this = ::std::move(from);
  }

  inline PrivateParameters& operator=(const PrivateParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivateParameters& operator=(PrivateParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrivateParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivateParameters* internal_default_instance() {
    return reinterpret_cast<const PrivateParameters*>(
               &_PrivateParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(PrivateParameters& a, PrivateParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivateParameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivateParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrivateParameters* New() const final {
    return new PrivateParameters();
  }

  PrivateParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrivateParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrivateParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PrivateParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrivateParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.PrivateParameters";
  }
  protected:
  explicit PrivateParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShieldedSpendsFieldNumber = 6,
    kShieldedReceivesFieldNumber = 7,
    kTransparentFromAddressFieldNumber = 1,
    kAskFieldNumber = 2,
    kNskFieldNumber = 3,
    kOvkFieldNumber = 4,
    kTransparentToAddressFieldNumber = 8,
    kFromAmountFieldNumber = 5,
    kToAmountFieldNumber = 9,
    kTimeoutFieldNumber = 10,
  };
  // repeated .protocol.SpendNote shielded_spends = 6;
  int shielded_spends_size() const;
  private:
  int _internal_shielded_spends_size() const;
  public:
  void clear_shielded_spends();
  ::protocol::SpendNote* mutable_shielded_spends(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNote >*
      mutable_shielded_spends();
  private:
  const ::protocol::SpendNote& _internal_shielded_spends(int index) const;
  ::protocol::SpendNote* _internal_add_shielded_spends();
  public:
  const ::protocol::SpendNote& shielded_spends(int index) const;
  ::protocol::SpendNote* add_shielded_spends();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNote >&
      shielded_spends() const;

  // repeated .protocol.ReceiveNote shielded_receives = 7;
  int shielded_receives_size() const;
  private:
  int _internal_shielded_receives_size() const;
  public:
  void clear_shielded_receives();
  ::protocol::ReceiveNote* mutable_shielded_receives(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >*
      mutable_shielded_receives();
  private:
  const ::protocol::ReceiveNote& _internal_shielded_receives(int index) const;
  ::protocol::ReceiveNote* _internal_add_shielded_receives();
  public:
  const ::protocol::ReceiveNote& shielded_receives(int index) const;
  ::protocol::ReceiveNote* add_shielded_receives();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >&
      shielded_receives() const;

  // bytes transparent_from_address = 1;
  void clear_transparent_from_address();
  const std::string& transparent_from_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transparent_from_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transparent_from_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_transparent_from_address();
  void set_allocated_transparent_from_address(std::string* transparent_from_address);
  private:
  const std::string& _internal_transparent_from_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transparent_from_address(const std::string& value);
  std::string* _internal_mutable_transparent_from_address();
  public:

  // bytes ask = 2;
  void clear_ask();
  const std::string& ask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ask();
  PROTOBUF_MUST_USE_RESULT std::string* release_ask();
  void set_allocated_ask(std::string* ask);
  private:
  const std::string& _internal_ask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ask(const std::string& value);
  std::string* _internal_mutable_ask();
  public:

  // bytes nsk = 3;
  void clear_nsk();
  const std::string& nsk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nsk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nsk();
  PROTOBUF_MUST_USE_RESULT std::string* release_nsk();
  void set_allocated_nsk(std::string* nsk);
  private:
  const std::string& _internal_nsk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nsk(const std::string& value);
  std::string* _internal_mutable_nsk();
  public:

  // bytes ovk = 4;
  void clear_ovk();
  const std::string& ovk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ovk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ovk();
  PROTOBUF_MUST_USE_RESULT std::string* release_ovk();
  void set_allocated_ovk(std::string* ovk);
  private:
  const std::string& _internal_ovk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ovk(const std::string& value);
  std::string* _internal_mutable_ovk();
  public:

  // bytes transparent_to_address = 8;
  void clear_transparent_to_address();
  const std::string& transparent_to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transparent_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transparent_to_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_transparent_to_address();
  void set_allocated_transparent_to_address(std::string* transparent_to_address);
  private:
  const std::string& _internal_transparent_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transparent_to_address(const std::string& value);
  std::string* _internal_mutable_transparent_to_address();
  public:

  // int64 from_amount = 5;
  void clear_from_amount();
  ::PROTOBUF_NAMESPACE_ID::int64 from_amount() const;
  void set_from_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_from_amount() const;
  void _internal_set_from_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 to_amount = 9;
  void clear_to_amount();
  ::PROTOBUF_NAMESPACE_ID::int64 to_amount() const;
  void set_to_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_to_amount() const;
  void _internal_set_to_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 timeout = 10;
  void clear_timeout();
  ::PROTOBUF_NAMESPACE_ID::int64 timeout() const;
  void set_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timeout() const;
  void _internal_set_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.PrivateParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNote > shielded_spends_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote > shielded_receives_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transparent_from_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ask_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nsk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ovk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transparent_to_address_;
  ::PROTOBUF_NAMESPACE_ID::int64 from_amount_;
  ::PROTOBUF_NAMESPACE_ID::int64 to_amount_;
  ::PROTOBUF_NAMESPACE_ID::int64 timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PrivateParametersWithoutAsk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.PrivateParametersWithoutAsk) */ {
 public:
  inline PrivateParametersWithoutAsk() : PrivateParametersWithoutAsk(nullptr) {}
  ~PrivateParametersWithoutAsk() override;
  explicit constexpr PrivateParametersWithoutAsk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivateParametersWithoutAsk(const PrivateParametersWithoutAsk& from);
  PrivateParametersWithoutAsk(PrivateParametersWithoutAsk&& from) noexcept
    : PrivateParametersWithoutAsk() {
    *this = ::std::move(from);
  }

  inline PrivateParametersWithoutAsk& operator=(const PrivateParametersWithoutAsk& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivateParametersWithoutAsk& operator=(PrivateParametersWithoutAsk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrivateParametersWithoutAsk& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivateParametersWithoutAsk* internal_default_instance() {
    return reinterpret_cast<const PrivateParametersWithoutAsk*>(
               &_PrivateParametersWithoutAsk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(PrivateParametersWithoutAsk& a, PrivateParametersWithoutAsk& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivateParametersWithoutAsk* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivateParametersWithoutAsk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrivateParametersWithoutAsk* New() const final {
    return new PrivateParametersWithoutAsk();
  }

  PrivateParametersWithoutAsk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrivateParametersWithoutAsk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrivateParametersWithoutAsk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PrivateParametersWithoutAsk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrivateParametersWithoutAsk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.PrivateParametersWithoutAsk";
  }
  protected:
  explicit PrivateParametersWithoutAsk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShieldedSpendsFieldNumber = 6,
    kShieldedReceivesFieldNumber = 7,
    kTransparentFromAddressFieldNumber = 1,
    kAkFieldNumber = 2,
    kNskFieldNumber = 3,
    kOvkFieldNumber = 4,
    kTransparentToAddressFieldNumber = 8,
    kFromAmountFieldNumber = 5,
    kToAmountFieldNumber = 9,
    kTimeoutFieldNumber = 10,
  };
  // repeated .protocol.SpendNote shielded_spends = 6;
  int shielded_spends_size() const;
  private:
  int _internal_shielded_spends_size() const;
  public:
  void clear_shielded_spends();
  ::protocol::SpendNote* mutable_shielded_spends(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNote >*
      mutable_shielded_spends();
  private:
  const ::protocol::SpendNote& _internal_shielded_spends(int index) const;
  ::protocol::SpendNote* _internal_add_shielded_spends();
  public:
  const ::protocol::SpendNote& shielded_spends(int index) const;
  ::protocol::SpendNote* add_shielded_spends();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNote >&
      shielded_spends() const;

  // repeated .protocol.ReceiveNote shielded_receives = 7;
  int shielded_receives_size() const;
  private:
  int _internal_shielded_receives_size() const;
  public:
  void clear_shielded_receives();
  ::protocol::ReceiveNote* mutable_shielded_receives(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >*
      mutable_shielded_receives();
  private:
  const ::protocol::ReceiveNote& _internal_shielded_receives(int index) const;
  ::protocol::ReceiveNote* _internal_add_shielded_receives();
  public:
  const ::protocol::ReceiveNote& shielded_receives(int index) const;
  ::protocol::ReceiveNote* add_shielded_receives();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >&
      shielded_receives() const;

  // bytes transparent_from_address = 1;
  void clear_transparent_from_address();
  const std::string& transparent_from_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transparent_from_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transparent_from_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_transparent_from_address();
  void set_allocated_transparent_from_address(std::string* transparent_from_address);
  private:
  const std::string& _internal_transparent_from_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transparent_from_address(const std::string& value);
  std::string* _internal_mutable_transparent_from_address();
  public:

  // bytes ak = 2;
  void clear_ak();
  const std::string& ak() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ak(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ak();
  PROTOBUF_MUST_USE_RESULT std::string* release_ak();
  void set_allocated_ak(std::string* ak);
  private:
  const std::string& _internal_ak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ak(const std::string& value);
  std::string* _internal_mutable_ak();
  public:

  // bytes nsk = 3;
  void clear_nsk();
  const std::string& nsk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nsk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nsk();
  PROTOBUF_MUST_USE_RESULT std::string* release_nsk();
  void set_allocated_nsk(std::string* nsk);
  private:
  const std::string& _internal_nsk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nsk(const std::string& value);
  std::string* _internal_mutable_nsk();
  public:

  // bytes ovk = 4;
  void clear_ovk();
  const std::string& ovk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ovk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ovk();
  PROTOBUF_MUST_USE_RESULT std::string* release_ovk();
  void set_allocated_ovk(std::string* ovk);
  private:
  const std::string& _internal_ovk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ovk(const std::string& value);
  std::string* _internal_mutable_ovk();
  public:

  // bytes transparent_to_address = 8;
  void clear_transparent_to_address();
  const std::string& transparent_to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transparent_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transparent_to_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_transparent_to_address();
  void set_allocated_transparent_to_address(std::string* transparent_to_address);
  private:
  const std::string& _internal_transparent_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transparent_to_address(const std::string& value);
  std::string* _internal_mutable_transparent_to_address();
  public:

  // int64 from_amount = 5;
  void clear_from_amount();
  ::PROTOBUF_NAMESPACE_ID::int64 from_amount() const;
  void set_from_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_from_amount() const;
  void _internal_set_from_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 to_amount = 9;
  void clear_to_amount();
  ::PROTOBUF_NAMESPACE_ID::int64 to_amount() const;
  void set_to_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_to_amount() const;
  void _internal_set_to_amount(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 timeout = 10;
  void clear_timeout();
  ::PROTOBUF_NAMESPACE_ID::int64 timeout() const;
  void set_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timeout() const;
  void _internal_set_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.PrivateParametersWithoutAsk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNote > shielded_spends_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote > shielded_receives_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transparent_from_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ak_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nsk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ovk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transparent_to_address_;
  ::PROTOBUF_NAMESPACE_ID::int64 from_amount_;
  ::PROTOBUF_NAMESPACE_ID::int64 to_amount_;
  ::PROTOBUF_NAMESPACE_ID::int64 timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class SpendAuthSigParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SpendAuthSigParameters) */ {
 public:
  inline SpendAuthSigParameters() : SpendAuthSigParameters(nullptr) {}
  ~SpendAuthSigParameters() override;
  explicit constexpr SpendAuthSigParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpendAuthSigParameters(const SpendAuthSigParameters& from);
  SpendAuthSigParameters(SpendAuthSigParameters&& from) noexcept
    : SpendAuthSigParameters() {
    *this = ::std::move(from);
  }

  inline SpendAuthSigParameters& operator=(const SpendAuthSigParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpendAuthSigParameters& operator=(SpendAuthSigParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpendAuthSigParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpendAuthSigParameters* internal_default_instance() {
    return reinterpret_cast<const SpendAuthSigParameters*>(
               &_SpendAuthSigParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(SpendAuthSigParameters& a, SpendAuthSigParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(SpendAuthSigParameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpendAuthSigParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpendAuthSigParameters* New() const final {
    return new SpendAuthSigParameters();
  }

  SpendAuthSigParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpendAuthSigParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpendAuthSigParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpendAuthSigParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpendAuthSigParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SpendAuthSigParameters";
  }
  protected:
  explicit SpendAuthSigParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAskFieldNumber = 1,
    kTxHashFieldNumber = 2,
    kAlphaFieldNumber = 3,
  };
  // bytes ask = 1;
  void clear_ask();
  const std::string& ask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ask();
  PROTOBUF_MUST_USE_RESULT std::string* release_ask();
  void set_allocated_ask(std::string* ask);
  private:
  const std::string& _internal_ask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ask(const std::string& value);
  std::string* _internal_mutable_ask();
  public:

  // bytes tx_hash = 2;
  void clear_tx_hash();
  const std::string& tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* tx_hash);
  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(const std::string& value);
  std::string* _internal_mutable_tx_hash();
  public:

  // bytes alpha = 3;
  void clear_alpha();
  const std::string& alpha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alpha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alpha();
  PROTOBUF_MUST_USE_RESULT std::string* release_alpha();
  void set_allocated_alpha(std::string* alpha);
  private:
  const std::string& _internal_alpha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alpha(const std::string& value);
  std::string* _internal_mutable_alpha();
  public:

  // @@protoc_insertion_point(class_scope:protocol.SpendAuthSigParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ask_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alpha_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class NfParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.NfParameters) */ {
 public:
  inline NfParameters() : NfParameters(nullptr) {}
  ~NfParameters() override;
  explicit constexpr NfParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NfParameters(const NfParameters& from);
  NfParameters(NfParameters&& from) noexcept
    : NfParameters() {
    *this = ::std::move(from);
  }

  inline NfParameters& operator=(const NfParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline NfParameters& operator=(NfParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NfParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const NfParameters* internal_default_instance() {
    return reinterpret_cast<const NfParameters*>(
               &_NfParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(NfParameters& a, NfParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(NfParameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NfParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NfParameters* New() const final {
    return new NfParameters();
  }

  NfParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NfParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NfParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NfParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NfParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.NfParameters";
  }
  protected:
  explicit NfParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAkFieldNumber = 3,
    kNkFieldNumber = 4,
    kNoteFieldNumber = 1,
    kVoucherFieldNumber = 2,
  };
  // bytes ak = 3;
  void clear_ak();
  const std::string& ak() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ak(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ak();
  PROTOBUF_MUST_USE_RESULT std::string* release_ak();
  void set_allocated_ak(std::string* ak);
  private:
  const std::string& _internal_ak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ak(const std::string& value);
  std::string* _internal_mutable_ak();
  public:

  // bytes nk = 4;
  void clear_nk();
  const std::string& nk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nk();
  PROTOBUF_MUST_USE_RESULT std::string* release_nk();
  void set_allocated_nk(std::string* nk);
  private:
  const std::string& _internal_nk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nk(const std::string& value);
  std::string* _internal_mutable_nk();
  public:

  // .protocol.Note note = 1;
  bool has_note() const;
  private:
  bool _internal_has_note() const;
  public:
  void clear_note();
  const ::protocol::Note& note() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Note* release_note();
  ::protocol::Note* mutable_note();
  void set_allocated_note(::protocol::Note* note);
  private:
  const ::protocol::Note& _internal_note() const;
  ::protocol::Note* _internal_mutable_note();
  public:
  void unsafe_arena_set_allocated_note(
      ::protocol::Note* note);
  ::protocol::Note* unsafe_arena_release_note();

  // .protocol.IncrementalMerkleVoucher voucher = 2;
  bool has_voucher() const;
  private:
  bool _internal_has_voucher() const;
  public:
  void clear_voucher();
  const ::protocol::IncrementalMerkleVoucher& voucher() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::IncrementalMerkleVoucher* release_voucher();
  ::protocol::IncrementalMerkleVoucher* mutable_voucher();
  void set_allocated_voucher(::protocol::IncrementalMerkleVoucher* voucher);
  private:
  const ::protocol::IncrementalMerkleVoucher& _internal_voucher() const;
  ::protocol::IncrementalMerkleVoucher* _internal_mutable_voucher();
  public:
  void unsafe_arena_set_allocated_voucher(
      ::protocol::IncrementalMerkleVoucher* voucher);
  ::protocol::IncrementalMerkleVoucher* unsafe_arena_release_voucher();

  // @@protoc_insertion_point(class_scope:protocol.NfParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ak_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nk_;
  ::protocol::Note* note_;
  ::protocol::IncrementalMerkleVoucher* voucher_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ExpandedSpendingKeyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ExpandedSpendingKeyMessage) */ {
 public:
  inline ExpandedSpendingKeyMessage() : ExpandedSpendingKeyMessage(nullptr) {}
  ~ExpandedSpendingKeyMessage() override;
  explicit constexpr ExpandedSpendingKeyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpandedSpendingKeyMessage(const ExpandedSpendingKeyMessage& from);
  ExpandedSpendingKeyMessage(ExpandedSpendingKeyMessage&& from) noexcept
    : ExpandedSpendingKeyMessage() {
    *this = ::std::move(from);
  }

  inline ExpandedSpendingKeyMessage& operator=(const ExpandedSpendingKeyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpandedSpendingKeyMessage& operator=(ExpandedSpendingKeyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpandedSpendingKeyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpandedSpendingKeyMessage* internal_default_instance() {
    return reinterpret_cast<const ExpandedSpendingKeyMessage*>(
               &_ExpandedSpendingKeyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(ExpandedSpendingKeyMessage& a, ExpandedSpendingKeyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpandedSpendingKeyMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpandedSpendingKeyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExpandedSpendingKeyMessage* New() const final {
    return new ExpandedSpendingKeyMessage();
  }

  ExpandedSpendingKeyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExpandedSpendingKeyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpandedSpendingKeyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExpandedSpendingKeyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpandedSpendingKeyMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ExpandedSpendingKeyMessage";
  }
  protected:
  explicit ExpandedSpendingKeyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAskFieldNumber = 1,
    kNskFieldNumber = 2,
    kOvkFieldNumber = 3,
  };
  // bytes ask = 1;
  void clear_ask();
  const std::string& ask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ask();
  PROTOBUF_MUST_USE_RESULT std::string* release_ask();
  void set_allocated_ask(std::string* ask);
  private:
  const std::string& _internal_ask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ask(const std::string& value);
  std::string* _internal_mutable_ask();
  public:

  // bytes nsk = 2;
  void clear_nsk();
  const std::string& nsk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nsk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nsk();
  PROTOBUF_MUST_USE_RESULT std::string* release_nsk();
  void set_allocated_nsk(std::string* nsk);
  private:
  const std::string& _internal_nsk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nsk(const std::string& value);
  std::string* _internal_mutable_nsk();
  public:

  // bytes ovk = 3;
  void clear_ovk();
  const std::string& ovk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ovk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ovk();
  PROTOBUF_MUST_USE_RESULT std::string* release_ovk();
  void set_allocated_ovk(std::string* ovk);
  private:
  const std::string& _internal_ovk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ovk(const std::string& value);
  std::string* _internal_mutable_ovk();
  public:

  // @@protoc_insertion_point(class_scope:protocol.ExpandedSpendingKeyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ask_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nsk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ovk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ViewingKeyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ViewingKeyMessage) */ {
 public:
  inline ViewingKeyMessage() : ViewingKeyMessage(nullptr) {}
  ~ViewingKeyMessage() override;
  explicit constexpr ViewingKeyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ViewingKeyMessage(const ViewingKeyMessage& from);
  ViewingKeyMessage(ViewingKeyMessage&& from) noexcept
    : ViewingKeyMessage() {
    *this = ::std::move(from);
  }

  inline ViewingKeyMessage& operator=(const ViewingKeyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ViewingKeyMessage& operator=(ViewingKeyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ViewingKeyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ViewingKeyMessage* internal_default_instance() {
    return reinterpret_cast<const ViewingKeyMessage*>(
               &_ViewingKeyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(ViewingKeyMessage& a, ViewingKeyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ViewingKeyMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ViewingKeyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ViewingKeyMessage* New() const final {
    return new ViewingKeyMessage();
  }

  ViewingKeyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ViewingKeyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ViewingKeyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ViewingKeyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ViewingKeyMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ViewingKeyMessage";
  }
  protected:
  explicit ViewingKeyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAkFieldNumber = 1,
    kNkFieldNumber = 2,
  };
  // bytes ak = 1;
  void clear_ak();
  const std::string& ak() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ak(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ak();
  PROTOBUF_MUST_USE_RESULT std::string* release_ak();
  void set_allocated_ak(std::string* ak);
  private:
  const std::string& _internal_ak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ak(const std::string& value);
  std::string* _internal_mutable_ak();
  public:

  // bytes nk = 2;
  void clear_nk();
  const std::string& nk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nk();
  PROTOBUF_MUST_USE_RESULT std::string* release_nk();
  void set_allocated_nk(std::string* nk);
  private:
  const std::string& _internal_nk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nk(const std::string& value);
  std::string* _internal_mutable_nk();
  public:

  // @@protoc_insertion_point(class_scope:protocol.ViewingKeyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ak_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class IncomingViewingKeyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.IncomingViewingKeyMessage) */ {
 public:
  inline IncomingViewingKeyMessage() : IncomingViewingKeyMessage(nullptr) {}
  ~IncomingViewingKeyMessage() override;
  explicit constexpr IncomingViewingKeyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncomingViewingKeyMessage(const IncomingViewingKeyMessage& from);
  IncomingViewingKeyMessage(IncomingViewingKeyMessage&& from) noexcept
    : IncomingViewingKeyMessage() {
    *this = ::std::move(from);
  }

  inline IncomingViewingKeyMessage& operator=(const IncomingViewingKeyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncomingViewingKeyMessage& operator=(IncomingViewingKeyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncomingViewingKeyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncomingViewingKeyMessage* internal_default_instance() {
    return reinterpret_cast<const IncomingViewingKeyMessage*>(
               &_IncomingViewingKeyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(IncomingViewingKeyMessage& a, IncomingViewingKeyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(IncomingViewingKeyMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncomingViewingKeyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IncomingViewingKeyMessage* New() const final {
    return new IncomingViewingKeyMessage();
  }

  IncomingViewingKeyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IncomingViewingKeyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IncomingViewingKeyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IncomingViewingKeyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncomingViewingKeyMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.IncomingViewingKeyMessage";
  }
  protected:
  explicit IncomingViewingKeyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIvkFieldNumber = 1,
  };
  // bytes ivk = 1;
  void clear_ivk();
  const std::string& ivk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ivk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ivk();
  PROTOBUF_MUST_USE_RESULT std::string* release_ivk();
  void set_allocated_ivk(std::string* ivk);
  private:
  const std::string& _internal_ivk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ivk(const std::string& value);
  std::string* _internal_mutable_ivk();
  public:

  // @@protoc_insertion_point(class_scope:protocol.IncomingViewingKeyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ivk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class DiversifierMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DiversifierMessage) */ {
 public:
  inline DiversifierMessage() : DiversifierMessage(nullptr) {}
  ~DiversifierMessage() override;
  explicit constexpr DiversifierMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiversifierMessage(const DiversifierMessage& from);
  DiversifierMessage(DiversifierMessage&& from) noexcept
    : DiversifierMessage() {
    *this = ::std::move(from);
  }

  inline DiversifierMessage& operator=(const DiversifierMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiversifierMessage& operator=(DiversifierMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiversifierMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiversifierMessage* internal_default_instance() {
    return reinterpret_cast<const DiversifierMessage*>(
               &_DiversifierMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(DiversifierMessage& a, DiversifierMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DiversifierMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiversifierMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DiversifierMessage* New() const final {
    return new DiversifierMessage();
  }

  DiversifierMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DiversifierMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiversifierMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DiversifierMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiversifierMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DiversifierMessage";
  }
  protected:
  explicit DiversifierMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDFieldNumber = 1,
  };
  // bytes d = 1;
  void clear_d();
  const std::string& d() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_d(ArgT0&& arg0, ArgT... args);
  std::string* mutable_d();
  PROTOBUF_MUST_USE_RESULT std::string* release_d();
  void set_allocated_d(std::string* d);
  private:
  const std::string& _internal_d() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_d(const std::string& value);
  std::string* _internal_mutable_d();
  public:

  // @@protoc_insertion_point(class_scope:protocol.DiversifierMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr d_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class IncomingViewingKeyDiversifierMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.IncomingViewingKeyDiversifierMessage) */ {
 public:
  inline IncomingViewingKeyDiversifierMessage() : IncomingViewingKeyDiversifierMessage(nullptr) {}
  ~IncomingViewingKeyDiversifierMessage() override;
  explicit constexpr IncomingViewingKeyDiversifierMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncomingViewingKeyDiversifierMessage(const IncomingViewingKeyDiversifierMessage& from);
  IncomingViewingKeyDiversifierMessage(IncomingViewingKeyDiversifierMessage&& from) noexcept
    : IncomingViewingKeyDiversifierMessage() {
    *this = ::std::move(from);
  }

  inline IncomingViewingKeyDiversifierMessage& operator=(const IncomingViewingKeyDiversifierMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncomingViewingKeyDiversifierMessage& operator=(IncomingViewingKeyDiversifierMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncomingViewingKeyDiversifierMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncomingViewingKeyDiversifierMessage* internal_default_instance() {
    return reinterpret_cast<const IncomingViewingKeyDiversifierMessage*>(
               &_IncomingViewingKeyDiversifierMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(IncomingViewingKeyDiversifierMessage& a, IncomingViewingKeyDiversifierMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(IncomingViewingKeyDiversifierMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncomingViewingKeyDiversifierMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IncomingViewingKeyDiversifierMessage* New() const final {
    return new IncomingViewingKeyDiversifierMessage();
  }

  IncomingViewingKeyDiversifierMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IncomingViewingKeyDiversifierMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IncomingViewingKeyDiversifierMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IncomingViewingKeyDiversifierMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncomingViewingKeyDiversifierMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.IncomingViewingKeyDiversifierMessage";
  }
  protected:
  explicit IncomingViewingKeyDiversifierMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIvkFieldNumber = 1,
    kDFieldNumber = 2,
  };
  // .protocol.IncomingViewingKeyMessage ivk = 1;
  bool has_ivk() const;
  private:
  bool _internal_has_ivk() const;
  public:
  void clear_ivk();
  const ::protocol::IncomingViewingKeyMessage& ivk() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::IncomingViewingKeyMessage* release_ivk();
  ::protocol::IncomingViewingKeyMessage* mutable_ivk();
  void set_allocated_ivk(::protocol::IncomingViewingKeyMessage* ivk);
  private:
  const ::protocol::IncomingViewingKeyMessage& _internal_ivk() const;
  ::protocol::IncomingViewingKeyMessage* _internal_mutable_ivk();
  public:
  void unsafe_arena_set_allocated_ivk(
      ::protocol::IncomingViewingKeyMessage* ivk);
  ::protocol::IncomingViewingKeyMessage* unsafe_arena_release_ivk();

  // .protocol.DiversifierMessage d = 2;
  bool has_d() const;
  private:
  bool _internal_has_d() const;
  public:
  void clear_d();
  const ::protocol::DiversifierMessage& d() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::DiversifierMessage* release_d();
  ::protocol::DiversifierMessage* mutable_d();
  void set_allocated_d(::protocol::DiversifierMessage* d);
  private:
  const ::protocol::DiversifierMessage& _internal_d() const;
  ::protocol::DiversifierMessage* _internal_mutable_d();
  public:
  void unsafe_arena_set_allocated_d(
      ::protocol::DiversifierMessage* d);
  ::protocol::DiversifierMessage* unsafe_arena_release_d();

  // @@protoc_insertion_point(class_scope:protocol.IncomingViewingKeyDiversifierMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::IncomingViewingKeyMessage* ivk_;
  ::protocol::DiversifierMessage* d_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PaymentAddressMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.PaymentAddressMessage) */ {
 public:
  inline PaymentAddressMessage() : PaymentAddressMessage(nullptr) {}
  ~PaymentAddressMessage() override;
  explicit constexpr PaymentAddressMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaymentAddressMessage(const PaymentAddressMessage& from);
  PaymentAddressMessage(PaymentAddressMessage&& from) noexcept
    : PaymentAddressMessage() {
    *this = ::std::move(from);
  }

  inline PaymentAddressMessage& operator=(const PaymentAddressMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentAddressMessage& operator=(PaymentAddressMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaymentAddressMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaymentAddressMessage* internal_default_instance() {
    return reinterpret_cast<const PaymentAddressMessage*>(
               &_PaymentAddressMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(PaymentAddressMessage& a, PaymentAddressMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentAddressMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentAddressMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PaymentAddressMessage* New() const final {
    return new PaymentAddressMessage();
  }

  PaymentAddressMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentAddressMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaymentAddressMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PaymentAddressMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentAddressMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.PaymentAddressMessage";
  }
  protected:
  explicit PaymentAddressMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPkDFieldNumber = 2,
    kPaymentAddressFieldNumber = 3,
    kDFieldNumber = 1,
  };
  // bytes pkD = 2;
  void clear_pkd();
  const std::string& pkd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pkd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pkd();
  PROTOBUF_MUST_USE_RESULT std::string* release_pkd();
  void set_allocated_pkd(std::string* pkd);
  private:
  const std::string& _internal_pkd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pkd(const std::string& value);
  std::string* _internal_mutable_pkd();
  public:

  // string payment_address = 3;
  void clear_payment_address();
  const std::string& payment_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payment_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payment_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_payment_address();
  void set_allocated_payment_address(std::string* payment_address);
  private:
  const std::string& _internal_payment_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payment_address(const std::string& value);
  std::string* _internal_mutable_payment_address();
  public:

  // .protocol.DiversifierMessage d = 1;
  bool has_d() const;
  private:
  bool _internal_has_d() const;
  public:
  void clear_d();
  const ::protocol::DiversifierMessage& d() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::DiversifierMessage* release_d();
  ::protocol::DiversifierMessage* mutable_d();
  void set_allocated_d(::protocol::DiversifierMessage* d);
  private:
  const ::protocol::DiversifierMessage& _internal_d() const;
  ::protocol::DiversifierMessage* _internal_mutable_d();
  public:
  void unsafe_arena_set_allocated_d(
      ::protocol::DiversifierMessage* d);
  ::protocol::DiversifierMessage* unsafe_arena_release_d();

  // @@protoc_insertion_point(class_scope:protocol.PaymentAddressMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pkd_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payment_address_;
  ::protocol::DiversifierMessage* d_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ShieldedAddressInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ShieldedAddressInfo) */ {
 public:
  inline ShieldedAddressInfo() : ShieldedAddressInfo(nullptr) {}
  ~ShieldedAddressInfo() override;
  explicit constexpr ShieldedAddressInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShieldedAddressInfo(const ShieldedAddressInfo& from);
  ShieldedAddressInfo(ShieldedAddressInfo&& from) noexcept
    : ShieldedAddressInfo() {
    *this = ::std::move(from);
  }

  inline ShieldedAddressInfo& operator=(const ShieldedAddressInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShieldedAddressInfo& operator=(ShieldedAddressInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShieldedAddressInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShieldedAddressInfo* internal_default_instance() {
    return reinterpret_cast<const ShieldedAddressInfo*>(
               &_ShieldedAddressInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(ShieldedAddressInfo& a, ShieldedAddressInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ShieldedAddressInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShieldedAddressInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShieldedAddressInfo* New() const final {
    return new ShieldedAddressInfo();
  }

  ShieldedAddressInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShieldedAddressInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShieldedAddressInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShieldedAddressInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShieldedAddressInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ShieldedAddressInfo";
  }
  protected:
  explicit ShieldedAddressInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkFieldNumber = 1,
    kAskFieldNumber = 2,
    kNskFieldNumber = 3,
    kOvkFieldNumber = 4,
    kAkFieldNumber = 5,
    kNkFieldNumber = 6,
    kIvkFieldNumber = 7,
    kDFieldNumber = 8,
    kPkDFieldNumber = 9,
    kPaymentAddressFieldNumber = 10,
  };
  // bytes sk = 1;
  void clear_sk();
  const std::string& sk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sk();
  PROTOBUF_MUST_USE_RESULT std::string* release_sk();
  void set_allocated_sk(std::string* sk);
  private:
  const std::string& _internal_sk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sk(const std::string& value);
  std::string* _internal_mutable_sk();
  public:

  // bytes ask = 2;
  void clear_ask();
  const std::string& ask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ask();
  PROTOBUF_MUST_USE_RESULT std::string* release_ask();
  void set_allocated_ask(std::string* ask);
  private:
  const std::string& _internal_ask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ask(const std::string& value);
  std::string* _internal_mutable_ask();
  public:

  // bytes nsk = 3;
  void clear_nsk();
  const std::string& nsk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nsk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nsk();
  PROTOBUF_MUST_USE_RESULT std::string* release_nsk();
  void set_allocated_nsk(std::string* nsk);
  private:
  const std::string& _internal_nsk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nsk(const std::string& value);
  std::string* _internal_mutable_nsk();
  public:

  // bytes ovk = 4;
  void clear_ovk();
  const std::string& ovk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ovk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ovk();
  PROTOBUF_MUST_USE_RESULT std::string* release_ovk();
  void set_allocated_ovk(std::string* ovk);
  private:
  const std::string& _internal_ovk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ovk(const std::string& value);
  std::string* _internal_mutable_ovk();
  public:

  // bytes ak = 5;
  void clear_ak();
  const std::string& ak() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ak(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ak();
  PROTOBUF_MUST_USE_RESULT std::string* release_ak();
  void set_allocated_ak(std::string* ak);
  private:
  const std::string& _internal_ak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ak(const std::string& value);
  std::string* _internal_mutable_ak();
  public:

  // bytes nk = 6;
  void clear_nk();
  const std::string& nk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nk();
  PROTOBUF_MUST_USE_RESULT std::string* release_nk();
  void set_allocated_nk(std::string* nk);
  private:
  const std::string& _internal_nk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nk(const std::string& value);
  std::string* _internal_mutable_nk();
  public:

  // bytes ivk = 7;
  void clear_ivk();
  const std::string& ivk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ivk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ivk();
  PROTOBUF_MUST_USE_RESULT std::string* release_ivk();
  void set_allocated_ivk(std::string* ivk);
  private:
  const std::string& _internal_ivk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ivk(const std::string& value);
  std::string* _internal_mutable_ivk();
  public:

  // bytes d = 8;
  void clear_d();
  const std::string& d() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_d(ArgT0&& arg0, ArgT... args);
  std::string* mutable_d();
  PROTOBUF_MUST_USE_RESULT std::string* release_d();
  void set_allocated_d(std::string* d);
  private:
  const std::string& _internal_d() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_d(const std::string& value);
  std::string* _internal_mutable_d();
  public:

  // bytes pkD = 9;
  void clear_pkd();
  const std::string& pkd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pkd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pkd();
  PROTOBUF_MUST_USE_RESULT std::string* release_pkd();
  void set_allocated_pkd(std::string* pkd);
  private:
  const std::string& _internal_pkd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pkd(const std::string& value);
  std::string* _internal_mutable_pkd();
  public:

  // string payment_address = 10;
  void clear_payment_address();
  const std::string& payment_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payment_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payment_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_payment_address();
  void set_allocated_payment_address(std::string* payment_address);
  private:
  const std::string& _internal_payment_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payment_address(const std::string& value);
  std::string* _internal_mutable_payment_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.ShieldedAddressInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ask_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nsk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ovk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ak_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ivk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr d_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pkd_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payment_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class NoteParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.NoteParameters) */ {
 public:
  inline NoteParameters() : NoteParameters(nullptr) {}
  ~NoteParameters() override;
  explicit constexpr NoteParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NoteParameters(const NoteParameters& from);
  NoteParameters(NoteParameters&& from) noexcept
    : NoteParameters() {
    *this = ::std::move(from);
  }

  inline NoteParameters& operator=(const NoteParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoteParameters& operator=(NoteParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoteParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoteParameters* internal_default_instance() {
    return reinterpret_cast<const NoteParameters*>(
               &_NoteParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(NoteParameters& a, NoteParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(NoteParameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoteParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NoteParameters* New() const final {
    return new NoteParameters();
  }

  NoteParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NoteParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NoteParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NoteParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NoteParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.NoteParameters";
  }
  protected:
  explicit NoteParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAkFieldNumber = 1,
    kNkFieldNumber = 2,
    kTxidFieldNumber = 4,
    kNoteFieldNumber = 3,
    kIndexFieldNumber = 5,
  };
  // bytes ak = 1;
  void clear_ak();
  const std::string& ak() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ak(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ak();
  PROTOBUF_MUST_USE_RESULT std::string* release_ak();
  void set_allocated_ak(std::string* ak);
  private:
  const std::string& _internal_ak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ak(const std::string& value);
  std::string* _internal_mutable_ak();
  public:

  // bytes nk = 2;
  void clear_nk();
  const std::string& nk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nk();
  PROTOBUF_MUST_USE_RESULT std::string* release_nk();
  void set_allocated_nk(std::string* nk);
  private:
  const std::string& _internal_nk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nk(const std::string& value);
  std::string* _internal_mutable_nk();
  public:

  // bytes txid = 4;
  void clear_txid();
  const std::string& txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txid();
  PROTOBUF_MUST_USE_RESULT std::string* release_txid();
  void set_allocated_txid(std::string* txid);
  private:
  const std::string& _internal_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txid(const std::string& value);
  std::string* _internal_mutable_txid();
  public:

  // .protocol.Note note = 3;
  bool has_note() const;
  private:
  bool _internal_has_note() const;
  public:
  void clear_note();
  const ::protocol::Note& note() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Note* release_note();
  ::protocol::Note* mutable_note();
  void set_allocated_note(::protocol::Note* note);
  private:
  const ::protocol::Note& _internal_note() const;
  ::protocol::Note* _internal_mutable_note();
  public:
  void unsafe_arena_set_allocated_note(
      ::protocol::Note* note);
  ::protocol::Note* unsafe_arena_release_note();

  // int32 index = 5;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::int32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.NoteParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ak_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txid_;
  ::protocol::Note* note_;
  ::PROTOBUF_NAMESPACE_ID::int32 index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class SpendResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SpendResult) */ {
 public:
  inline SpendResult() : SpendResult(nullptr) {}
  ~SpendResult() override;
  explicit constexpr SpendResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpendResult(const SpendResult& from);
  SpendResult(SpendResult&& from) noexcept
    : SpendResult() {
    *this = ::std::move(from);
  }

  inline SpendResult& operator=(const SpendResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpendResult& operator=(SpendResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpendResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpendResult* internal_default_instance() {
    return reinterpret_cast<const SpendResult*>(
               &_SpendResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(SpendResult& a, SpendResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SpendResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpendResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpendResult* New() const final {
    return new SpendResult();
  }

  SpendResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpendResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpendResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpendResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpendResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SpendResult";
  }
  protected:
  explicit SpendResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SpendResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class TransactionInfoList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionInfoList) */ {
 public:
  inline TransactionInfoList() : TransactionInfoList(nullptr) {}
  ~TransactionInfoList() override;
  explicit constexpr TransactionInfoList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionInfoList(const TransactionInfoList& from);
  TransactionInfoList(TransactionInfoList&& from) noexcept
    : TransactionInfoList() {
    *this = ::std::move(from);
  }

  inline TransactionInfoList& operator=(const TransactionInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionInfoList& operator=(TransactionInfoList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionInfoList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionInfoList* internal_default_instance() {
    return reinterpret_cast<const TransactionInfoList*>(
               &_TransactionInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(TransactionInfoList& a, TransactionInfoList& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionInfoList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionInfoList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionInfoList* New() const final {
    return new TransactionInfoList();
  }

  TransactionInfoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionInfoList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionInfoList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionInfoList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionInfoList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionInfoList";
  }
  protected:
  explicit TransactionInfoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionInfoFieldNumber = 1,
  };
  // repeated .protocol.TransactionInfo transactionInfo = 1;
  int transactioninfo_size() const;
  private:
  int _internal_transactioninfo_size() const;
  public:
  void clear_transactioninfo();
  ::protocol::TransactionInfo* mutable_transactioninfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo >*
      mutable_transactioninfo();
  private:
  const ::protocol::TransactionInfo& _internal_transactioninfo(int index) const;
  ::protocol::TransactionInfo* _internal_add_transactioninfo();
  public:
  const ::protocol::TransactionInfo& transactioninfo(int index) const;
  ::protocol::TransactionInfo* add_transactioninfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo >&
      transactioninfo() const;

  // @@protoc_insertion_point(class_scope:protocol.TransactionInfoList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo > transactioninfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class SpendNoteTRC20 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SpendNoteTRC20) */ {
 public:
  inline SpendNoteTRC20() : SpendNoteTRC20(nullptr) {}
  ~SpendNoteTRC20() override;
  explicit constexpr SpendNoteTRC20(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpendNoteTRC20(const SpendNoteTRC20& from);
  SpendNoteTRC20(SpendNoteTRC20&& from) noexcept
    : SpendNoteTRC20() {
    *this = ::std::move(from);
  }

  inline SpendNoteTRC20& operator=(const SpendNoteTRC20& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpendNoteTRC20& operator=(SpendNoteTRC20&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpendNoteTRC20& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpendNoteTRC20* internal_default_instance() {
    return reinterpret_cast<const SpendNoteTRC20*>(
               &_SpendNoteTRC20_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(SpendNoteTRC20& a, SpendNoteTRC20& b) {
    a.Swap(&b);
  }
  inline void Swap(SpendNoteTRC20* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpendNoteTRC20* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpendNoteTRC20* New() const final {
    return new SpendNoteTRC20();
  }

  SpendNoteTRC20* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpendNoteTRC20>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpendNoteTRC20& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpendNoteTRC20& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpendNoteTRC20* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SpendNoteTRC20";
  }
  protected:
  explicit SpendNoteTRC20(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlphaFieldNumber = 2,
    kRootFieldNumber = 3,
    kPathFieldNumber = 4,
    kNoteFieldNumber = 1,
    kPosFieldNumber = 5,
  };
  // bytes alpha = 2;
  void clear_alpha();
  const std::string& alpha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alpha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alpha();
  PROTOBUF_MUST_USE_RESULT std::string* release_alpha();
  void set_allocated_alpha(std::string* alpha);
  private:
  const std::string& _internal_alpha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alpha(const std::string& value);
  std::string* _internal_mutable_alpha();
  public:

  // bytes root = 3;
  void clear_root();
  const std::string& root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_root();
  PROTOBUF_MUST_USE_RESULT std::string* release_root();
  void set_allocated_root(std::string* root);
  private:
  const std::string& _internal_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_root(const std::string& value);
  std::string* _internal_mutable_root();
  public:

  // bytes path = 4;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .protocol.Note note = 1;
  bool has_note() const;
  private:
  bool _internal_has_note() const;
  public:
  void clear_note();
  const ::protocol::Note& note() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Note* release_note();
  ::protocol::Note* mutable_note();
  void set_allocated_note(::protocol::Note* note);
  private:
  const ::protocol::Note& _internal_note() const;
  ::protocol::Note* _internal_mutable_note();
  public:
  void unsafe_arena_set_allocated_note(
      ::protocol::Note* note);
  ::protocol::Note* unsafe_arena_release_note();

  // int64 pos = 5;
  void clear_pos();
  ::PROTOBUF_NAMESPACE_ID::int64 pos() const;
  void set_pos(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pos() const;
  void _internal_set_pos(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.SpendNoteTRC20)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alpha_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr root_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::protocol::Note* note_;
  ::PROTOBUF_NAMESPACE_ID::int64 pos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PrivateShieldedTRC20Parameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.PrivateShieldedTRC20Parameters) */ {
 public:
  inline PrivateShieldedTRC20Parameters() : PrivateShieldedTRC20Parameters(nullptr) {}
  ~PrivateShieldedTRC20Parameters() override;
  explicit constexpr PrivateShieldedTRC20Parameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivateShieldedTRC20Parameters(const PrivateShieldedTRC20Parameters& from);
  PrivateShieldedTRC20Parameters(PrivateShieldedTRC20Parameters&& from) noexcept
    : PrivateShieldedTRC20Parameters() {
    *this = ::std::move(from);
  }

  inline PrivateShieldedTRC20Parameters& operator=(const PrivateShieldedTRC20Parameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivateShieldedTRC20Parameters& operator=(PrivateShieldedTRC20Parameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrivateShieldedTRC20Parameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivateShieldedTRC20Parameters* internal_default_instance() {
    return reinterpret_cast<const PrivateShieldedTRC20Parameters*>(
               &_PrivateShieldedTRC20Parameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(PrivateShieldedTRC20Parameters& a, PrivateShieldedTRC20Parameters& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivateShieldedTRC20Parameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivateShieldedTRC20Parameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrivateShieldedTRC20Parameters* New() const final {
    return new PrivateShieldedTRC20Parameters();
  }

  PrivateShieldedTRC20Parameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrivateShieldedTRC20Parameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrivateShieldedTRC20Parameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PrivateShieldedTRC20Parameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrivateShieldedTRC20Parameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.PrivateShieldedTRC20Parameters";
  }
  protected:
  explicit PrivateShieldedTRC20Parameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShieldedSpendsFieldNumber = 5,
    kShieldedReceivesFieldNumber = 6,
    kAskFieldNumber = 1,
    kNskFieldNumber = 2,
    kOvkFieldNumber = 3,
    kFromAmountFieldNumber = 4,
    kTransparentToAddressFieldNumber = 7,
    kToAmountFieldNumber = 8,
    kShieldedTRC20ContractAddressFieldNumber = 9,
  };
  // repeated .protocol.SpendNoteTRC20 shielded_spends = 5;
  int shielded_spends_size() const;
  private:
  int _internal_shielded_spends_size() const;
  public:
  void clear_shielded_spends();
  ::protocol::SpendNoteTRC20* mutable_shielded_spends(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNoteTRC20 >*
      mutable_shielded_spends();
  private:
  const ::protocol::SpendNoteTRC20& _internal_shielded_spends(int index) const;
  ::protocol::SpendNoteTRC20* _internal_add_shielded_spends();
  public:
  const ::protocol::SpendNoteTRC20& shielded_spends(int index) const;
  ::protocol::SpendNoteTRC20* add_shielded_spends();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNoteTRC20 >&
      shielded_spends() const;

  // repeated .protocol.ReceiveNote shielded_receives = 6;
  int shielded_receives_size() const;
  private:
  int _internal_shielded_receives_size() const;
  public:
  void clear_shielded_receives();
  ::protocol::ReceiveNote* mutable_shielded_receives(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >*
      mutable_shielded_receives();
  private:
  const ::protocol::ReceiveNote& _internal_shielded_receives(int index) const;
  ::protocol::ReceiveNote* _internal_add_shielded_receives();
  public:
  const ::protocol::ReceiveNote& shielded_receives(int index) const;
  ::protocol::ReceiveNote* add_shielded_receives();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >&
      shielded_receives() const;

  // bytes ask = 1;
  void clear_ask();
  const std::string& ask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ask();
  PROTOBUF_MUST_USE_RESULT std::string* release_ask();
  void set_allocated_ask(std::string* ask);
  private:
  const std::string& _internal_ask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ask(const std::string& value);
  std::string* _internal_mutable_ask();
  public:

  // bytes nsk = 2;
  void clear_nsk();
  const std::string& nsk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nsk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nsk();
  PROTOBUF_MUST_USE_RESULT std::string* release_nsk();
  void set_allocated_nsk(std::string* nsk);
  private:
  const std::string& _internal_nsk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nsk(const std::string& value);
  std::string* _internal_mutable_nsk();
  public:

  // bytes ovk = 3;
  void clear_ovk();
  const std::string& ovk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ovk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ovk();
  PROTOBUF_MUST_USE_RESULT std::string* release_ovk();
  void set_allocated_ovk(std::string* ovk);
  private:
  const std::string& _internal_ovk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ovk(const std::string& value);
  std::string* _internal_mutable_ovk();
  public:

  // string from_amount = 4;
  void clear_from_amount();
  const std::string& from_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_amount();
  PROTOBUF_MUST_USE_RESULT std::string* release_from_amount();
  void set_allocated_from_amount(std::string* from_amount);
  private:
  const std::string& _internal_from_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_amount(const std::string& value);
  std::string* _internal_mutable_from_amount();
  public:

  // bytes transparent_to_address = 7;
  void clear_transparent_to_address();
  const std::string& transparent_to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transparent_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transparent_to_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_transparent_to_address();
  void set_allocated_transparent_to_address(std::string* transparent_to_address);
  private:
  const std::string& _internal_transparent_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transparent_to_address(const std::string& value);
  std::string* _internal_mutable_transparent_to_address();
  public:

  // string to_amount = 8;
  void clear_to_amount();
  const std::string& to_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_amount();
  PROTOBUF_MUST_USE_RESULT std::string* release_to_amount();
  void set_allocated_to_amount(std::string* to_amount);
  private:
  const std::string& _internal_to_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_amount(const std::string& value);
  std::string* _internal_mutable_to_amount();
  public:

  // bytes shielded_TRC20_contract_address = 9;
  void clear_shielded_trc20_contract_address();
  const std::string& shielded_trc20_contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shielded_trc20_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shielded_trc20_contract_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_shielded_trc20_contract_address();
  void set_allocated_shielded_trc20_contract_address(std::string* shielded_trc20_contract_address);
  private:
  const std::string& _internal_shielded_trc20_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shielded_trc20_contract_address(const std::string& value);
  std::string* _internal_mutable_shielded_trc20_contract_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.PrivateShieldedTRC20Parameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNoteTRC20 > shielded_spends_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote > shielded_receives_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ask_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nsk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ovk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transparent_to_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shielded_trc20_contract_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class PrivateShieldedTRC20ParametersWithoutAsk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.PrivateShieldedTRC20ParametersWithoutAsk) */ {
 public:
  inline PrivateShieldedTRC20ParametersWithoutAsk() : PrivateShieldedTRC20ParametersWithoutAsk(nullptr) {}
  ~PrivateShieldedTRC20ParametersWithoutAsk() override;
  explicit constexpr PrivateShieldedTRC20ParametersWithoutAsk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivateShieldedTRC20ParametersWithoutAsk(const PrivateShieldedTRC20ParametersWithoutAsk& from);
  PrivateShieldedTRC20ParametersWithoutAsk(PrivateShieldedTRC20ParametersWithoutAsk&& from) noexcept
    : PrivateShieldedTRC20ParametersWithoutAsk() {
    *this = ::std::move(from);
  }

  inline PrivateShieldedTRC20ParametersWithoutAsk& operator=(const PrivateShieldedTRC20ParametersWithoutAsk& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivateShieldedTRC20ParametersWithoutAsk& operator=(PrivateShieldedTRC20ParametersWithoutAsk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrivateShieldedTRC20ParametersWithoutAsk& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivateShieldedTRC20ParametersWithoutAsk* internal_default_instance() {
    return reinterpret_cast<const PrivateShieldedTRC20ParametersWithoutAsk*>(
               &_PrivateShieldedTRC20ParametersWithoutAsk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(PrivateShieldedTRC20ParametersWithoutAsk& a, PrivateShieldedTRC20ParametersWithoutAsk& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivateShieldedTRC20ParametersWithoutAsk* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivateShieldedTRC20ParametersWithoutAsk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrivateShieldedTRC20ParametersWithoutAsk* New() const final {
    return new PrivateShieldedTRC20ParametersWithoutAsk();
  }

  PrivateShieldedTRC20ParametersWithoutAsk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrivateShieldedTRC20ParametersWithoutAsk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrivateShieldedTRC20ParametersWithoutAsk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PrivateShieldedTRC20ParametersWithoutAsk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrivateShieldedTRC20ParametersWithoutAsk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.PrivateShieldedTRC20ParametersWithoutAsk";
  }
  protected:
  explicit PrivateShieldedTRC20ParametersWithoutAsk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShieldedSpendsFieldNumber = 5,
    kShieldedReceivesFieldNumber = 6,
    kAkFieldNumber = 1,
    kNskFieldNumber = 2,
    kOvkFieldNumber = 3,
    kFromAmountFieldNumber = 4,
    kTransparentToAddressFieldNumber = 7,
    kToAmountFieldNumber = 8,
    kShieldedTRC20ContractAddressFieldNumber = 9,
  };
  // repeated .protocol.SpendNoteTRC20 shielded_spends = 5;
  int shielded_spends_size() const;
  private:
  int _internal_shielded_spends_size() const;
  public:
  void clear_shielded_spends();
  ::protocol::SpendNoteTRC20* mutable_shielded_spends(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNoteTRC20 >*
      mutable_shielded_spends();
  private:
  const ::protocol::SpendNoteTRC20& _internal_shielded_spends(int index) const;
  ::protocol::SpendNoteTRC20* _internal_add_shielded_spends();
  public:
  const ::protocol::SpendNoteTRC20& shielded_spends(int index) const;
  ::protocol::SpendNoteTRC20* add_shielded_spends();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNoteTRC20 >&
      shielded_spends() const;

  // repeated .protocol.ReceiveNote shielded_receives = 6;
  int shielded_receives_size() const;
  private:
  int _internal_shielded_receives_size() const;
  public:
  void clear_shielded_receives();
  ::protocol::ReceiveNote* mutable_shielded_receives(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >*
      mutable_shielded_receives();
  private:
  const ::protocol::ReceiveNote& _internal_shielded_receives(int index) const;
  ::protocol::ReceiveNote* _internal_add_shielded_receives();
  public:
  const ::protocol::ReceiveNote& shielded_receives(int index) const;
  ::protocol::ReceiveNote* add_shielded_receives();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >&
      shielded_receives() const;

  // bytes ak = 1;
  void clear_ak();
  const std::string& ak() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ak(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ak();
  PROTOBUF_MUST_USE_RESULT std::string* release_ak();
  void set_allocated_ak(std::string* ak);
  private:
  const std::string& _internal_ak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ak(const std::string& value);
  std::string* _internal_mutable_ak();
  public:

  // bytes nsk = 2;
  void clear_nsk();
  const std::string& nsk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nsk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nsk();
  PROTOBUF_MUST_USE_RESULT std::string* release_nsk();
  void set_allocated_nsk(std::string* nsk);
  private:
  const std::string& _internal_nsk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nsk(const std::string& value);
  std::string* _internal_mutable_nsk();
  public:

  // bytes ovk = 3;
  void clear_ovk();
  const std::string& ovk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ovk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ovk();
  PROTOBUF_MUST_USE_RESULT std::string* release_ovk();
  void set_allocated_ovk(std::string* ovk);
  private:
  const std::string& _internal_ovk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ovk(const std::string& value);
  std::string* _internal_mutable_ovk();
  public:

  // string from_amount = 4;
  void clear_from_amount();
  const std::string& from_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_amount();
  PROTOBUF_MUST_USE_RESULT std::string* release_from_amount();
  void set_allocated_from_amount(std::string* from_amount);
  private:
  const std::string& _internal_from_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_amount(const std::string& value);
  std::string* _internal_mutable_from_amount();
  public:

  // bytes transparent_to_address = 7;
  void clear_transparent_to_address();
  const std::string& transparent_to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transparent_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transparent_to_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_transparent_to_address();
  void set_allocated_transparent_to_address(std::string* transparent_to_address);
  private:
  const std::string& _internal_transparent_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transparent_to_address(const std::string& value);
  std::string* _internal_mutable_transparent_to_address();
  public:

  // string to_amount = 8;
  void clear_to_amount();
  const std::string& to_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_amount();
  PROTOBUF_MUST_USE_RESULT std::string* release_to_amount();
  void set_allocated_to_amount(std::string* to_amount);
  private:
  const std::string& _internal_to_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_amount(const std::string& value);
  std::string* _internal_mutable_to_amount();
  public:

  // bytes shielded_TRC20_contract_address = 9;
  void clear_shielded_trc20_contract_address();
  const std::string& shielded_trc20_contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shielded_trc20_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shielded_trc20_contract_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_shielded_trc20_contract_address();
  void set_allocated_shielded_trc20_contract_address(std::string* shielded_trc20_contract_address);
  private:
  const std::string& _internal_shielded_trc20_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shielded_trc20_contract_address(const std::string& value);
  std::string* _internal_mutable_shielded_trc20_contract_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.PrivateShieldedTRC20ParametersWithoutAsk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNoteTRC20 > shielded_spends_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote > shielded_receives_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ak_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nsk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ovk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transparent_to_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shielded_trc20_contract_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ShieldedTRC20Parameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ShieldedTRC20Parameters) */ {
 public:
  inline ShieldedTRC20Parameters() : ShieldedTRC20Parameters(nullptr) {}
  ~ShieldedTRC20Parameters() override;
  explicit constexpr ShieldedTRC20Parameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShieldedTRC20Parameters(const ShieldedTRC20Parameters& from);
  ShieldedTRC20Parameters(ShieldedTRC20Parameters&& from) noexcept
    : ShieldedTRC20Parameters() {
    *this = ::std::move(from);
  }

  inline ShieldedTRC20Parameters& operator=(const ShieldedTRC20Parameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShieldedTRC20Parameters& operator=(ShieldedTRC20Parameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShieldedTRC20Parameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShieldedTRC20Parameters* internal_default_instance() {
    return reinterpret_cast<const ShieldedTRC20Parameters*>(
               &_ShieldedTRC20Parameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(ShieldedTRC20Parameters& a, ShieldedTRC20Parameters& b) {
    a.Swap(&b);
  }
  inline void Swap(ShieldedTRC20Parameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShieldedTRC20Parameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShieldedTRC20Parameters* New() const final {
    return new ShieldedTRC20Parameters();
  }

  ShieldedTRC20Parameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShieldedTRC20Parameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShieldedTRC20Parameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShieldedTRC20Parameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShieldedTRC20Parameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ShieldedTRC20Parameters";
  }
  protected:
  explicit ShieldedTRC20Parameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpendDescriptionFieldNumber = 1,
    kReceiveDescriptionFieldNumber = 2,
    kBindingSignatureFieldNumber = 3,
    kMessageHashFieldNumber = 4,
    kTriggerContractInputFieldNumber = 5,
    kParameterTypeFieldNumber = 6,
  };
  // repeated .protocol.SpendDescription spend_description = 1;
  int spend_description_size() const;
  private:
  int _internal_spend_description_size() const;
  public:
  void clear_spend_description();
  ::protocol::SpendDescription* mutable_spend_description(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendDescription >*
      mutable_spend_description();
  private:
  const ::protocol::SpendDescription& _internal_spend_description(int index) const;
  ::protocol::SpendDescription* _internal_add_spend_description();
  public:
  const ::protocol::SpendDescription& spend_description(int index) const;
  ::protocol::SpendDescription* add_spend_description();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendDescription >&
      spend_description() const;

  // repeated .protocol.ReceiveDescription receive_description = 2;
  int receive_description_size() const;
  private:
  int _internal_receive_description_size() const;
  public:
  void clear_receive_description();
  ::protocol::ReceiveDescription* mutable_receive_description(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveDescription >*
      mutable_receive_description();
  private:
  const ::protocol::ReceiveDescription& _internal_receive_description(int index) const;
  ::protocol::ReceiveDescription* _internal_add_receive_description();
  public:
  const ::protocol::ReceiveDescription& receive_description(int index) const;
  ::protocol::ReceiveDescription* add_receive_description();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveDescription >&
      receive_description() const;

  // bytes binding_signature = 3;
  void clear_binding_signature();
  const std::string& binding_signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binding_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binding_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_binding_signature();
  void set_allocated_binding_signature(std::string* binding_signature);
  private:
  const std::string& _internal_binding_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binding_signature(const std::string& value);
  std::string* _internal_mutable_binding_signature();
  public:

  // bytes message_hash = 4;
  void clear_message_hash();
  const std::string& message_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_message_hash();
  void set_allocated_message_hash(std::string* message_hash);
  private:
  const std::string& _internal_message_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_hash(const std::string& value);
  std::string* _internal_mutable_message_hash();
  public:

  // string trigger_contract_input = 5;
  void clear_trigger_contract_input();
  const std::string& trigger_contract_input() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trigger_contract_input(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trigger_contract_input();
  PROTOBUF_MUST_USE_RESULT std::string* release_trigger_contract_input();
  void set_allocated_trigger_contract_input(std::string* trigger_contract_input);
  private:
  const std::string& _internal_trigger_contract_input() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_contract_input(const std::string& value);
  std::string* _internal_mutable_trigger_contract_input();
  public:

  // string parameter_type = 6;
  void clear_parameter_type();
  const std::string& parameter_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parameter_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parameter_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_parameter_type();
  void set_allocated_parameter_type(std::string* parameter_type);
  private:
  const std::string& _internal_parameter_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parameter_type(const std::string& value);
  std::string* _internal_mutable_parameter_type();
  public:

  // @@protoc_insertion_point(class_scope:protocol.ShieldedTRC20Parameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendDescription > spend_description_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveDescription > receive_description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binding_signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_contract_input_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parameter_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class IvkDecryptTRC20Parameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.IvkDecryptTRC20Parameters) */ {
 public:
  inline IvkDecryptTRC20Parameters() : IvkDecryptTRC20Parameters(nullptr) {}
  ~IvkDecryptTRC20Parameters() override;
  explicit constexpr IvkDecryptTRC20Parameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IvkDecryptTRC20Parameters(const IvkDecryptTRC20Parameters& from);
  IvkDecryptTRC20Parameters(IvkDecryptTRC20Parameters&& from) noexcept
    : IvkDecryptTRC20Parameters() {
    *this = ::std::move(from);
  }

  inline IvkDecryptTRC20Parameters& operator=(const IvkDecryptTRC20Parameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline IvkDecryptTRC20Parameters& operator=(IvkDecryptTRC20Parameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IvkDecryptTRC20Parameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const IvkDecryptTRC20Parameters* internal_default_instance() {
    return reinterpret_cast<const IvkDecryptTRC20Parameters*>(
               &_IvkDecryptTRC20Parameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(IvkDecryptTRC20Parameters& a, IvkDecryptTRC20Parameters& b) {
    a.Swap(&b);
  }
  inline void Swap(IvkDecryptTRC20Parameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IvkDecryptTRC20Parameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IvkDecryptTRC20Parameters* New() const final {
    return new IvkDecryptTRC20Parameters();
  }

  IvkDecryptTRC20Parameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IvkDecryptTRC20Parameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IvkDecryptTRC20Parameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IvkDecryptTRC20Parameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IvkDecryptTRC20Parameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.IvkDecryptTRC20Parameters";
  }
  protected:
  explicit IvkDecryptTRC20Parameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 7,
    kShieldedTRC20ContractAddressFieldNumber = 3,
    kIvkFieldNumber = 4,
    kAkFieldNumber = 5,
    kNkFieldNumber = 6,
    kStartBlockIndexFieldNumber = 1,
    kEndBlockIndexFieldNumber = 2,
  };
  // repeated string events = 7;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  const std::string& events(int index) const;
  std::string* mutable_events(int index);
  void set_events(int index, const std::string& value);
  void set_events(int index, std::string&& value);
  void set_events(int index, const char* value);
  void set_events(int index, const char* value, size_t size);
  std::string* add_events();
  void add_events(const std::string& value);
  void add_events(std::string&& value);
  void add_events(const char* value);
  void add_events(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& events() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_events();
  private:
  const std::string& _internal_events(int index) const;
  std::string* _internal_add_events();
  public:

  // bytes shielded_TRC20_contract_address = 3;
  void clear_shielded_trc20_contract_address();
  const std::string& shielded_trc20_contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shielded_trc20_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shielded_trc20_contract_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_shielded_trc20_contract_address();
  void set_allocated_shielded_trc20_contract_address(std::string* shielded_trc20_contract_address);
  private:
  const std::string& _internal_shielded_trc20_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shielded_trc20_contract_address(const std::string& value);
  std::string* _internal_mutable_shielded_trc20_contract_address();
  public:

  // bytes ivk = 4;
  void clear_ivk();
  const std::string& ivk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ivk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ivk();
  PROTOBUF_MUST_USE_RESULT std::string* release_ivk();
  void set_allocated_ivk(std::string* ivk);
  private:
  const std::string& _internal_ivk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ivk(const std::string& value);
  std::string* _internal_mutable_ivk();
  public:

  // bytes ak = 5;
  void clear_ak();
  const std::string& ak() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ak(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ak();
  PROTOBUF_MUST_USE_RESULT std::string* release_ak();
  void set_allocated_ak(std::string* ak);
  private:
  const std::string& _internal_ak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ak(const std::string& value);
  std::string* _internal_mutable_ak();
  public:

  // bytes nk = 6;
  void clear_nk();
  const std::string& nk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nk();
  PROTOBUF_MUST_USE_RESULT std::string* release_nk();
  void set_allocated_nk(std::string* nk);
  private:
  const std::string& _internal_nk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nk(const std::string& value);
  std::string* _internal_mutable_nk();
  public:

  // int64 start_block_index = 1;
  void clear_start_block_index();
  ::PROTOBUF_NAMESPACE_ID::int64 start_block_index() const;
  void set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_block_index() const;
  void _internal_set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 end_block_index = 2;
  void clear_end_block_index();
  ::PROTOBUF_NAMESPACE_ID::int64 end_block_index() const;
  void set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end_block_index() const;
  void _internal_set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.IvkDecryptTRC20Parameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shielded_trc20_contract_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ivk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ak_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nk_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_block_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_block_index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class OvkDecryptTRC20Parameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.OvkDecryptTRC20Parameters) */ {
 public:
  inline OvkDecryptTRC20Parameters() : OvkDecryptTRC20Parameters(nullptr) {}
  ~OvkDecryptTRC20Parameters() override;
  explicit constexpr OvkDecryptTRC20Parameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OvkDecryptTRC20Parameters(const OvkDecryptTRC20Parameters& from);
  OvkDecryptTRC20Parameters(OvkDecryptTRC20Parameters&& from) noexcept
    : OvkDecryptTRC20Parameters() {
    *this = ::std::move(from);
  }

  inline OvkDecryptTRC20Parameters& operator=(const OvkDecryptTRC20Parameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline OvkDecryptTRC20Parameters& operator=(OvkDecryptTRC20Parameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OvkDecryptTRC20Parameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const OvkDecryptTRC20Parameters* internal_default_instance() {
    return reinterpret_cast<const OvkDecryptTRC20Parameters*>(
               &_OvkDecryptTRC20Parameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(OvkDecryptTRC20Parameters& a, OvkDecryptTRC20Parameters& b) {
    a.Swap(&b);
  }
  inline void Swap(OvkDecryptTRC20Parameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OvkDecryptTRC20Parameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OvkDecryptTRC20Parameters* New() const final {
    return new OvkDecryptTRC20Parameters();
  }

  OvkDecryptTRC20Parameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OvkDecryptTRC20Parameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OvkDecryptTRC20Parameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OvkDecryptTRC20Parameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OvkDecryptTRC20Parameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.OvkDecryptTRC20Parameters";
  }
  protected:
  explicit OvkDecryptTRC20Parameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 5,
    kOvkFieldNumber = 3,
    kShieldedTRC20ContractAddressFieldNumber = 4,
    kStartBlockIndexFieldNumber = 1,
    kEndBlockIndexFieldNumber = 2,
  };
  // repeated string events = 5;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  const std::string& events(int index) const;
  std::string* mutable_events(int index);
  void set_events(int index, const std::string& value);
  void set_events(int index, std::string&& value);
  void set_events(int index, const char* value);
  void set_events(int index, const char* value, size_t size);
  std::string* add_events();
  void add_events(const std::string& value);
  void add_events(std::string&& value);
  void add_events(const char* value);
  void add_events(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& events() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_events();
  private:
  const std::string& _internal_events(int index) const;
  std::string* _internal_add_events();
  public:

  // bytes ovk = 3;
  void clear_ovk();
  const std::string& ovk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ovk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ovk();
  PROTOBUF_MUST_USE_RESULT std::string* release_ovk();
  void set_allocated_ovk(std::string* ovk);
  private:
  const std::string& _internal_ovk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ovk(const std::string& value);
  std::string* _internal_mutable_ovk();
  public:

  // bytes shielded_TRC20_contract_address = 4;
  void clear_shielded_trc20_contract_address();
  const std::string& shielded_trc20_contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shielded_trc20_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shielded_trc20_contract_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_shielded_trc20_contract_address();
  void set_allocated_shielded_trc20_contract_address(std::string* shielded_trc20_contract_address);
  private:
  const std::string& _internal_shielded_trc20_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shielded_trc20_contract_address(const std::string& value);
  std::string* _internal_mutable_shielded_trc20_contract_address();
  public:

  // int64 start_block_index = 1;
  void clear_start_block_index();
  ::PROTOBUF_NAMESPACE_ID::int64 start_block_index() const;
  void set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_block_index() const;
  void _internal_set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 end_block_index = 2;
  void clear_end_block_index();
  ::PROTOBUF_NAMESPACE_ID::int64 end_block_index() const;
  void set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end_block_index() const;
  void _internal_set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.OvkDecryptTRC20Parameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ovk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shielded_trc20_contract_address_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_block_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_block_index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class DecryptNotesTRC20_NoteTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DecryptNotesTRC20.NoteTx) */ {
 public:
  inline DecryptNotesTRC20_NoteTx() : DecryptNotesTRC20_NoteTx(nullptr) {}
  ~DecryptNotesTRC20_NoteTx() override;
  explicit constexpr DecryptNotesTRC20_NoteTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecryptNotesTRC20_NoteTx(const DecryptNotesTRC20_NoteTx& from);
  DecryptNotesTRC20_NoteTx(DecryptNotesTRC20_NoteTx&& from) noexcept
    : DecryptNotesTRC20_NoteTx() {
    *this = ::std::move(from);
  }

  inline DecryptNotesTRC20_NoteTx& operator=(const DecryptNotesTRC20_NoteTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecryptNotesTRC20_NoteTx& operator=(DecryptNotesTRC20_NoteTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecryptNotesTRC20_NoteTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecryptNotesTRC20_NoteTx* internal_default_instance() {
    return reinterpret_cast<const DecryptNotesTRC20_NoteTx*>(
               &_DecryptNotesTRC20_NoteTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(DecryptNotesTRC20_NoteTx& a, DecryptNotesTRC20_NoteTx& b) {
    a.Swap(&b);
  }
  inline void Swap(DecryptNotesTRC20_NoteTx* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecryptNotesTRC20_NoteTx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecryptNotesTRC20_NoteTx* New() const final {
    return new DecryptNotesTRC20_NoteTx();
  }

  DecryptNotesTRC20_NoteTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecryptNotesTRC20_NoteTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecryptNotesTRC20_NoteTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DecryptNotesTRC20_NoteTx& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecryptNotesTRC20_NoteTx* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DecryptNotesTRC20.NoteTx";
  }
  protected:
  explicit DecryptNotesTRC20_NoteTx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxidFieldNumber = 4,
    kToAmountFieldNumber = 6,
    kTransparentToAddressFieldNumber = 7,
    kNoteFieldNumber = 1,
    kPositionFieldNumber = 2,
    kIsSpentFieldNumber = 3,
    kIndexFieldNumber = 5,
  };
  // bytes txid = 4;
  void clear_txid();
  const std::string& txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txid();
  PROTOBUF_MUST_USE_RESULT std::string* release_txid();
  void set_allocated_txid(std::string* txid);
  private:
  const std::string& _internal_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txid(const std::string& value);
  std::string* _internal_mutable_txid();
  public:

  // string to_amount = 6;
  void clear_to_amount();
  const std::string& to_amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_amount();
  PROTOBUF_MUST_USE_RESULT std::string* release_to_amount();
  void set_allocated_to_amount(std::string* to_amount);
  private:
  const std::string& _internal_to_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_amount(const std::string& value);
  std::string* _internal_mutable_to_amount();
  public:

  // bytes transparent_to_address = 7;
  void clear_transparent_to_address();
  const std::string& transparent_to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transparent_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transparent_to_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_transparent_to_address();
  void set_allocated_transparent_to_address(std::string* transparent_to_address);
  private:
  const std::string& _internal_transparent_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transparent_to_address(const std::string& value);
  std::string* _internal_mutable_transparent_to_address();
  public:

  // .protocol.Note note = 1;
  bool has_note() const;
  private:
  bool _internal_has_note() const;
  public:
  void clear_note();
  const ::protocol::Note& note() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Note* release_note();
  ::protocol::Note* mutable_note();
  void set_allocated_note(::protocol::Note* note);
  private:
  const ::protocol::Note& _internal_note() const;
  ::protocol::Note* _internal_mutable_note();
  public:
  void unsafe_arena_set_allocated_note(
      ::protocol::Note* note);
  ::protocol::Note* unsafe_arena_release_note();

  // int64 position = 2;
  void clear_position();
  ::PROTOBUF_NAMESPACE_ID::int64 position() const;
  void set_position(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_position() const;
  void _internal_set_position(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool is_spent = 3;
  void clear_is_spent();
  bool is_spent() const;
  void set_is_spent(bool value);
  private:
  bool _internal_is_spent() const;
  void _internal_set_is_spent(bool value);
  public:

  // int32 index = 5;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::int32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.DecryptNotesTRC20.NoteTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transparent_to_address_;
  ::protocol::Note* note_;
  ::PROTOBUF_NAMESPACE_ID::int64 position_;
  bool is_spent_;
  ::PROTOBUF_NAMESPACE_ID::int32 index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class DecryptNotesTRC20 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DecryptNotesTRC20) */ {
 public:
  inline DecryptNotesTRC20() : DecryptNotesTRC20(nullptr) {}
  ~DecryptNotesTRC20() override;
  explicit constexpr DecryptNotesTRC20(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecryptNotesTRC20(const DecryptNotesTRC20& from);
  DecryptNotesTRC20(DecryptNotesTRC20&& from) noexcept
    : DecryptNotesTRC20() {
    *this = ::std::move(from);
  }

  inline DecryptNotesTRC20& operator=(const DecryptNotesTRC20& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecryptNotesTRC20& operator=(DecryptNotesTRC20&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecryptNotesTRC20& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecryptNotesTRC20* internal_default_instance() {
    return reinterpret_cast<const DecryptNotesTRC20*>(
               &_DecryptNotesTRC20_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(DecryptNotesTRC20& a, DecryptNotesTRC20& b) {
    a.Swap(&b);
  }
  inline void Swap(DecryptNotesTRC20* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecryptNotesTRC20* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecryptNotesTRC20* New() const final {
    return new DecryptNotesTRC20();
  }

  DecryptNotesTRC20* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecryptNotesTRC20>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecryptNotesTRC20& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DecryptNotesTRC20& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecryptNotesTRC20* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DecryptNotesTRC20";
  }
  protected:
  explicit DecryptNotesTRC20(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DecryptNotesTRC20_NoteTx NoteTx;

  // accessors -------------------------------------------------------

  enum : int {
    kNoteTxsFieldNumber = 1,
  };
  // repeated .protocol.DecryptNotesTRC20.NoteTx noteTxs = 1;
  int notetxs_size() const;
  private:
  int _internal_notetxs_size() const;
  public:
  void clear_notetxs();
  ::protocol::DecryptNotesTRC20_NoteTx* mutable_notetxs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotesTRC20_NoteTx >*
      mutable_notetxs();
  private:
  const ::protocol::DecryptNotesTRC20_NoteTx& _internal_notetxs(int index) const;
  ::protocol::DecryptNotesTRC20_NoteTx* _internal_add_notetxs();
  public:
  const ::protocol::DecryptNotesTRC20_NoteTx& notetxs(int index) const;
  ::protocol::DecryptNotesTRC20_NoteTx* add_notetxs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotesTRC20_NoteTx >&
      notetxs() const;

  // @@protoc_insertion_point(class_scope:protocol.DecryptNotesTRC20)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotesTRC20_NoteTx > notetxs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class NfTRC20Parameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.NfTRC20Parameters) */ {
 public:
  inline NfTRC20Parameters() : NfTRC20Parameters(nullptr) {}
  ~NfTRC20Parameters() override;
  explicit constexpr NfTRC20Parameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NfTRC20Parameters(const NfTRC20Parameters& from);
  NfTRC20Parameters(NfTRC20Parameters&& from) noexcept
    : NfTRC20Parameters() {
    *this = ::std::move(from);
  }

  inline NfTRC20Parameters& operator=(const NfTRC20Parameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline NfTRC20Parameters& operator=(NfTRC20Parameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NfTRC20Parameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const NfTRC20Parameters* internal_default_instance() {
    return reinterpret_cast<const NfTRC20Parameters*>(
               &_NfTRC20Parameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(NfTRC20Parameters& a, NfTRC20Parameters& b) {
    a.Swap(&b);
  }
  inline void Swap(NfTRC20Parameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NfTRC20Parameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NfTRC20Parameters* New() const final {
    return new NfTRC20Parameters();
  }

  NfTRC20Parameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NfTRC20Parameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NfTRC20Parameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NfTRC20Parameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NfTRC20Parameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.NfTRC20Parameters";
  }
  protected:
  explicit NfTRC20Parameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAkFieldNumber = 2,
    kNkFieldNumber = 3,
    kShieldedTRC20ContractAddressFieldNumber = 5,
    kNoteFieldNumber = 1,
    kPositionFieldNumber = 4,
  };
  // bytes ak = 2;
  void clear_ak();
  const std::string& ak() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ak(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ak();
  PROTOBUF_MUST_USE_RESULT std::string* release_ak();
  void set_allocated_ak(std::string* ak);
  private:
  const std::string& _internal_ak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ak(const std::string& value);
  std::string* _internal_mutable_ak();
  public:

  // bytes nk = 3;
  void clear_nk();
  const std::string& nk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nk();
  PROTOBUF_MUST_USE_RESULT std::string* release_nk();
  void set_allocated_nk(std::string* nk);
  private:
  const std::string& _internal_nk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nk(const std::string& value);
  std::string* _internal_mutable_nk();
  public:

  // bytes shielded_TRC20_contract_address = 5;
  void clear_shielded_trc20_contract_address();
  const std::string& shielded_trc20_contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shielded_trc20_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shielded_trc20_contract_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_shielded_trc20_contract_address();
  void set_allocated_shielded_trc20_contract_address(std::string* shielded_trc20_contract_address);
  private:
  const std::string& _internal_shielded_trc20_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shielded_trc20_contract_address(const std::string& value);
  std::string* _internal_mutable_shielded_trc20_contract_address();
  public:

  // .protocol.Note note = 1;
  bool has_note() const;
  private:
  bool _internal_has_note() const;
  public:
  void clear_note();
  const ::protocol::Note& note() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::Note* release_note();
  ::protocol::Note* mutable_note();
  void set_allocated_note(::protocol::Note* note);
  private:
  const ::protocol::Note& _internal_note() const;
  ::protocol::Note* _internal_mutable_note();
  public:
  void unsafe_arena_set_allocated_note(
      ::protocol::Note* note);
  ::protocol::Note* unsafe_arena_release_note();

  // int64 position = 4;
  void clear_position();
  ::PROTOBUF_NAMESPACE_ID::int64 position() const;
  void set_position(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_position() const;
  void _internal_set_position(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.NfTRC20Parameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ak_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shielded_trc20_contract_address_;
  ::protocol::Note* note_;
  ::PROTOBUF_NAMESPACE_ID::int64 position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class NullifierResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.NullifierResult) */ {
 public:
  inline NullifierResult() : NullifierResult(nullptr) {}
  ~NullifierResult() override;
  explicit constexpr NullifierResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NullifierResult(const NullifierResult& from);
  NullifierResult(NullifierResult&& from) noexcept
    : NullifierResult() {
    *this = ::std::move(from);
  }

  inline NullifierResult& operator=(const NullifierResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline NullifierResult& operator=(NullifierResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NullifierResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const NullifierResult* internal_default_instance() {
    return reinterpret_cast<const NullifierResult*>(
               &_NullifierResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(NullifierResult& a, NullifierResult& b) {
    a.Swap(&b);
  }
  inline void Swap(NullifierResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NullifierResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NullifierResult* New() const final {
    return new NullifierResult();
  }

  NullifierResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NullifierResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NullifierResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NullifierResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NullifierResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.NullifierResult";
  }
  protected:
  explicit NullifierResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSpentFieldNumber = 1,
  };
  // bool is_spent = 1;
  void clear_is_spent();
  bool is_spent() const;
  void set_is_spent(bool value);
  private:
  bool _internal_is_spent() const;
  void _internal_set_is_spent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.NullifierResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_spent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// -------------------------------------------------------------------

class ShieldedTRC20TriggerContractParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ShieldedTRC20TriggerContractParameters) */ {
 public:
  inline ShieldedTRC20TriggerContractParameters() : ShieldedTRC20TriggerContractParameters(nullptr) {}
  ~ShieldedTRC20TriggerContractParameters() override;
  explicit constexpr ShieldedTRC20TriggerContractParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShieldedTRC20TriggerContractParameters(const ShieldedTRC20TriggerContractParameters& from);
  ShieldedTRC20TriggerContractParameters(ShieldedTRC20TriggerContractParameters&& from) noexcept
    : ShieldedTRC20TriggerContractParameters() {
    *this = ::std::move(from);
  }

  inline ShieldedTRC20TriggerContractParameters& operator=(const ShieldedTRC20TriggerContractParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShieldedTRC20TriggerContractParameters& operator=(ShieldedTRC20TriggerContractParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShieldedTRC20TriggerContractParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShieldedTRC20TriggerContractParameters* internal_default_instance() {
    return reinterpret_cast<const ShieldedTRC20TriggerContractParameters*>(
               &_ShieldedTRC20TriggerContractParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(ShieldedTRC20TriggerContractParameters& a, ShieldedTRC20TriggerContractParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(ShieldedTRC20TriggerContractParameters* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShieldedTRC20TriggerContractParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShieldedTRC20TriggerContractParameters* New() const final {
    return new ShieldedTRC20TriggerContractParameters();
  }

  ShieldedTRC20TriggerContractParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShieldedTRC20TriggerContractParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShieldedTRC20TriggerContractParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShieldedTRC20TriggerContractParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShieldedTRC20TriggerContractParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ShieldedTRC20TriggerContractParameters";
  }
  protected:
  explicit ShieldedTRC20TriggerContractParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpendAuthoritySignatureFieldNumber = 2,
    kAmountFieldNumber = 3,
    kTransparentToAddressFieldNumber = 4,
    kShieldedTRC20ParametersFieldNumber = 1,
  };
  // repeated .protocol.BytesMessage spend_authority_signature = 2;
  int spend_authority_signature_size() const;
  private:
  int _internal_spend_authority_signature_size() const;
  public:
  void clear_spend_authority_signature();
  ::protocol::BytesMessage* mutable_spend_authority_signature(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BytesMessage >*
      mutable_spend_authority_signature();
  private:
  const ::protocol::BytesMessage& _internal_spend_authority_signature(int index) const;
  ::protocol::BytesMessage* _internal_add_spend_authority_signature();
  public:
  const ::protocol::BytesMessage& spend_authority_signature(int index) const;
  ::protocol::BytesMessage* add_spend_authority_signature();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BytesMessage >&
      spend_authority_signature() const;

  // string amount = 3;
  void clear_amount();
  const std::string& amount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amount();
  PROTOBUF_MUST_USE_RESULT std::string* release_amount();
  void set_allocated_amount(std::string* amount);
  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(const std::string& value);
  std::string* _internal_mutable_amount();
  public:

  // bytes transparent_to_address = 4;
  void clear_transparent_to_address();
  const std::string& transparent_to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transparent_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transparent_to_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_transparent_to_address();
  void set_allocated_transparent_to_address(std::string* transparent_to_address);
  private:
  const std::string& _internal_transparent_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transparent_to_address(const std::string& value);
  std::string* _internal_mutable_transparent_to_address();
  public:

  // .protocol.ShieldedTRC20Parameters shielded_TRC20_Parameters = 1;
  bool has_shielded_trc20_parameters() const;
  private:
  bool _internal_has_shielded_trc20_parameters() const;
  public:
  void clear_shielded_trc20_parameters();
  const ::protocol::ShieldedTRC20Parameters& shielded_trc20_parameters() const;
  PROTOBUF_MUST_USE_RESULT ::protocol::ShieldedTRC20Parameters* release_shielded_trc20_parameters();
  ::protocol::ShieldedTRC20Parameters* mutable_shielded_trc20_parameters();
  void set_allocated_shielded_trc20_parameters(::protocol::ShieldedTRC20Parameters* shielded_trc20_parameters);
  private:
  const ::protocol::ShieldedTRC20Parameters& _internal_shielded_trc20_parameters() const;
  ::protocol::ShieldedTRC20Parameters* _internal_mutable_shielded_trc20_parameters();
  public:
  void unsafe_arena_set_allocated_shielded_trc20_parameters(
      ::protocol::ShieldedTRC20Parameters* shielded_trc20_parameters);
  ::protocol::ShieldedTRC20Parameters* unsafe_arena_release_shielded_trc20_parameters();

  // @@protoc_insertion_point(class_scope:protocol.ShieldedTRC20TriggerContractParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BytesMessage > spend_authority_signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transparent_to_address_;
  ::protocol::ShieldedTRC20Parameters* shielded_trc20_parameters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_api_2fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Return

// bool result = 1;
inline void Return::clear_result() {
  result_ = false;
}
inline bool Return::_internal_result() const {
  return result_;
}
inline bool Return::result() const {
  // @@protoc_insertion_point(field_get:protocol.Return.result)
  return _internal_result();
}
inline void Return::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void Return::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:protocol.Return.result)
}

// .protocol.Return.response_code code = 2;
inline void Return::clear_code() {
  code_ = 0;
}
inline ::protocol::Return_response_code Return::_internal_code() const {
  return static_cast< ::protocol::Return_response_code >(code_);
}
inline ::protocol::Return_response_code Return::code() const {
  // @@protoc_insertion_point(field_get:protocol.Return.code)
  return _internal_code();
}
inline void Return::_internal_set_code(::protocol::Return_response_code value) {
  
  code_ = value;
}
inline void Return::set_code(::protocol::Return_response_code value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:protocol.Return.code)
}

// bytes message = 3;
inline void Return::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& Return::message() const {
  // @@protoc_insertion_point(field_get:protocol.Return.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Return::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Return.message)
}
inline std::string* Return::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protocol.Return.message)
  return _s;
}
inline const std::string& Return::_internal_message() const {
  return message_.Get();
}
inline void Return::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Return::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Return::release_message() {
  // @@protoc_insertion_point(field_release:protocol.Return.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Return::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Return.message)
}

// -------------------------------------------------------------------

// BlockReference

// int64 block_num = 1;
inline void BlockReference::clear_block_num() {
  block_num_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BlockReference::_internal_block_num() const {
  return block_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BlockReference::block_num() const {
  // @@protoc_insertion_point(field_get:protocol.BlockReference.block_num)
  return _internal_block_num();
}
inline void BlockReference::_internal_set_block_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  block_num_ = value;
}
inline void BlockReference::set_block_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_block_num(value);
  // @@protoc_insertion_point(field_set:protocol.BlockReference.block_num)
}

// bytes block_hash = 2;
inline void BlockReference::clear_block_hash() {
  block_hash_.ClearToEmpty();
}
inline const std::string& BlockReference::block_hash() const {
  // @@protoc_insertion_point(field_get:protocol.BlockReference.block_hash)
  return _internal_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockReference::set_block_hash(ArgT0&& arg0, ArgT... args) {
 
 block_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockReference.block_hash)
}
inline std::string* BlockReference::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:protocol.BlockReference.block_hash)
  return _s;
}
inline const std::string& BlockReference::_internal_block_hash() const {
  return block_hash_.Get();
}
inline void BlockReference::_internal_set_block_hash(const std::string& value) {
  
  block_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockReference::_internal_mutable_block_hash() {
  
  return block_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockReference::release_block_hash() {
  // @@protoc_insertion_point(field_release:protocol.BlockReference.block_hash)
  return block_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockReference::set_allocated_block_hash(std::string* block_hash) {
  if (block_hash != nullptr) {
    
  } else {
    
  }
  block_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockReference.block_hash)
}

// -------------------------------------------------------------------

// WitnessList

// repeated .protocol.Witness witnesses = 1;
inline int WitnessList::_internal_witnesses_size() const {
  return witnesses_.size();
}
inline int WitnessList::witnesses_size() const {
  return _internal_witnesses_size();
}
inline ::protocol::Witness* WitnessList::mutable_witnesses(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.WitnessList.witnesses)
  return witnesses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Witness >*
WitnessList::mutable_witnesses() {
  // @@protoc_insertion_point(field_mutable_list:protocol.WitnessList.witnesses)
  return &witnesses_;
}
inline const ::protocol::Witness& WitnessList::_internal_witnesses(int index) const {
  return witnesses_.Get(index);
}
inline const ::protocol::Witness& WitnessList::witnesses(int index) const {
  // @@protoc_insertion_point(field_get:protocol.WitnessList.witnesses)
  return _internal_witnesses(index);
}
inline ::protocol::Witness* WitnessList::_internal_add_witnesses() {
  return witnesses_.Add();
}
inline ::protocol::Witness* WitnessList::add_witnesses() {
  ::protocol::Witness* _add = _internal_add_witnesses();
  // @@protoc_insertion_point(field_add:protocol.WitnessList.witnesses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Witness >&
WitnessList::witnesses() const {
  // @@protoc_insertion_point(field_list:protocol.WitnessList.witnesses)
  return witnesses_;
}

// -------------------------------------------------------------------

// ProposalList

// repeated .protocol.Proposal proposals = 1;
inline int ProposalList::_internal_proposals_size() const {
  return proposals_.size();
}
inline int ProposalList::proposals_size() const {
  return _internal_proposals_size();
}
inline ::protocol::Proposal* ProposalList::mutable_proposals(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ProposalList.proposals)
  return proposals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Proposal >*
ProposalList::mutable_proposals() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ProposalList.proposals)
  return &proposals_;
}
inline const ::protocol::Proposal& ProposalList::_internal_proposals(int index) const {
  return proposals_.Get(index);
}
inline const ::protocol::Proposal& ProposalList::proposals(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ProposalList.proposals)
  return _internal_proposals(index);
}
inline ::protocol::Proposal* ProposalList::_internal_add_proposals() {
  return proposals_.Add();
}
inline ::protocol::Proposal* ProposalList::add_proposals() {
  ::protocol::Proposal* _add = _internal_add_proposals();
  // @@protoc_insertion_point(field_add:protocol.ProposalList.proposals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Proposal >&
ProposalList::proposals() const {
  // @@protoc_insertion_point(field_list:protocol.ProposalList.proposals)
  return proposals_;
}

// -------------------------------------------------------------------

// ExchangeList

// repeated .protocol.Exchange exchanges = 1;
inline int ExchangeList::_internal_exchanges_size() const {
  return exchanges_.size();
}
inline int ExchangeList::exchanges_size() const {
  return _internal_exchanges_size();
}
inline ::protocol::Exchange* ExchangeList::mutable_exchanges(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ExchangeList.exchanges)
  return exchanges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Exchange >*
ExchangeList::mutable_exchanges() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ExchangeList.exchanges)
  return &exchanges_;
}
inline const ::protocol::Exchange& ExchangeList::_internal_exchanges(int index) const {
  return exchanges_.Get(index);
}
inline const ::protocol::Exchange& ExchangeList::exchanges(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ExchangeList.exchanges)
  return _internal_exchanges(index);
}
inline ::protocol::Exchange* ExchangeList::_internal_add_exchanges() {
  return exchanges_.Add();
}
inline ::protocol::Exchange* ExchangeList::add_exchanges() {
  ::protocol::Exchange* _add = _internal_add_exchanges();
  // @@protoc_insertion_point(field_add:protocol.ExchangeList.exchanges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Exchange >&
ExchangeList::exchanges() const {
  // @@protoc_insertion_point(field_list:protocol.ExchangeList.exchanges)
  return exchanges_;
}

// -------------------------------------------------------------------

// AssetIssueList

// repeated .protocol.AssetIssueContract assetIssue = 1;
inline int AssetIssueList::_internal_assetissue_size() const {
  return assetissue_.size();
}
inline int AssetIssueList::assetissue_size() const {
  return _internal_assetissue_size();
}
inline ::protocol::AssetIssueContract* AssetIssueList::mutable_assetissue(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.AssetIssueList.assetIssue)
  return assetissue_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AssetIssueContract >*
AssetIssueList::mutable_assetissue() {
  // @@protoc_insertion_point(field_mutable_list:protocol.AssetIssueList.assetIssue)
  return &assetissue_;
}
inline const ::protocol::AssetIssueContract& AssetIssueList::_internal_assetissue(int index) const {
  return assetissue_.Get(index);
}
inline const ::protocol::AssetIssueContract& AssetIssueList::assetissue(int index) const {
  // @@protoc_insertion_point(field_get:protocol.AssetIssueList.assetIssue)
  return _internal_assetissue(index);
}
inline ::protocol::AssetIssueContract* AssetIssueList::_internal_add_assetissue() {
  return assetissue_.Add();
}
inline ::protocol::AssetIssueContract* AssetIssueList::add_assetissue() {
  ::protocol::AssetIssueContract* _add = _internal_add_assetissue();
  // @@protoc_insertion_point(field_add:protocol.AssetIssueList.assetIssue)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AssetIssueContract >&
AssetIssueList::assetissue() const {
  // @@protoc_insertion_point(field_list:protocol.AssetIssueList.assetIssue)
  return assetissue_;
}

// -------------------------------------------------------------------

// BlockList

// repeated .protocol.Block block = 1;
inline int BlockList::_internal_block_size() const {
  return block_.size();
}
inline int BlockList::block_size() const {
  return _internal_block_size();
}
inline ::protocol::Block* BlockList::mutable_block(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.BlockList.block)
  return block_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Block >*
BlockList::mutable_block() {
  // @@protoc_insertion_point(field_mutable_list:protocol.BlockList.block)
  return &block_;
}
inline const ::protocol::Block& BlockList::_internal_block(int index) const {
  return block_.Get(index);
}
inline const ::protocol::Block& BlockList::block(int index) const {
  // @@protoc_insertion_point(field_get:protocol.BlockList.block)
  return _internal_block(index);
}
inline ::protocol::Block* BlockList::_internal_add_block() {
  return block_.Add();
}
inline ::protocol::Block* BlockList::add_block() {
  ::protocol::Block* _add = _internal_add_block();
  // @@protoc_insertion_point(field_add:protocol.BlockList.block)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Block >&
BlockList::block() const {
  // @@protoc_insertion_point(field_list:protocol.BlockList.block)
  return block_;
}

// -------------------------------------------------------------------

// TransactionList

// repeated .protocol.Transaction transaction = 1;
inline int TransactionList::_internal_transaction_size() const {
  return transaction_.size();
}
inline int TransactionList::transaction_size() const {
  return _internal_transaction_size();
}
inline ::protocol::Transaction* TransactionList::mutable_transaction(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionList.transaction)
  return transaction_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >*
TransactionList::mutable_transaction() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionList.transaction)
  return &transaction_;
}
inline const ::protocol::Transaction& TransactionList::_internal_transaction(int index) const {
  return transaction_.Get(index);
}
inline const ::protocol::Transaction& TransactionList::transaction(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionList.transaction)
  return _internal_transaction(index);
}
inline ::protocol::Transaction* TransactionList::_internal_add_transaction() {
  return transaction_.Add();
}
inline ::protocol::Transaction* TransactionList::add_transaction() {
  ::protocol::Transaction* _add = _internal_add_transaction();
  // @@protoc_insertion_point(field_add:protocol.TransactionList.transaction)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >&
TransactionList::transaction() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionList.transaction)
  return transaction_;
}

// -------------------------------------------------------------------

// DelegatedResourceMessage

// bytes fromAddress = 1;
inline void DelegatedResourceMessage::clear_fromaddress() {
  fromaddress_.ClearToEmpty();
}
inline const std::string& DelegatedResourceMessage::fromaddress() const {
  // @@protoc_insertion_point(field_get:protocol.DelegatedResourceMessage.fromAddress)
  return _internal_fromaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegatedResourceMessage::set_fromaddress(ArgT0&& arg0, ArgT... args) {
 
 fromaddress_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.DelegatedResourceMessage.fromAddress)
}
inline std::string* DelegatedResourceMessage::mutable_fromaddress() {
  std::string* _s = _internal_mutable_fromaddress();
  // @@protoc_insertion_point(field_mutable:protocol.DelegatedResourceMessage.fromAddress)
  return _s;
}
inline const std::string& DelegatedResourceMessage::_internal_fromaddress() const {
  return fromaddress_.Get();
}
inline void DelegatedResourceMessage::_internal_set_fromaddress(const std::string& value) {
  
  fromaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DelegatedResourceMessage::_internal_mutable_fromaddress() {
  
  return fromaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DelegatedResourceMessage::release_fromaddress() {
  // @@protoc_insertion_point(field_release:protocol.DelegatedResourceMessage.fromAddress)
  return fromaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DelegatedResourceMessage::set_allocated_fromaddress(std::string* fromaddress) {
  if (fromaddress != nullptr) {
    
  } else {
    
  }
  fromaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fromaddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.DelegatedResourceMessage.fromAddress)
}

// bytes toAddress = 2;
inline void DelegatedResourceMessage::clear_toaddress() {
  toaddress_.ClearToEmpty();
}
inline const std::string& DelegatedResourceMessage::toaddress() const {
  // @@protoc_insertion_point(field_get:protocol.DelegatedResourceMessage.toAddress)
  return _internal_toaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegatedResourceMessage::set_toaddress(ArgT0&& arg0, ArgT... args) {
 
 toaddress_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.DelegatedResourceMessage.toAddress)
}
inline std::string* DelegatedResourceMessage::mutable_toaddress() {
  std::string* _s = _internal_mutable_toaddress();
  // @@protoc_insertion_point(field_mutable:protocol.DelegatedResourceMessage.toAddress)
  return _s;
}
inline const std::string& DelegatedResourceMessage::_internal_toaddress() const {
  return toaddress_.Get();
}
inline void DelegatedResourceMessage::_internal_set_toaddress(const std::string& value) {
  
  toaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DelegatedResourceMessage::_internal_mutable_toaddress() {
  
  return toaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DelegatedResourceMessage::release_toaddress() {
  // @@protoc_insertion_point(field_release:protocol.DelegatedResourceMessage.toAddress)
  return toaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DelegatedResourceMessage::set_allocated_toaddress(std::string* toaddress) {
  if (toaddress != nullptr) {
    
  } else {
    
  }
  toaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), toaddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.DelegatedResourceMessage.toAddress)
}

// -------------------------------------------------------------------

// DelegatedResourceList

// repeated .protocol.DelegatedResource delegatedResource = 1;
inline int DelegatedResourceList::_internal_delegatedresource_size() const {
  return delegatedresource_.size();
}
inline int DelegatedResourceList::delegatedresource_size() const {
  return _internal_delegatedresource_size();
}
inline ::protocol::DelegatedResource* DelegatedResourceList::mutable_delegatedresource(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.DelegatedResourceList.delegatedResource)
  return delegatedresource_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DelegatedResource >*
DelegatedResourceList::mutable_delegatedresource() {
  // @@protoc_insertion_point(field_mutable_list:protocol.DelegatedResourceList.delegatedResource)
  return &delegatedresource_;
}
inline const ::protocol::DelegatedResource& DelegatedResourceList::_internal_delegatedresource(int index) const {
  return delegatedresource_.Get(index);
}
inline const ::protocol::DelegatedResource& DelegatedResourceList::delegatedresource(int index) const {
  // @@protoc_insertion_point(field_get:protocol.DelegatedResourceList.delegatedResource)
  return _internal_delegatedresource(index);
}
inline ::protocol::DelegatedResource* DelegatedResourceList::_internal_add_delegatedresource() {
  return delegatedresource_.Add();
}
inline ::protocol::DelegatedResource* DelegatedResourceList::add_delegatedresource() {
  ::protocol::DelegatedResource* _add = _internal_add_delegatedresource();
  // @@protoc_insertion_point(field_add:protocol.DelegatedResourceList.delegatedResource)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DelegatedResource >&
DelegatedResourceList::delegatedresource() const {
  // @@protoc_insertion_point(field_list:protocol.DelegatedResourceList.delegatedResource)
  return delegatedresource_;
}

// -------------------------------------------------------------------

// NodeList

// repeated .protocol.Node nodes = 1;
inline int NodeList::_internal_nodes_size() const {
  return nodes_.size();
}
inline int NodeList::nodes_size() const {
  return _internal_nodes_size();
}
inline void NodeList::clear_nodes() {
  nodes_.Clear();
}
inline ::protocol::Node* NodeList::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.NodeList.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Node >*
NodeList::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.NodeList.nodes)
  return &nodes_;
}
inline const ::protocol::Node& NodeList::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::protocol::Node& NodeList::nodes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.NodeList.nodes)
  return _internal_nodes(index);
}
inline ::protocol::Node* NodeList::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::protocol::Node* NodeList::add_nodes() {
  ::protocol::Node* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:protocol.NodeList.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Node >&
NodeList::nodes() const {
  // @@protoc_insertion_point(field_list:protocol.NodeList.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// Node

// .protocol.Address address = 1;
inline bool Node::_internal_has_address() const {
  return this != internal_default_instance() && address_ != nullptr;
}
inline bool Node::has_address() const {
  return _internal_has_address();
}
inline void Node::clear_address() {
  if (GetArenaForAllocation() == nullptr && address_ != nullptr) {
    delete address_;
  }
  address_ = nullptr;
}
inline const ::protocol::Address& Node::_internal_address() const {
  const ::protocol::Address* p = address_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Address&>(
      ::protocol::_Address_default_instance_);
}
inline const ::protocol::Address& Node::address() const {
  // @@protoc_insertion_point(field_get:protocol.Node.address)
  return _internal_address();
}
inline void Node::unsafe_arena_set_allocated_address(
    ::protocol::Address* address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(address_);
  }
  address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Node.address)
}
inline ::protocol::Address* Node::release_address() {
  
  ::protocol::Address* temp = address_;
  address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Address* Node::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_release:protocol.Node.address)
  
  ::protocol::Address* temp = address_;
  address_ = nullptr;
  return temp;
}
inline ::protocol::Address* Node::_internal_mutable_address() {
  
  if (address_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Address>(GetArenaForAllocation());
    address_ = p;
  }
  return address_;
}
inline ::protocol::Address* Node::mutable_address() {
  ::protocol::Address* _msg = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.Node.address)
  return _msg;
}
inline void Node::set_allocated_address(::protocol::Address* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete address_;
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Address>::GetOwningArena(address);
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    
  } else {
    
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:protocol.Node.address)
}

// -------------------------------------------------------------------

// Address

// bytes host = 1;
inline void Address::clear_host() {
  host_.ClearToEmpty();
}
inline const std::string& Address::host() const {
  // @@protoc_insertion_point(field_get:protocol.Address.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Address::set_host(ArgT0&& arg0, ArgT... args) {
 
 host_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Address.host)
}
inline std::string* Address::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:protocol.Address.host)
  return _s;
}
inline const std::string& Address::_internal_host() const {
  return host_.Get();
}
inline void Address::_internal_set_host(const std::string& value) {
  
  host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Address::_internal_mutable_host() {
  
  return host_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Address::release_host() {
  // @@protoc_insertion_point(field_release:protocol.Address.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Address::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Address.host)
}

// int32 port = 2;
inline void Address::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Address::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Address::port() const {
  // @@protoc_insertion_point(field_get:protocol.Address.port)
  return _internal_port();
}
inline void Address::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void Address::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:protocol.Address.port)
}

// -------------------------------------------------------------------

// EmptyMessage

// -------------------------------------------------------------------

// NumberMessage

// int64 num = 1;
inline void NumberMessage::clear_num() {
  num_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NumberMessage::_internal_num() const {
  return num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NumberMessage::num() const {
  // @@protoc_insertion_point(field_get:protocol.NumberMessage.num)
  return _internal_num();
}
inline void NumberMessage::_internal_set_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  num_ = value;
}
inline void NumberMessage::set_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:protocol.NumberMessage.num)
}

// -------------------------------------------------------------------

// BytesMessage

// bytes value = 1;
inline void BytesMessage::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& BytesMessage::value() const {
  // @@protoc_insertion_point(field_get:protocol.BytesMessage.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BytesMessage::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BytesMessage.value)
}
inline std::string* BytesMessage::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:protocol.BytesMessage.value)
  return _s;
}
inline const std::string& BytesMessage::_internal_value() const {
  return value_.Get();
}
inline void BytesMessage::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BytesMessage::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BytesMessage::release_value() {
  // @@protoc_insertion_point(field_release:protocol.BytesMessage.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BytesMessage::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.BytesMessage.value)
}

// -------------------------------------------------------------------

// TimeMessage

// int64 beginInMilliseconds = 1;
inline void TimeMessage::clear_begininmilliseconds() {
  begininmilliseconds_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimeMessage::_internal_begininmilliseconds() const {
  return begininmilliseconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimeMessage::begininmilliseconds() const {
  // @@protoc_insertion_point(field_get:protocol.TimeMessage.beginInMilliseconds)
  return _internal_begininmilliseconds();
}
inline void TimeMessage::_internal_set_begininmilliseconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  begininmilliseconds_ = value;
}
inline void TimeMessage::set_begininmilliseconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_begininmilliseconds(value);
  // @@protoc_insertion_point(field_set:protocol.TimeMessage.beginInMilliseconds)
}

// int64 endInMilliseconds = 2;
inline void TimeMessage::clear_endinmilliseconds() {
  endinmilliseconds_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimeMessage::_internal_endinmilliseconds() const {
  return endinmilliseconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimeMessage::endinmilliseconds() const {
  // @@protoc_insertion_point(field_get:protocol.TimeMessage.endInMilliseconds)
  return _internal_endinmilliseconds();
}
inline void TimeMessage::_internal_set_endinmilliseconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  endinmilliseconds_ = value;
}
inline void TimeMessage::set_endinmilliseconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_endinmilliseconds(value);
  // @@protoc_insertion_point(field_set:protocol.TimeMessage.endInMilliseconds)
}

// -------------------------------------------------------------------

// BlockLimit

// int64 startNum = 1;
inline void BlockLimit::clear_startnum() {
  startnum_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BlockLimit::_internal_startnum() const {
  return startnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BlockLimit::startnum() const {
  // @@protoc_insertion_point(field_get:protocol.BlockLimit.startNum)
  return _internal_startnum();
}
inline void BlockLimit::_internal_set_startnum(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  startnum_ = value;
}
inline void BlockLimit::set_startnum(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_startnum(value);
  // @@protoc_insertion_point(field_set:protocol.BlockLimit.startNum)
}

// int64 endNum = 2;
inline void BlockLimit::clear_endnum() {
  endnum_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BlockLimit::_internal_endnum() const {
  return endnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BlockLimit::endnum() const {
  // @@protoc_insertion_point(field_get:protocol.BlockLimit.endNum)
  return _internal_endnum();
}
inline void BlockLimit::_internal_set_endnum(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  endnum_ = value;
}
inline void BlockLimit::set_endnum(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_endnum(value);
  // @@protoc_insertion_point(field_set:protocol.BlockLimit.endNum)
}

// -------------------------------------------------------------------

// TransactionLimit

// bytes transactionId = 1;
inline void TransactionLimit::clear_transactionid() {
  transactionid_.ClearToEmpty();
}
inline const std::string& TransactionLimit::transactionid() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionLimit.transactionId)
  return _internal_transactionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionLimit::set_transactionid(ArgT0&& arg0, ArgT... args) {
 
 transactionid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionLimit.transactionId)
}
inline std::string* TransactionLimit::mutable_transactionid() {
  std::string* _s = _internal_mutable_transactionid();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionLimit.transactionId)
  return _s;
}
inline const std::string& TransactionLimit::_internal_transactionid() const {
  return transactionid_.Get();
}
inline void TransactionLimit::_internal_set_transactionid(const std::string& value) {
  
  transactionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionLimit::_internal_mutable_transactionid() {
  
  return transactionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionLimit::release_transactionid() {
  // @@protoc_insertion_point(field_release:protocol.TransactionLimit.transactionId)
  return transactionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionLimit::set_allocated_transactionid(std::string* transactionid) {
  if (transactionid != nullptr) {
    
  } else {
    
  }
  transactionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transactionid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionLimit.transactionId)
}

// int64 limitNum = 2;
inline void TransactionLimit::clear_limitnum() {
  limitnum_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionLimit::_internal_limitnum() const {
  return limitnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionLimit::limitnum() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionLimit.limitNum)
  return _internal_limitnum();
}
inline void TransactionLimit::_internal_set_limitnum(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  limitnum_ = value;
}
inline void TransactionLimit::set_limitnum(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_limitnum(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionLimit.limitNum)
}

// -------------------------------------------------------------------

// AccountPaginated

// .protocol.Account account = 1;
inline bool AccountPaginated::_internal_has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline bool AccountPaginated::has_account() const {
  return _internal_has_account();
}
inline const ::protocol::Account& AccountPaginated::_internal_account() const {
  const ::protocol::Account* p = account_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Account&>(
      ::protocol::_Account_default_instance_);
}
inline const ::protocol::Account& AccountPaginated::account() const {
  // @@protoc_insertion_point(field_get:protocol.AccountPaginated.account)
  return _internal_account();
}
inline void AccountPaginated::unsafe_arena_set_allocated_account(
    ::protocol::Account* account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.AccountPaginated.account)
}
inline ::protocol::Account* AccountPaginated::release_account() {
  
  ::protocol::Account* temp = account_;
  account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Account* AccountPaginated::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:protocol.AccountPaginated.account)
  
  ::protocol::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::protocol::Account* AccountPaginated::_internal_mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Account>(GetArenaForAllocation());
    account_ = p;
  }
  return account_;
}
inline ::protocol::Account* AccountPaginated::mutable_account() {
  ::protocol::Account* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:protocol.AccountPaginated.account)
  return _msg;
}
inline void AccountPaginated::set_allocated_account(::protocol::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account));
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountPaginated.account)
}

// int64 offset = 2;
inline void AccountPaginated::clear_offset() {
  offset_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountPaginated::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountPaginated::offset() const {
  // @@protoc_insertion_point(field_get:protocol.AccountPaginated.offset)
  return _internal_offset();
}
inline void AccountPaginated::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_ = value;
}
inline void AccountPaginated::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:protocol.AccountPaginated.offset)
}

// int64 limit = 3;
inline void AccountPaginated::clear_limit() {
  limit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountPaginated::_internal_limit() const {
  return limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountPaginated::limit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountPaginated.limit)
  return _internal_limit();
}
inline void AccountPaginated::_internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  limit_ = value;
}
inline void AccountPaginated::set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:protocol.AccountPaginated.limit)
}

// -------------------------------------------------------------------

// TimePaginatedMessage

// .protocol.TimeMessage timeMessage = 1;
inline bool TimePaginatedMessage::_internal_has_timemessage() const {
  return this != internal_default_instance() && timemessage_ != nullptr;
}
inline bool TimePaginatedMessage::has_timemessage() const {
  return _internal_has_timemessage();
}
inline void TimePaginatedMessage::clear_timemessage() {
  if (GetArenaForAllocation() == nullptr && timemessage_ != nullptr) {
    delete timemessage_;
  }
  timemessage_ = nullptr;
}
inline const ::protocol::TimeMessage& TimePaginatedMessage::_internal_timemessage() const {
  const ::protocol::TimeMessage* p = timemessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::TimeMessage&>(
      ::protocol::_TimeMessage_default_instance_);
}
inline const ::protocol::TimeMessage& TimePaginatedMessage::timemessage() const {
  // @@protoc_insertion_point(field_get:protocol.TimePaginatedMessage.timeMessage)
  return _internal_timemessage();
}
inline void TimePaginatedMessage::unsafe_arena_set_allocated_timemessage(
    ::protocol::TimeMessage* timemessage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timemessage_);
  }
  timemessage_ = timemessage;
  if (timemessage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TimePaginatedMessage.timeMessage)
}
inline ::protocol::TimeMessage* TimePaginatedMessage::release_timemessage() {
  
  ::protocol::TimeMessage* temp = timemessage_;
  timemessage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::TimeMessage* TimePaginatedMessage::unsafe_arena_release_timemessage() {
  // @@protoc_insertion_point(field_release:protocol.TimePaginatedMessage.timeMessage)
  
  ::protocol::TimeMessage* temp = timemessage_;
  timemessage_ = nullptr;
  return temp;
}
inline ::protocol::TimeMessage* TimePaginatedMessage::_internal_mutable_timemessage() {
  
  if (timemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::TimeMessage>(GetArenaForAllocation());
    timemessage_ = p;
  }
  return timemessage_;
}
inline ::protocol::TimeMessage* TimePaginatedMessage::mutable_timemessage() {
  ::protocol::TimeMessage* _msg = _internal_mutable_timemessage();
  // @@protoc_insertion_point(field_mutable:protocol.TimePaginatedMessage.timeMessage)
  return _msg;
}
inline void TimePaginatedMessage::set_allocated_timemessage(::protocol::TimeMessage* timemessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete timemessage_;
  }
  if (timemessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::TimeMessage>::GetOwningArena(timemessage);
    if (message_arena != submessage_arena) {
      timemessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timemessage, submessage_arena);
    }
    
  } else {
    
  }
  timemessage_ = timemessage;
  // @@protoc_insertion_point(field_set_allocated:protocol.TimePaginatedMessage.timeMessage)
}

// int64 offset = 2;
inline void TimePaginatedMessage::clear_offset() {
  offset_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimePaginatedMessage::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimePaginatedMessage::offset() const {
  // @@protoc_insertion_point(field_get:protocol.TimePaginatedMessage.offset)
  return _internal_offset();
}
inline void TimePaginatedMessage::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_ = value;
}
inline void TimePaginatedMessage::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:protocol.TimePaginatedMessage.offset)
}

// int64 limit = 3;
inline void TimePaginatedMessage::clear_limit() {
  limit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimePaginatedMessage::_internal_limit() const {
  return limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimePaginatedMessage::limit() const {
  // @@protoc_insertion_point(field_get:protocol.TimePaginatedMessage.limit)
  return _internal_limit();
}
inline void TimePaginatedMessage::_internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  limit_ = value;
}
inline void TimePaginatedMessage::set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:protocol.TimePaginatedMessage.limit)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AccountNetMessage

// int64 freeNetUsed = 1;
inline void AccountNetMessage::clear_freenetused() {
  freenetused_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountNetMessage::_internal_freenetused() const {
  return freenetused_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountNetMessage::freenetused() const {
  // @@protoc_insertion_point(field_get:protocol.AccountNetMessage.freeNetUsed)
  return _internal_freenetused();
}
inline void AccountNetMessage::_internal_set_freenetused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  freenetused_ = value;
}
inline void AccountNetMessage::set_freenetused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_freenetused(value);
  // @@protoc_insertion_point(field_set:protocol.AccountNetMessage.freeNetUsed)
}

// int64 freeNetLimit = 2;
inline void AccountNetMessage::clear_freenetlimit() {
  freenetlimit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountNetMessage::_internal_freenetlimit() const {
  return freenetlimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountNetMessage::freenetlimit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountNetMessage.freeNetLimit)
  return _internal_freenetlimit();
}
inline void AccountNetMessage::_internal_set_freenetlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  freenetlimit_ = value;
}
inline void AccountNetMessage::set_freenetlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_freenetlimit(value);
  // @@protoc_insertion_point(field_set:protocol.AccountNetMessage.freeNetLimit)
}

// int64 NetUsed = 3;
inline void AccountNetMessage::clear_netused() {
  netused_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountNetMessage::_internal_netused() const {
  return netused_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountNetMessage::netused() const {
  // @@protoc_insertion_point(field_get:protocol.AccountNetMessage.NetUsed)
  return _internal_netused();
}
inline void AccountNetMessage::_internal_set_netused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  netused_ = value;
}
inline void AccountNetMessage::set_netused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_netused(value);
  // @@protoc_insertion_point(field_set:protocol.AccountNetMessage.NetUsed)
}

// int64 NetLimit = 4;
inline void AccountNetMessage::clear_netlimit() {
  netlimit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountNetMessage::_internal_netlimit() const {
  return netlimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountNetMessage::netlimit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountNetMessage.NetLimit)
  return _internal_netlimit();
}
inline void AccountNetMessage::_internal_set_netlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  netlimit_ = value;
}
inline void AccountNetMessage::set_netlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_netlimit(value);
  // @@protoc_insertion_point(field_set:protocol.AccountNetMessage.NetLimit)
}

// map<string, int64> assetNetUsed = 5;
inline int AccountNetMessage::_internal_assetnetused_size() const {
  return assetnetused_.size();
}
inline int AccountNetMessage::assetnetused_size() const {
  return _internal_assetnetused_size();
}
inline void AccountNetMessage::clear_assetnetused() {
  assetnetused_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
AccountNetMessage::_internal_assetnetused() const {
  return assetnetused_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
AccountNetMessage::assetnetused() const {
  // @@protoc_insertion_point(field_map:protocol.AccountNetMessage.assetNetUsed)
  return _internal_assetnetused();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
AccountNetMessage::_internal_mutable_assetnetused() {
  return assetnetused_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
AccountNetMessage::mutable_assetnetused() {
  // @@protoc_insertion_point(field_mutable_map:protocol.AccountNetMessage.assetNetUsed)
  return _internal_mutable_assetnetused();
}

// map<string, int64> assetNetLimit = 6;
inline int AccountNetMessage::_internal_assetnetlimit_size() const {
  return assetnetlimit_.size();
}
inline int AccountNetMessage::assetnetlimit_size() const {
  return _internal_assetnetlimit_size();
}
inline void AccountNetMessage::clear_assetnetlimit() {
  assetnetlimit_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
AccountNetMessage::_internal_assetnetlimit() const {
  return assetnetlimit_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
AccountNetMessage::assetnetlimit() const {
  // @@protoc_insertion_point(field_map:protocol.AccountNetMessage.assetNetLimit)
  return _internal_assetnetlimit();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
AccountNetMessage::_internal_mutable_assetnetlimit() {
  return assetnetlimit_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
AccountNetMessage::mutable_assetnetlimit() {
  // @@protoc_insertion_point(field_mutable_map:protocol.AccountNetMessage.assetNetLimit)
  return _internal_mutable_assetnetlimit();
}

// int64 TotalNetLimit = 7;
inline void AccountNetMessage::clear_totalnetlimit() {
  totalnetlimit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountNetMessage::_internal_totalnetlimit() const {
  return totalnetlimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountNetMessage::totalnetlimit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountNetMessage.TotalNetLimit)
  return _internal_totalnetlimit();
}
inline void AccountNetMessage::_internal_set_totalnetlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  totalnetlimit_ = value;
}
inline void AccountNetMessage::set_totalnetlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_totalnetlimit(value);
  // @@protoc_insertion_point(field_set:protocol.AccountNetMessage.TotalNetLimit)
}

// int64 TotalNetWeight = 8;
inline void AccountNetMessage::clear_totalnetweight() {
  totalnetweight_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountNetMessage::_internal_totalnetweight() const {
  return totalnetweight_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountNetMessage::totalnetweight() const {
  // @@protoc_insertion_point(field_get:protocol.AccountNetMessage.TotalNetWeight)
  return _internal_totalnetweight();
}
inline void AccountNetMessage::_internal_set_totalnetweight(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  totalnetweight_ = value;
}
inline void AccountNetMessage::set_totalnetweight(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_totalnetweight(value);
  // @@protoc_insertion_point(field_set:protocol.AccountNetMessage.TotalNetWeight)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AccountResourceMessage

// int64 freeNetUsed = 1;
inline void AccountResourceMessage::clear_freenetused() {
  freenetused_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_freenetused() const {
  return freenetused_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::freenetused() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.freeNetUsed)
  return _internal_freenetused();
}
inline void AccountResourceMessage::_internal_set_freenetused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  freenetused_ = value;
}
inline void AccountResourceMessage::set_freenetused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_freenetused(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.freeNetUsed)
}

// int64 freeNetLimit = 2;
inline void AccountResourceMessage::clear_freenetlimit() {
  freenetlimit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_freenetlimit() const {
  return freenetlimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::freenetlimit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.freeNetLimit)
  return _internal_freenetlimit();
}
inline void AccountResourceMessage::_internal_set_freenetlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  freenetlimit_ = value;
}
inline void AccountResourceMessage::set_freenetlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_freenetlimit(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.freeNetLimit)
}

// int64 NetUsed = 3;
inline void AccountResourceMessage::clear_netused() {
  netused_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_netused() const {
  return netused_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::netused() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.NetUsed)
  return _internal_netused();
}
inline void AccountResourceMessage::_internal_set_netused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  netused_ = value;
}
inline void AccountResourceMessage::set_netused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_netused(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.NetUsed)
}

// int64 NetLimit = 4;
inline void AccountResourceMessage::clear_netlimit() {
  netlimit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_netlimit() const {
  return netlimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::netlimit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.NetLimit)
  return _internal_netlimit();
}
inline void AccountResourceMessage::_internal_set_netlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  netlimit_ = value;
}
inline void AccountResourceMessage::set_netlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_netlimit(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.NetLimit)
}

// map<string, int64> assetNetUsed = 5;
inline int AccountResourceMessage::_internal_assetnetused_size() const {
  return assetnetused_.size();
}
inline int AccountResourceMessage::assetnetused_size() const {
  return _internal_assetnetused_size();
}
inline void AccountResourceMessage::clear_assetnetused() {
  assetnetused_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
AccountResourceMessage::_internal_assetnetused() const {
  return assetnetused_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
AccountResourceMessage::assetnetused() const {
  // @@protoc_insertion_point(field_map:protocol.AccountResourceMessage.assetNetUsed)
  return _internal_assetnetused();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
AccountResourceMessage::_internal_mutable_assetnetused() {
  return assetnetused_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
AccountResourceMessage::mutable_assetnetused() {
  // @@protoc_insertion_point(field_mutable_map:protocol.AccountResourceMessage.assetNetUsed)
  return _internal_mutable_assetnetused();
}

// map<string, int64> assetNetLimit = 6;
inline int AccountResourceMessage::_internal_assetnetlimit_size() const {
  return assetnetlimit_.size();
}
inline int AccountResourceMessage::assetnetlimit_size() const {
  return _internal_assetnetlimit_size();
}
inline void AccountResourceMessage::clear_assetnetlimit() {
  assetnetlimit_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
AccountResourceMessage::_internal_assetnetlimit() const {
  return assetnetlimit_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >&
AccountResourceMessage::assetnetlimit() const {
  // @@protoc_insertion_point(field_map:protocol.AccountResourceMessage.assetNetLimit)
  return _internal_assetnetlimit();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
AccountResourceMessage::_internal_mutable_assetnetlimit() {
  return assetnetlimit_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int64 >*
AccountResourceMessage::mutable_assetnetlimit() {
  // @@protoc_insertion_point(field_mutable_map:protocol.AccountResourceMessage.assetNetLimit)
  return _internal_mutable_assetnetlimit();
}

// int64 TotalNetLimit = 7;
inline void AccountResourceMessage::clear_totalnetlimit() {
  totalnetlimit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_totalnetlimit() const {
  return totalnetlimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::totalnetlimit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.TotalNetLimit)
  return _internal_totalnetlimit();
}
inline void AccountResourceMessage::_internal_set_totalnetlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  totalnetlimit_ = value;
}
inline void AccountResourceMessage::set_totalnetlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_totalnetlimit(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.TotalNetLimit)
}

// int64 TotalNetWeight = 8;
inline void AccountResourceMessage::clear_totalnetweight() {
  totalnetweight_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_totalnetweight() const {
  return totalnetweight_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::totalnetweight() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.TotalNetWeight)
  return _internal_totalnetweight();
}
inline void AccountResourceMessage::_internal_set_totalnetweight(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  totalnetweight_ = value;
}
inline void AccountResourceMessage::set_totalnetweight(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_totalnetweight(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.TotalNetWeight)
}

// int64 TotalTronPowerWeight = 9;
inline void AccountResourceMessage::clear_totaltronpowerweight() {
  totaltronpowerweight_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_totaltronpowerweight() const {
  return totaltronpowerweight_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::totaltronpowerweight() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.TotalTronPowerWeight)
  return _internal_totaltronpowerweight();
}
inline void AccountResourceMessage::_internal_set_totaltronpowerweight(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  totaltronpowerweight_ = value;
}
inline void AccountResourceMessage::set_totaltronpowerweight(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_totaltronpowerweight(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.TotalTronPowerWeight)
}

// int64 tronPowerUsed = 10;
inline void AccountResourceMessage::clear_tronpowerused() {
  tronpowerused_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_tronpowerused() const {
  return tronpowerused_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::tronpowerused() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.tronPowerUsed)
  return _internal_tronpowerused();
}
inline void AccountResourceMessage::_internal_set_tronpowerused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tronpowerused_ = value;
}
inline void AccountResourceMessage::set_tronpowerused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tronpowerused(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.tronPowerUsed)
}

// int64 tronPowerLimit = 11;
inline void AccountResourceMessage::clear_tronpowerlimit() {
  tronpowerlimit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_tronpowerlimit() const {
  return tronpowerlimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::tronpowerlimit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.tronPowerLimit)
  return _internal_tronpowerlimit();
}
inline void AccountResourceMessage::_internal_set_tronpowerlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tronpowerlimit_ = value;
}
inline void AccountResourceMessage::set_tronpowerlimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tronpowerlimit(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.tronPowerLimit)
}

// int64 EnergyUsed = 13;
inline void AccountResourceMessage::clear_energyused() {
  energyused_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_energyused() const {
  return energyused_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::energyused() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.EnergyUsed)
  return _internal_energyused();
}
inline void AccountResourceMessage::_internal_set_energyused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  energyused_ = value;
}
inline void AccountResourceMessage::set_energyused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_energyused(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.EnergyUsed)
}

// int64 EnergyLimit = 14;
inline void AccountResourceMessage::clear_energylimit() {
  energylimit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_energylimit() const {
  return energylimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::energylimit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.EnergyLimit)
  return _internal_energylimit();
}
inline void AccountResourceMessage::_internal_set_energylimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  energylimit_ = value;
}
inline void AccountResourceMessage::set_energylimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_energylimit(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.EnergyLimit)
}

// int64 TotalEnergyLimit = 15;
inline void AccountResourceMessage::clear_totalenergylimit() {
  totalenergylimit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_totalenergylimit() const {
  return totalenergylimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::totalenergylimit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.TotalEnergyLimit)
  return _internal_totalenergylimit();
}
inline void AccountResourceMessage::_internal_set_totalenergylimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  totalenergylimit_ = value;
}
inline void AccountResourceMessage::set_totalenergylimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_totalenergylimit(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.TotalEnergyLimit)
}

// int64 TotalEnergyWeight = 16;
inline void AccountResourceMessage::clear_totalenergyweight() {
  totalenergyweight_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_totalenergyweight() const {
  return totalenergyweight_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::totalenergyweight() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.TotalEnergyWeight)
  return _internal_totalenergyweight();
}
inline void AccountResourceMessage::_internal_set_totalenergyweight(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  totalenergyweight_ = value;
}
inline void AccountResourceMessage::set_totalenergyweight(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_totalenergyweight(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.TotalEnergyWeight)
}

// int64 storageUsed = 21;
inline void AccountResourceMessage::clear_storageused() {
  storageused_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_storageused() const {
  return storageused_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::storageused() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.storageUsed)
  return _internal_storageused();
}
inline void AccountResourceMessage::_internal_set_storageused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  storageused_ = value;
}
inline void AccountResourceMessage::set_storageused(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_storageused(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.storageUsed)
}

// int64 storageLimit = 22;
inline void AccountResourceMessage::clear_storagelimit() {
  storagelimit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::_internal_storagelimit() const {
  return storagelimit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AccountResourceMessage::storagelimit() const {
  // @@protoc_insertion_point(field_get:protocol.AccountResourceMessage.storageLimit)
  return _internal_storagelimit();
}
inline void AccountResourceMessage::_internal_set_storagelimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  storagelimit_ = value;
}
inline void AccountResourceMessage::set_storagelimit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_storagelimit(value);
  // @@protoc_insertion_point(field_set:protocol.AccountResourceMessage.storageLimit)
}

// -------------------------------------------------------------------

// PaginatedMessage

// int64 offset = 1;
inline void PaginatedMessage::clear_offset() {
  offset_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PaginatedMessage::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PaginatedMessage::offset() const {
  // @@protoc_insertion_point(field_get:protocol.PaginatedMessage.offset)
  return _internal_offset();
}
inline void PaginatedMessage::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_ = value;
}
inline void PaginatedMessage::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:protocol.PaginatedMessage.offset)
}

// int64 limit = 2;
inline void PaginatedMessage::clear_limit() {
  limit_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PaginatedMessage::_internal_limit() const {
  return limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PaginatedMessage::limit() const {
  // @@protoc_insertion_point(field_get:protocol.PaginatedMessage.limit)
  return _internal_limit();
}
inline void PaginatedMessage::_internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  limit_ = value;
}
inline void PaginatedMessage::set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:protocol.PaginatedMessage.limit)
}

// -------------------------------------------------------------------

// EasyTransferMessage

// bytes passPhrase = 1;
inline void EasyTransferMessage::clear_passphrase() {
  passphrase_.ClearToEmpty();
}
inline const std::string& EasyTransferMessage::passphrase() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferMessage.passPhrase)
  return _internal_passphrase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EasyTransferMessage::set_passphrase(ArgT0&& arg0, ArgT... args) {
 
 passphrase_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.EasyTransferMessage.passPhrase)
}
inline std::string* EasyTransferMessage::mutable_passphrase() {
  std::string* _s = _internal_mutable_passphrase();
  // @@protoc_insertion_point(field_mutable:protocol.EasyTransferMessage.passPhrase)
  return _s;
}
inline const std::string& EasyTransferMessage::_internal_passphrase() const {
  return passphrase_.Get();
}
inline void EasyTransferMessage::_internal_set_passphrase(const std::string& value) {
  
  passphrase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EasyTransferMessage::_internal_mutable_passphrase() {
  
  return passphrase_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EasyTransferMessage::release_passphrase() {
  // @@protoc_insertion_point(field_release:protocol.EasyTransferMessage.passPhrase)
  return passphrase_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EasyTransferMessage::set_allocated_passphrase(std::string* passphrase) {
  if (passphrase != nullptr) {
    
  } else {
    
  }
  passphrase_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), passphrase,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.EasyTransferMessage.passPhrase)
}

// bytes toAddress = 2;
inline void EasyTransferMessage::clear_toaddress() {
  toaddress_.ClearToEmpty();
}
inline const std::string& EasyTransferMessage::toaddress() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferMessage.toAddress)
  return _internal_toaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EasyTransferMessage::set_toaddress(ArgT0&& arg0, ArgT... args) {
 
 toaddress_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.EasyTransferMessage.toAddress)
}
inline std::string* EasyTransferMessage::mutable_toaddress() {
  std::string* _s = _internal_mutable_toaddress();
  // @@protoc_insertion_point(field_mutable:protocol.EasyTransferMessage.toAddress)
  return _s;
}
inline const std::string& EasyTransferMessage::_internal_toaddress() const {
  return toaddress_.Get();
}
inline void EasyTransferMessage::_internal_set_toaddress(const std::string& value) {
  
  toaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EasyTransferMessage::_internal_mutable_toaddress() {
  
  return toaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EasyTransferMessage::release_toaddress() {
  // @@protoc_insertion_point(field_release:protocol.EasyTransferMessage.toAddress)
  return toaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EasyTransferMessage::set_allocated_toaddress(std::string* toaddress) {
  if (toaddress != nullptr) {
    
  } else {
    
  }
  toaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), toaddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.EasyTransferMessage.toAddress)
}

// int64 amount = 3;
inline void EasyTransferMessage::clear_amount() {
  amount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EasyTransferMessage::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EasyTransferMessage::amount() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferMessage.amount)
  return _internal_amount();
}
inline void EasyTransferMessage::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  amount_ = value;
}
inline void EasyTransferMessage::set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:protocol.EasyTransferMessage.amount)
}

// -------------------------------------------------------------------

// EasyTransferAssetMessage

// bytes passPhrase = 1;
inline void EasyTransferAssetMessage::clear_passphrase() {
  passphrase_.ClearToEmpty();
}
inline const std::string& EasyTransferAssetMessage::passphrase() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferAssetMessage.passPhrase)
  return _internal_passphrase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EasyTransferAssetMessage::set_passphrase(ArgT0&& arg0, ArgT... args) {
 
 passphrase_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.EasyTransferAssetMessage.passPhrase)
}
inline std::string* EasyTransferAssetMessage::mutable_passphrase() {
  std::string* _s = _internal_mutable_passphrase();
  // @@protoc_insertion_point(field_mutable:protocol.EasyTransferAssetMessage.passPhrase)
  return _s;
}
inline const std::string& EasyTransferAssetMessage::_internal_passphrase() const {
  return passphrase_.Get();
}
inline void EasyTransferAssetMessage::_internal_set_passphrase(const std::string& value) {
  
  passphrase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EasyTransferAssetMessage::_internal_mutable_passphrase() {
  
  return passphrase_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EasyTransferAssetMessage::release_passphrase() {
  // @@protoc_insertion_point(field_release:protocol.EasyTransferAssetMessage.passPhrase)
  return passphrase_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EasyTransferAssetMessage::set_allocated_passphrase(std::string* passphrase) {
  if (passphrase != nullptr) {
    
  } else {
    
  }
  passphrase_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), passphrase,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.EasyTransferAssetMessage.passPhrase)
}

// bytes toAddress = 2;
inline void EasyTransferAssetMessage::clear_toaddress() {
  toaddress_.ClearToEmpty();
}
inline const std::string& EasyTransferAssetMessage::toaddress() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferAssetMessage.toAddress)
  return _internal_toaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EasyTransferAssetMessage::set_toaddress(ArgT0&& arg0, ArgT... args) {
 
 toaddress_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.EasyTransferAssetMessage.toAddress)
}
inline std::string* EasyTransferAssetMessage::mutable_toaddress() {
  std::string* _s = _internal_mutable_toaddress();
  // @@protoc_insertion_point(field_mutable:protocol.EasyTransferAssetMessage.toAddress)
  return _s;
}
inline const std::string& EasyTransferAssetMessage::_internal_toaddress() const {
  return toaddress_.Get();
}
inline void EasyTransferAssetMessage::_internal_set_toaddress(const std::string& value) {
  
  toaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EasyTransferAssetMessage::_internal_mutable_toaddress() {
  
  return toaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EasyTransferAssetMessage::release_toaddress() {
  // @@protoc_insertion_point(field_release:protocol.EasyTransferAssetMessage.toAddress)
  return toaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EasyTransferAssetMessage::set_allocated_toaddress(std::string* toaddress) {
  if (toaddress != nullptr) {
    
  } else {
    
  }
  toaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), toaddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.EasyTransferAssetMessage.toAddress)
}

// string assetId = 3;
inline void EasyTransferAssetMessage::clear_assetid() {
  assetid_.ClearToEmpty();
}
inline const std::string& EasyTransferAssetMessage::assetid() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferAssetMessage.assetId)
  return _internal_assetid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EasyTransferAssetMessage::set_assetid(ArgT0&& arg0, ArgT... args) {
 
 assetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.EasyTransferAssetMessage.assetId)
}
inline std::string* EasyTransferAssetMessage::mutable_assetid() {
  std::string* _s = _internal_mutable_assetid();
  // @@protoc_insertion_point(field_mutable:protocol.EasyTransferAssetMessage.assetId)
  return _s;
}
inline const std::string& EasyTransferAssetMessage::_internal_assetid() const {
  return assetid_.Get();
}
inline void EasyTransferAssetMessage::_internal_set_assetid(const std::string& value) {
  
  assetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EasyTransferAssetMessage::_internal_mutable_assetid() {
  
  return assetid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EasyTransferAssetMessage::release_assetid() {
  // @@protoc_insertion_point(field_release:protocol.EasyTransferAssetMessage.assetId)
  return assetid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EasyTransferAssetMessage::set_allocated_assetid(std::string* assetid) {
  if (assetid != nullptr) {
    
  } else {
    
  }
  assetid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assetid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.EasyTransferAssetMessage.assetId)
}

// int64 amount = 4;
inline void EasyTransferAssetMessage::clear_amount() {
  amount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EasyTransferAssetMessage::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EasyTransferAssetMessage::amount() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferAssetMessage.amount)
  return _internal_amount();
}
inline void EasyTransferAssetMessage::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  amount_ = value;
}
inline void EasyTransferAssetMessage::set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:protocol.EasyTransferAssetMessage.amount)
}

// -------------------------------------------------------------------

// EasyTransferByPrivateMessage

// bytes privateKey = 1;
inline void EasyTransferByPrivateMessage::clear_privatekey() {
  privatekey_.ClearToEmpty();
}
inline const std::string& EasyTransferByPrivateMessage::privatekey() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferByPrivateMessage.privateKey)
  return _internal_privatekey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EasyTransferByPrivateMessage::set_privatekey(ArgT0&& arg0, ArgT... args) {
 
 privatekey_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.EasyTransferByPrivateMessage.privateKey)
}
inline std::string* EasyTransferByPrivateMessage::mutable_privatekey() {
  std::string* _s = _internal_mutable_privatekey();
  // @@protoc_insertion_point(field_mutable:protocol.EasyTransferByPrivateMessage.privateKey)
  return _s;
}
inline const std::string& EasyTransferByPrivateMessage::_internal_privatekey() const {
  return privatekey_.Get();
}
inline void EasyTransferByPrivateMessage::_internal_set_privatekey(const std::string& value) {
  
  privatekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EasyTransferByPrivateMessage::_internal_mutable_privatekey() {
  
  return privatekey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EasyTransferByPrivateMessage::release_privatekey() {
  // @@protoc_insertion_point(field_release:protocol.EasyTransferByPrivateMessage.privateKey)
  return privatekey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EasyTransferByPrivateMessage::set_allocated_privatekey(std::string* privatekey) {
  if (privatekey != nullptr) {
    
  } else {
    
  }
  privatekey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), privatekey,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.EasyTransferByPrivateMessage.privateKey)
}

// bytes toAddress = 2;
inline void EasyTransferByPrivateMessage::clear_toaddress() {
  toaddress_.ClearToEmpty();
}
inline const std::string& EasyTransferByPrivateMessage::toaddress() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferByPrivateMessage.toAddress)
  return _internal_toaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EasyTransferByPrivateMessage::set_toaddress(ArgT0&& arg0, ArgT... args) {
 
 toaddress_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.EasyTransferByPrivateMessage.toAddress)
}
inline std::string* EasyTransferByPrivateMessage::mutable_toaddress() {
  std::string* _s = _internal_mutable_toaddress();
  // @@protoc_insertion_point(field_mutable:protocol.EasyTransferByPrivateMessage.toAddress)
  return _s;
}
inline const std::string& EasyTransferByPrivateMessage::_internal_toaddress() const {
  return toaddress_.Get();
}
inline void EasyTransferByPrivateMessage::_internal_set_toaddress(const std::string& value) {
  
  toaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EasyTransferByPrivateMessage::_internal_mutable_toaddress() {
  
  return toaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EasyTransferByPrivateMessage::release_toaddress() {
  // @@protoc_insertion_point(field_release:protocol.EasyTransferByPrivateMessage.toAddress)
  return toaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EasyTransferByPrivateMessage::set_allocated_toaddress(std::string* toaddress) {
  if (toaddress != nullptr) {
    
  } else {
    
  }
  toaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), toaddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.EasyTransferByPrivateMessage.toAddress)
}

// int64 amount = 3;
inline void EasyTransferByPrivateMessage::clear_amount() {
  amount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EasyTransferByPrivateMessage::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EasyTransferByPrivateMessage::amount() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferByPrivateMessage.amount)
  return _internal_amount();
}
inline void EasyTransferByPrivateMessage::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  amount_ = value;
}
inline void EasyTransferByPrivateMessage::set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:protocol.EasyTransferByPrivateMessage.amount)
}

// -------------------------------------------------------------------

// EasyTransferAssetByPrivateMessage

// bytes privateKey = 1;
inline void EasyTransferAssetByPrivateMessage::clear_privatekey() {
  privatekey_.ClearToEmpty();
}
inline const std::string& EasyTransferAssetByPrivateMessage::privatekey() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferAssetByPrivateMessage.privateKey)
  return _internal_privatekey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EasyTransferAssetByPrivateMessage::set_privatekey(ArgT0&& arg0, ArgT... args) {
 
 privatekey_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.EasyTransferAssetByPrivateMessage.privateKey)
}
inline std::string* EasyTransferAssetByPrivateMessage::mutable_privatekey() {
  std::string* _s = _internal_mutable_privatekey();
  // @@protoc_insertion_point(field_mutable:protocol.EasyTransferAssetByPrivateMessage.privateKey)
  return _s;
}
inline const std::string& EasyTransferAssetByPrivateMessage::_internal_privatekey() const {
  return privatekey_.Get();
}
inline void EasyTransferAssetByPrivateMessage::_internal_set_privatekey(const std::string& value) {
  
  privatekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EasyTransferAssetByPrivateMessage::_internal_mutable_privatekey() {
  
  return privatekey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EasyTransferAssetByPrivateMessage::release_privatekey() {
  // @@protoc_insertion_point(field_release:protocol.EasyTransferAssetByPrivateMessage.privateKey)
  return privatekey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EasyTransferAssetByPrivateMessage::set_allocated_privatekey(std::string* privatekey) {
  if (privatekey != nullptr) {
    
  } else {
    
  }
  privatekey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), privatekey,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.EasyTransferAssetByPrivateMessage.privateKey)
}

// bytes toAddress = 2;
inline void EasyTransferAssetByPrivateMessage::clear_toaddress() {
  toaddress_.ClearToEmpty();
}
inline const std::string& EasyTransferAssetByPrivateMessage::toaddress() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferAssetByPrivateMessage.toAddress)
  return _internal_toaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EasyTransferAssetByPrivateMessage::set_toaddress(ArgT0&& arg0, ArgT... args) {
 
 toaddress_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.EasyTransferAssetByPrivateMessage.toAddress)
}
inline std::string* EasyTransferAssetByPrivateMessage::mutable_toaddress() {
  std::string* _s = _internal_mutable_toaddress();
  // @@protoc_insertion_point(field_mutable:protocol.EasyTransferAssetByPrivateMessage.toAddress)
  return _s;
}
inline const std::string& EasyTransferAssetByPrivateMessage::_internal_toaddress() const {
  return toaddress_.Get();
}
inline void EasyTransferAssetByPrivateMessage::_internal_set_toaddress(const std::string& value) {
  
  toaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EasyTransferAssetByPrivateMessage::_internal_mutable_toaddress() {
  
  return toaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EasyTransferAssetByPrivateMessage::release_toaddress() {
  // @@protoc_insertion_point(field_release:protocol.EasyTransferAssetByPrivateMessage.toAddress)
  return toaddress_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EasyTransferAssetByPrivateMessage::set_allocated_toaddress(std::string* toaddress) {
  if (toaddress != nullptr) {
    
  } else {
    
  }
  toaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), toaddress,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.EasyTransferAssetByPrivateMessage.toAddress)
}

// string assetId = 3;
inline void EasyTransferAssetByPrivateMessage::clear_assetid() {
  assetid_.ClearToEmpty();
}
inline const std::string& EasyTransferAssetByPrivateMessage::assetid() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferAssetByPrivateMessage.assetId)
  return _internal_assetid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EasyTransferAssetByPrivateMessage::set_assetid(ArgT0&& arg0, ArgT... args) {
 
 assetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.EasyTransferAssetByPrivateMessage.assetId)
}
inline std::string* EasyTransferAssetByPrivateMessage::mutable_assetid() {
  std::string* _s = _internal_mutable_assetid();
  // @@protoc_insertion_point(field_mutable:protocol.EasyTransferAssetByPrivateMessage.assetId)
  return _s;
}
inline const std::string& EasyTransferAssetByPrivateMessage::_internal_assetid() const {
  return assetid_.Get();
}
inline void EasyTransferAssetByPrivateMessage::_internal_set_assetid(const std::string& value) {
  
  assetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EasyTransferAssetByPrivateMessage::_internal_mutable_assetid() {
  
  return assetid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EasyTransferAssetByPrivateMessage::release_assetid() {
  // @@protoc_insertion_point(field_release:protocol.EasyTransferAssetByPrivateMessage.assetId)
  return assetid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EasyTransferAssetByPrivateMessage::set_allocated_assetid(std::string* assetid) {
  if (assetid != nullptr) {
    
  } else {
    
  }
  assetid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assetid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.EasyTransferAssetByPrivateMessage.assetId)
}

// int64 amount = 4;
inline void EasyTransferAssetByPrivateMessage::clear_amount() {
  amount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EasyTransferAssetByPrivateMessage::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EasyTransferAssetByPrivateMessage::amount() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferAssetByPrivateMessage.amount)
  return _internal_amount();
}
inline void EasyTransferAssetByPrivateMessage::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  amount_ = value;
}
inline void EasyTransferAssetByPrivateMessage::set_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:protocol.EasyTransferAssetByPrivateMessage.amount)
}

// -------------------------------------------------------------------

// EasyTransferResponse

// .protocol.Transaction transaction = 1;
inline bool EasyTransferResponse::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool EasyTransferResponse::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::protocol::Transaction& EasyTransferResponse::_internal_transaction() const {
  const ::protocol::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Transaction&>(
      ::protocol::_Transaction_default_instance_);
}
inline const ::protocol::Transaction& EasyTransferResponse::transaction() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferResponse.transaction)
  return _internal_transaction();
}
inline void EasyTransferResponse::unsafe_arena_set_allocated_transaction(
    ::protocol::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.EasyTransferResponse.transaction)
}
inline ::protocol::Transaction* EasyTransferResponse::release_transaction() {
  
  ::protocol::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Transaction* EasyTransferResponse::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:protocol.EasyTransferResponse.transaction)
  
  ::protocol::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::protocol::Transaction* EasyTransferResponse::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::protocol::Transaction* EasyTransferResponse::mutable_transaction() {
  ::protocol::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:protocol.EasyTransferResponse.transaction)
  return _msg;
}
inline void EasyTransferResponse::set_allocated_transaction(::protocol::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:protocol.EasyTransferResponse.transaction)
}

// .protocol.Return result = 2;
inline bool EasyTransferResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool EasyTransferResponse::has_result() const {
  return _internal_has_result();
}
inline void EasyTransferResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::protocol::Return& EasyTransferResponse::_internal_result() const {
  const ::protocol::Return* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Return&>(
      ::protocol::_Return_default_instance_);
}
inline const ::protocol::Return& EasyTransferResponse::result() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferResponse.result)
  return _internal_result();
}
inline void EasyTransferResponse::unsafe_arena_set_allocated_result(
    ::protocol::Return* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.EasyTransferResponse.result)
}
inline ::protocol::Return* EasyTransferResponse::release_result() {
  
  ::protocol::Return* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Return* EasyTransferResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:protocol.EasyTransferResponse.result)
  
  ::protocol::Return* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::protocol::Return* EasyTransferResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Return>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::protocol::Return* EasyTransferResponse::mutable_result() {
  ::protocol::Return* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:protocol.EasyTransferResponse.result)
  return _msg;
}
inline void EasyTransferResponse::set_allocated_result(::protocol::Return* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Return>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:protocol.EasyTransferResponse.result)
}

// bytes txid = 3;
inline void EasyTransferResponse::clear_txid() {
  txid_.ClearToEmpty();
}
inline const std::string& EasyTransferResponse::txid() const {
  // @@protoc_insertion_point(field_get:protocol.EasyTransferResponse.txid)
  return _internal_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EasyTransferResponse::set_txid(ArgT0&& arg0, ArgT... args) {
 
 txid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.EasyTransferResponse.txid)
}
inline std::string* EasyTransferResponse::mutable_txid() {
  std::string* _s = _internal_mutable_txid();
  // @@protoc_insertion_point(field_mutable:protocol.EasyTransferResponse.txid)
  return _s;
}
inline const std::string& EasyTransferResponse::_internal_txid() const {
  return txid_.Get();
}
inline void EasyTransferResponse::_internal_set_txid(const std::string& value) {
  
  txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EasyTransferResponse::_internal_mutable_txid() {
  
  return txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EasyTransferResponse::release_txid() {
  // @@protoc_insertion_point(field_release:protocol.EasyTransferResponse.txid)
  return txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EasyTransferResponse::set_allocated_txid(std::string* txid) {
  if (txid != nullptr) {
    
  } else {
    
  }
  txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), txid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.EasyTransferResponse.txid)
}

// -------------------------------------------------------------------

// AddressPrKeyPairMessage

// string address = 1;
inline void AddressPrKeyPairMessage::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& AddressPrKeyPairMessage::address() const {
  // @@protoc_insertion_point(field_get:protocol.AddressPrKeyPairMessage.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddressPrKeyPairMessage::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AddressPrKeyPairMessage.address)
}
inline std::string* AddressPrKeyPairMessage::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.AddressPrKeyPairMessage.address)
  return _s;
}
inline const std::string& AddressPrKeyPairMessage::_internal_address() const {
  return address_.Get();
}
inline void AddressPrKeyPairMessage::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddressPrKeyPairMessage::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddressPrKeyPairMessage::release_address() {
  // @@protoc_insertion_point(field_release:protocol.AddressPrKeyPairMessage.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddressPrKeyPairMessage::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.AddressPrKeyPairMessage.address)
}

// string privateKey = 2;
inline void AddressPrKeyPairMessage::clear_privatekey() {
  privatekey_.ClearToEmpty();
}
inline const std::string& AddressPrKeyPairMessage::privatekey() const {
  // @@protoc_insertion_point(field_get:protocol.AddressPrKeyPairMessage.privateKey)
  return _internal_privatekey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddressPrKeyPairMessage::set_privatekey(ArgT0&& arg0, ArgT... args) {
 
 privatekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AddressPrKeyPairMessage.privateKey)
}
inline std::string* AddressPrKeyPairMessage::mutable_privatekey() {
  std::string* _s = _internal_mutable_privatekey();
  // @@protoc_insertion_point(field_mutable:protocol.AddressPrKeyPairMessage.privateKey)
  return _s;
}
inline const std::string& AddressPrKeyPairMessage::_internal_privatekey() const {
  return privatekey_.Get();
}
inline void AddressPrKeyPairMessage::_internal_set_privatekey(const std::string& value) {
  
  privatekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddressPrKeyPairMessage::_internal_mutable_privatekey() {
  
  return privatekey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddressPrKeyPairMessage::release_privatekey() {
  // @@protoc_insertion_point(field_release:protocol.AddressPrKeyPairMessage.privateKey)
  return privatekey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddressPrKeyPairMessage::set_allocated_privatekey(std::string* privatekey) {
  if (privatekey != nullptr) {
    
  } else {
    
  }
  privatekey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), privatekey,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.AddressPrKeyPairMessage.privateKey)
}

// -------------------------------------------------------------------

// TransactionExtention

// .protocol.Transaction transaction = 1;
inline bool TransactionExtention::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool TransactionExtention::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::protocol::Transaction& TransactionExtention::_internal_transaction() const {
  const ::protocol::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Transaction&>(
      ::protocol::_Transaction_default_instance_);
}
inline const ::protocol::Transaction& TransactionExtention::transaction() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionExtention.transaction)
  return _internal_transaction();
}
inline void TransactionExtention::unsafe_arena_set_allocated_transaction(
    ::protocol::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TransactionExtention.transaction)
}
inline ::protocol::Transaction* TransactionExtention::release_transaction() {
  
  ::protocol::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Transaction* TransactionExtention::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:protocol.TransactionExtention.transaction)
  
  ::protocol::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::protocol::Transaction* TransactionExtention::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::protocol::Transaction* TransactionExtention::mutable_transaction() {
  ::protocol::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionExtention.transaction)
  return _msg;
}
inline void TransactionExtention::set_allocated_transaction(::protocol::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionExtention.transaction)
}

// bytes txid = 2;
inline void TransactionExtention::clear_txid() {
  txid_.ClearToEmpty();
}
inline const std::string& TransactionExtention::txid() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionExtention.txid)
  return _internal_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionExtention::set_txid(ArgT0&& arg0, ArgT... args) {
 
 txid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionExtention.txid)
}
inline std::string* TransactionExtention::mutable_txid() {
  std::string* _s = _internal_mutable_txid();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionExtention.txid)
  return _s;
}
inline const std::string& TransactionExtention::_internal_txid() const {
  return txid_.Get();
}
inline void TransactionExtention::_internal_set_txid(const std::string& value) {
  
  txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionExtention::_internal_mutable_txid() {
  
  return txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionExtention::release_txid() {
  // @@protoc_insertion_point(field_release:protocol.TransactionExtention.txid)
  return txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionExtention::set_allocated_txid(std::string* txid) {
  if (txid != nullptr) {
    
  } else {
    
  }
  txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), txid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionExtention.txid)
}

// repeated bytes constant_result = 3;
inline int TransactionExtention::_internal_constant_result_size() const {
  return constant_result_.size();
}
inline int TransactionExtention::constant_result_size() const {
  return _internal_constant_result_size();
}
inline void TransactionExtention::clear_constant_result() {
  constant_result_.Clear();
}
inline std::string* TransactionExtention::add_constant_result() {
  std::string* _s = _internal_add_constant_result();
  // @@protoc_insertion_point(field_add_mutable:protocol.TransactionExtention.constant_result)
  return _s;
}
inline const std::string& TransactionExtention::_internal_constant_result(int index) const {
  return constant_result_.Get(index);
}
inline const std::string& TransactionExtention::constant_result(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionExtention.constant_result)
  return _internal_constant_result(index);
}
inline std::string* TransactionExtention::mutable_constant_result(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionExtention.constant_result)
  return constant_result_.Mutable(index);
}
inline void TransactionExtention::set_constant_result(int index, const std::string& value) {
  constant_result_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionExtention.constant_result)
}
inline void TransactionExtention::set_constant_result(int index, std::string&& value) {
  constant_result_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.TransactionExtention.constant_result)
}
inline void TransactionExtention::set_constant_result(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  constant_result_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.TransactionExtention.constant_result)
}
inline void TransactionExtention::set_constant_result(int index, const void* value, size_t size) {
  constant_result_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.TransactionExtention.constant_result)
}
inline std::string* TransactionExtention::_internal_add_constant_result() {
  return constant_result_.Add();
}
inline void TransactionExtention::add_constant_result(const std::string& value) {
  constant_result_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.TransactionExtention.constant_result)
}
inline void TransactionExtention::add_constant_result(std::string&& value) {
  constant_result_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.TransactionExtention.constant_result)
}
inline void TransactionExtention::add_constant_result(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  constant_result_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.TransactionExtention.constant_result)
}
inline void TransactionExtention::add_constant_result(const void* value, size_t size) {
  constant_result_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.TransactionExtention.constant_result)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransactionExtention::constant_result() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionExtention.constant_result)
  return constant_result_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransactionExtention::mutable_constant_result() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionExtention.constant_result)
  return &constant_result_;
}

// .protocol.Return result = 4;
inline bool TransactionExtention::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool TransactionExtention::has_result() const {
  return _internal_has_result();
}
inline void TransactionExtention::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::protocol::Return& TransactionExtention::_internal_result() const {
  const ::protocol::Return* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Return&>(
      ::protocol::_Return_default_instance_);
}
inline const ::protocol::Return& TransactionExtention::result() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionExtention.result)
  return _internal_result();
}
inline void TransactionExtention::unsafe_arena_set_allocated_result(
    ::protocol::Return* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TransactionExtention.result)
}
inline ::protocol::Return* TransactionExtention::release_result() {
  
  ::protocol::Return* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Return* TransactionExtention::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:protocol.TransactionExtention.result)
  
  ::protocol::Return* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::protocol::Return* TransactionExtention::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Return>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::protocol::Return* TransactionExtention::mutable_result() {
  ::protocol::Return* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionExtention.result)
  return _msg;
}
inline void TransactionExtention::set_allocated_result(::protocol::Return* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Return>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionExtention.result)
}

// int64 energy_used = 5;
inline void TransactionExtention::clear_energy_used() {
  energy_used_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionExtention::_internal_energy_used() const {
  return energy_used_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionExtention::energy_used() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionExtention.energy_used)
  return _internal_energy_used();
}
inline void TransactionExtention::_internal_set_energy_used(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  energy_used_ = value;
}
inline void TransactionExtention::set_energy_used(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_energy_used(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionExtention.energy_used)
}

// -------------------------------------------------------------------

// BlockExtention

// repeated .protocol.TransactionExtention transactions = 1;
inline int BlockExtention::_internal_transactions_size() const {
  return transactions_.size();
}
inline int BlockExtention::transactions_size() const {
  return _internal_transactions_size();
}
inline void BlockExtention::clear_transactions() {
  transactions_.Clear();
}
inline ::protocol::TransactionExtention* BlockExtention::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.BlockExtention.transactions)
  return transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionExtention >*
BlockExtention::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:protocol.BlockExtention.transactions)
  return &transactions_;
}
inline const ::protocol::TransactionExtention& BlockExtention::_internal_transactions(int index) const {
  return transactions_.Get(index);
}
inline const ::protocol::TransactionExtention& BlockExtention::transactions(int index) const {
  // @@protoc_insertion_point(field_get:protocol.BlockExtention.transactions)
  return _internal_transactions(index);
}
inline ::protocol::TransactionExtention* BlockExtention::_internal_add_transactions() {
  return transactions_.Add();
}
inline ::protocol::TransactionExtention* BlockExtention::add_transactions() {
  ::protocol::TransactionExtention* _add = _internal_add_transactions();
  // @@protoc_insertion_point(field_add:protocol.BlockExtention.transactions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionExtention >&
BlockExtention::transactions() const {
  // @@protoc_insertion_point(field_list:protocol.BlockExtention.transactions)
  return transactions_;
}

// .protocol.BlockHeader block_header = 2;
inline bool BlockExtention::_internal_has_block_header() const {
  return this != internal_default_instance() && block_header_ != nullptr;
}
inline bool BlockExtention::has_block_header() const {
  return _internal_has_block_header();
}
inline const ::protocol::BlockHeader& BlockExtention::_internal_block_header() const {
  const ::protocol::BlockHeader* p = block_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::BlockHeader&>(
      ::protocol::_BlockHeader_default_instance_);
}
inline const ::protocol::BlockHeader& BlockExtention::block_header() const {
  // @@protoc_insertion_point(field_get:protocol.BlockExtention.block_header)
  return _internal_block_header();
}
inline void BlockExtention::unsafe_arena_set_allocated_block_header(
    ::protocol::BlockHeader* block_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_header_);
  }
  block_header_ = block_header;
  if (block_header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.BlockExtention.block_header)
}
inline ::protocol::BlockHeader* BlockExtention::release_block_header() {
  
  ::protocol::BlockHeader* temp = block_header_;
  block_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::BlockHeader* BlockExtention::unsafe_arena_release_block_header() {
  // @@protoc_insertion_point(field_release:protocol.BlockExtention.block_header)
  
  ::protocol::BlockHeader* temp = block_header_;
  block_header_ = nullptr;
  return temp;
}
inline ::protocol::BlockHeader* BlockExtention::_internal_mutable_block_header() {
  
  if (block_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::BlockHeader>(GetArenaForAllocation());
    block_header_ = p;
  }
  return block_header_;
}
inline ::protocol::BlockHeader* BlockExtention::mutable_block_header() {
  ::protocol::BlockHeader* _msg = _internal_mutable_block_header();
  // @@protoc_insertion_point(field_mutable:protocol.BlockExtention.block_header)
  return _msg;
}
inline void BlockExtention::set_allocated_block_header(::protocol::BlockHeader* block_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_header_);
  }
  if (block_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_header));
    if (message_arena != submessage_arena) {
      block_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_header, submessage_arena);
    }
    
  } else {
    
  }
  block_header_ = block_header;
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockExtention.block_header)
}

// bytes blockid = 3;
inline void BlockExtention::clear_blockid() {
  blockid_.ClearToEmpty();
}
inline const std::string& BlockExtention::blockid() const {
  // @@protoc_insertion_point(field_get:protocol.BlockExtention.blockid)
  return _internal_blockid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockExtention::set_blockid(ArgT0&& arg0, ArgT... args) {
 
 blockid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockExtention.blockid)
}
inline std::string* BlockExtention::mutable_blockid() {
  std::string* _s = _internal_mutable_blockid();
  // @@protoc_insertion_point(field_mutable:protocol.BlockExtention.blockid)
  return _s;
}
inline const std::string& BlockExtention::_internal_blockid() const {
  return blockid_.Get();
}
inline void BlockExtention::_internal_set_blockid(const std::string& value) {
  
  blockid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockExtention::_internal_mutable_blockid() {
  
  return blockid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockExtention::release_blockid() {
  // @@protoc_insertion_point(field_release:protocol.BlockExtention.blockid)
  return blockid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockExtention::set_allocated_blockid(std::string* blockid) {
  if (blockid != nullptr) {
    
  } else {
    
  }
  blockid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blockid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockExtention.blockid)
}

// -------------------------------------------------------------------

// BlockListExtention

// repeated .protocol.BlockExtention block = 1;
inline int BlockListExtention::_internal_block_size() const {
  return block_.size();
}
inline int BlockListExtention::block_size() const {
  return _internal_block_size();
}
inline void BlockListExtention::clear_block() {
  block_.Clear();
}
inline ::protocol::BlockExtention* BlockListExtention::mutable_block(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.BlockListExtention.block)
  return block_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockExtention >*
BlockListExtention::mutable_block() {
  // @@protoc_insertion_point(field_mutable_list:protocol.BlockListExtention.block)
  return &block_;
}
inline const ::protocol::BlockExtention& BlockListExtention::_internal_block(int index) const {
  return block_.Get(index);
}
inline const ::protocol::BlockExtention& BlockListExtention::block(int index) const {
  // @@protoc_insertion_point(field_get:protocol.BlockListExtention.block)
  return _internal_block(index);
}
inline ::protocol::BlockExtention* BlockListExtention::_internal_add_block() {
  return block_.Add();
}
inline ::protocol::BlockExtention* BlockListExtention::add_block() {
  ::protocol::BlockExtention* _add = _internal_add_block();
  // @@protoc_insertion_point(field_add:protocol.BlockListExtention.block)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockExtention >&
BlockListExtention::block() const {
  // @@protoc_insertion_point(field_list:protocol.BlockListExtention.block)
  return block_;
}

// -------------------------------------------------------------------

// TransactionListExtention

// repeated .protocol.TransactionExtention transaction = 1;
inline int TransactionListExtention::_internal_transaction_size() const {
  return transaction_.size();
}
inline int TransactionListExtention::transaction_size() const {
  return _internal_transaction_size();
}
inline void TransactionListExtention::clear_transaction() {
  transaction_.Clear();
}
inline ::protocol::TransactionExtention* TransactionListExtention::mutable_transaction(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionListExtention.transaction)
  return transaction_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionExtention >*
TransactionListExtention::mutable_transaction() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionListExtention.transaction)
  return &transaction_;
}
inline const ::protocol::TransactionExtention& TransactionListExtention::_internal_transaction(int index) const {
  return transaction_.Get(index);
}
inline const ::protocol::TransactionExtention& TransactionListExtention::transaction(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionListExtention.transaction)
  return _internal_transaction(index);
}
inline ::protocol::TransactionExtention* TransactionListExtention::_internal_add_transaction() {
  return transaction_.Add();
}
inline ::protocol::TransactionExtention* TransactionListExtention::add_transaction() {
  ::protocol::TransactionExtention* _add = _internal_add_transaction();
  // @@protoc_insertion_point(field_add:protocol.TransactionListExtention.transaction)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionExtention >&
TransactionListExtention::transaction() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionListExtention.transaction)
  return transaction_;
}

// -------------------------------------------------------------------

// BlockIncrementalMerkleTree

// int64 number = 1;
inline void BlockIncrementalMerkleTree::clear_number() {
  number_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BlockIncrementalMerkleTree::_internal_number() const {
  return number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BlockIncrementalMerkleTree::number() const {
  // @@protoc_insertion_point(field_get:protocol.BlockIncrementalMerkleTree.number)
  return _internal_number();
}
inline void BlockIncrementalMerkleTree::_internal_set_number(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  number_ = value;
}
inline void BlockIncrementalMerkleTree::set_number(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:protocol.BlockIncrementalMerkleTree.number)
}

// .protocol.IncrementalMerkleTree merkleTree = 2;
inline bool BlockIncrementalMerkleTree::_internal_has_merkletree() const {
  return this != internal_default_instance() && merkletree_ != nullptr;
}
inline bool BlockIncrementalMerkleTree::has_merkletree() const {
  return _internal_has_merkletree();
}
inline const ::protocol::IncrementalMerkleTree& BlockIncrementalMerkleTree::_internal_merkletree() const {
  const ::protocol::IncrementalMerkleTree* p = merkletree_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::IncrementalMerkleTree&>(
      ::protocol::_IncrementalMerkleTree_default_instance_);
}
inline const ::protocol::IncrementalMerkleTree& BlockIncrementalMerkleTree::merkletree() const {
  // @@protoc_insertion_point(field_get:protocol.BlockIncrementalMerkleTree.merkleTree)
  return _internal_merkletree();
}
inline void BlockIncrementalMerkleTree::unsafe_arena_set_allocated_merkletree(
    ::protocol::IncrementalMerkleTree* merkletree) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(merkletree_);
  }
  merkletree_ = merkletree;
  if (merkletree) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.BlockIncrementalMerkleTree.merkleTree)
}
inline ::protocol::IncrementalMerkleTree* BlockIncrementalMerkleTree::release_merkletree() {
  
  ::protocol::IncrementalMerkleTree* temp = merkletree_;
  merkletree_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::IncrementalMerkleTree* BlockIncrementalMerkleTree::unsafe_arena_release_merkletree() {
  // @@protoc_insertion_point(field_release:protocol.BlockIncrementalMerkleTree.merkleTree)
  
  ::protocol::IncrementalMerkleTree* temp = merkletree_;
  merkletree_ = nullptr;
  return temp;
}
inline ::protocol::IncrementalMerkleTree* BlockIncrementalMerkleTree::_internal_mutable_merkletree() {
  
  if (merkletree_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::IncrementalMerkleTree>(GetArenaForAllocation());
    merkletree_ = p;
  }
  return merkletree_;
}
inline ::protocol::IncrementalMerkleTree* BlockIncrementalMerkleTree::mutable_merkletree() {
  ::protocol::IncrementalMerkleTree* _msg = _internal_mutable_merkletree();
  // @@protoc_insertion_point(field_mutable:protocol.BlockIncrementalMerkleTree.merkleTree)
  return _msg;
}
inline void BlockIncrementalMerkleTree::set_allocated_merkletree(::protocol::IncrementalMerkleTree* merkletree) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(merkletree_);
  }
  if (merkletree) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(merkletree));
    if (message_arena != submessage_arena) {
      merkletree = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, merkletree, submessage_arena);
    }
    
  } else {
    
  }
  merkletree_ = merkletree;
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockIncrementalMerkleTree.merkleTree)
}

// -------------------------------------------------------------------

// TransactionSignWeight_Result

// .protocol.TransactionSignWeight.Result.response_code code = 1;
inline void TransactionSignWeight_Result::clear_code() {
  code_ = 0;
}
inline ::protocol::TransactionSignWeight_Result_response_code TransactionSignWeight_Result::_internal_code() const {
  return static_cast< ::protocol::TransactionSignWeight_Result_response_code >(code_);
}
inline ::protocol::TransactionSignWeight_Result_response_code TransactionSignWeight_Result::code() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionSignWeight.Result.code)
  return _internal_code();
}
inline void TransactionSignWeight_Result::_internal_set_code(::protocol::TransactionSignWeight_Result_response_code value) {
  
  code_ = value;
}
inline void TransactionSignWeight_Result::set_code(::protocol::TransactionSignWeight_Result_response_code value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionSignWeight.Result.code)
}

// string message = 2;
inline void TransactionSignWeight_Result::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& TransactionSignWeight_Result::message() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionSignWeight.Result.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionSignWeight_Result::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionSignWeight.Result.message)
}
inline std::string* TransactionSignWeight_Result::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionSignWeight.Result.message)
  return _s;
}
inline const std::string& TransactionSignWeight_Result::_internal_message() const {
  return message_.Get();
}
inline void TransactionSignWeight_Result::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionSignWeight_Result::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionSignWeight_Result::release_message() {
  // @@protoc_insertion_point(field_release:protocol.TransactionSignWeight.Result.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionSignWeight_Result::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionSignWeight.Result.message)
}

// -------------------------------------------------------------------

// TransactionSignWeight

// .protocol.Permission permission = 1;
inline bool TransactionSignWeight::_internal_has_permission() const {
  return this != internal_default_instance() && permission_ != nullptr;
}
inline bool TransactionSignWeight::has_permission() const {
  return _internal_has_permission();
}
inline const ::protocol::Permission& TransactionSignWeight::_internal_permission() const {
  const ::protocol::Permission* p = permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Permission&>(
      ::protocol::_Permission_default_instance_);
}
inline const ::protocol::Permission& TransactionSignWeight::permission() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionSignWeight.permission)
  return _internal_permission();
}
inline void TransactionSignWeight::unsafe_arena_set_allocated_permission(
    ::protocol::Permission* permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission_);
  }
  permission_ = permission;
  if (permission) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TransactionSignWeight.permission)
}
inline ::protocol::Permission* TransactionSignWeight::release_permission() {
  
  ::protocol::Permission* temp = permission_;
  permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Permission* TransactionSignWeight::unsafe_arena_release_permission() {
  // @@protoc_insertion_point(field_release:protocol.TransactionSignWeight.permission)
  
  ::protocol::Permission* temp = permission_;
  permission_ = nullptr;
  return temp;
}
inline ::protocol::Permission* TransactionSignWeight::_internal_mutable_permission() {
  
  if (permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Permission>(GetArenaForAllocation());
    permission_ = p;
  }
  return permission_;
}
inline ::protocol::Permission* TransactionSignWeight::mutable_permission() {
  ::protocol::Permission* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionSignWeight.permission)
  return _msg;
}
inline void TransactionSignWeight::set_allocated_permission(::protocol::Permission* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission_);
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission));
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    
  } else {
    
  }
  permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionSignWeight.permission)
}

// repeated bytes approved_list = 2;
inline int TransactionSignWeight::_internal_approved_list_size() const {
  return approved_list_.size();
}
inline int TransactionSignWeight::approved_list_size() const {
  return _internal_approved_list_size();
}
inline void TransactionSignWeight::clear_approved_list() {
  approved_list_.Clear();
}
inline std::string* TransactionSignWeight::add_approved_list() {
  std::string* _s = _internal_add_approved_list();
  // @@protoc_insertion_point(field_add_mutable:protocol.TransactionSignWeight.approved_list)
  return _s;
}
inline const std::string& TransactionSignWeight::_internal_approved_list(int index) const {
  return approved_list_.Get(index);
}
inline const std::string& TransactionSignWeight::approved_list(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionSignWeight.approved_list)
  return _internal_approved_list(index);
}
inline std::string* TransactionSignWeight::mutable_approved_list(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionSignWeight.approved_list)
  return approved_list_.Mutable(index);
}
inline void TransactionSignWeight::set_approved_list(int index, const std::string& value) {
  approved_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionSignWeight.approved_list)
}
inline void TransactionSignWeight::set_approved_list(int index, std::string&& value) {
  approved_list_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.TransactionSignWeight.approved_list)
}
inline void TransactionSignWeight::set_approved_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  approved_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.TransactionSignWeight.approved_list)
}
inline void TransactionSignWeight::set_approved_list(int index, const void* value, size_t size) {
  approved_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.TransactionSignWeight.approved_list)
}
inline std::string* TransactionSignWeight::_internal_add_approved_list() {
  return approved_list_.Add();
}
inline void TransactionSignWeight::add_approved_list(const std::string& value) {
  approved_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.TransactionSignWeight.approved_list)
}
inline void TransactionSignWeight::add_approved_list(std::string&& value) {
  approved_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.TransactionSignWeight.approved_list)
}
inline void TransactionSignWeight::add_approved_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  approved_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.TransactionSignWeight.approved_list)
}
inline void TransactionSignWeight::add_approved_list(const void* value, size_t size) {
  approved_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.TransactionSignWeight.approved_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransactionSignWeight::approved_list() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionSignWeight.approved_list)
  return approved_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransactionSignWeight::mutable_approved_list() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionSignWeight.approved_list)
  return &approved_list_;
}

// int64 current_weight = 3;
inline void TransactionSignWeight::clear_current_weight() {
  current_weight_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionSignWeight::_internal_current_weight() const {
  return current_weight_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionSignWeight::current_weight() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionSignWeight.current_weight)
  return _internal_current_weight();
}
inline void TransactionSignWeight::_internal_set_current_weight(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  current_weight_ = value;
}
inline void TransactionSignWeight::set_current_weight(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_current_weight(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionSignWeight.current_weight)
}

// .protocol.TransactionSignWeight.Result result = 4;
inline bool TransactionSignWeight::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool TransactionSignWeight::has_result() const {
  return _internal_has_result();
}
inline void TransactionSignWeight::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::protocol::TransactionSignWeight_Result& TransactionSignWeight::_internal_result() const {
  const ::protocol::TransactionSignWeight_Result* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::TransactionSignWeight_Result&>(
      ::protocol::_TransactionSignWeight_Result_default_instance_);
}
inline const ::protocol::TransactionSignWeight_Result& TransactionSignWeight::result() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionSignWeight.result)
  return _internal_result();
}
inline void TransactionSignWeight::unsafe_arena_set_allocated_result(
    ::protocol::TransactionSignWeight_Result* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TransactionSignWeight.result)
}
inline ::protocol::TransactionSignWeight_Result* TransactionSignWeight::release_result() {
  
  ::protocol::TransactionSignWeight_Result* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::TransactionSignWeight_Result* TransactionSignWeight::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:protocol.TransactionSignWeight.result)
  
  ::protocol::TransactionSignWeight_Result* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::protocol::TransactionSignWeight_Result* TransactionSignWeight::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::TransactionSignWeight_Result>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::protocol::TransactionSignWeight_Result* TransactionSignWeight::mutable_result() {
  ::protocol::TransactionSignWeight_Result* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionSignWeight.result)
  return _msg;
}
inline void TransactionSignWeight::set_allocated_result(::protocol::TransactionSignWeight_Result* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::TransactionSignWeight_Result>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionSignWeight.result)
}

// .protocol.TransactionExtention transaction = 5;
inline bool TransactionSignWeight::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool TransactionSignWeight::has_transaction() const {
  return _internal_has_transaction();
}
inline void TransactionSignWeight::clear_transaction() {
  if (GetArenaForAllocation() == nullptr && transaction_ != nullptr) {
    delete transaction_;
  }
  transaction_ = nullptr;
}
inline const ::protocol::TransactionExtention& TransactionSignWeight::_internal_transaction() const {
  const ::protocol::TransactionExtention* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::TransactionExtention&>(
      ::protocol::_TransactionExtention_default_instance_);
}
inline const ::protocol::TransactionExtention& TransactionSignWeight::transaction() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionSignWeight.transaction)
  return _internal_transaction();
}
inline void TransactionSignWeight::unsafe_arena_set_allocated_transaction(
    ::protocol::TransactionExtention* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TransactionSignWeight.transaction)
}
inline ::protocol::TransactionExtention* TransactionSignWeight::release_transaction() {
  
  ::protocol::TransactionExtention* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::TransactionExtention* TransactionSignWeight::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:protocol.TransactionSignWeight.transaction)
  
  ::protocol::TransactionExtention* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::protocol::TransactionExtention* TransactionSignWeight::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::TransactionExtention>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::protocol::TransactionExtention* TransactionSignWeight::mutable_transaction() {
  ::protocol::TransactionExtention* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionSignWeight.transaction)
  return _msg;
}
inline void TransactionSignWeight::set_allocated_transaction(::protocol::TransactionExtention* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transaction_;
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::TransactionExtention>::GetOwningArena(transaction);
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionSignWeight.transaction)
}

// -------------------------------------------------------------------

// TransactionApprovedList_Result

// .protocol.TransactionApprovedList.Result.response_code code = 1;
inline void TransactionApprovedList_Result::clear_code() {
  code_ = 0;
}
inline ::protocol::TransactionApprovedList_Result_response_code TransactionApprovedList_Result::_internal_code() const {
  return static_cast< ::protocol::TransactionApprovedList_Result_response_code >(code_);
}
inline ::protocol::TransactionApprovedList_Result_response_code TransactionApprovedList_Result::code() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionApprovedList.Result.code)
  return _internal_code();
}
inline void TransactionApprovedList_Result::_internal_set_code(::protocol::TransactionApprovedList_Result_response_code value) {
  
  code_ = value;
}
inline void TransactionApprovedList_Result::set_code(::protocol::TransactionApprovedList_Result_response_code value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionApprovedList.Result.code)
}

// string message = 2;
inline void TransactionApprovedList_Result::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& TransactionApprovedList_Result::message() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionApprovedList.Result.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionApprovedList_Result::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionApprovedList.Result.message)
}
inline std::string* TransactionApprovedList_Result::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionApprovedList.Result.message)
  return _s;
}
inline const std::string& TransactionApprovedList_Result::_internal_message() const {
  return message_.Get();
}
inline void TransactionApprovedList_Result::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionApprovedList_Result::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionApprovedList_Result::release_message() {
  // @@protoc_insertion_point(field_release:protocol.TransactionApprovedList.Result.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionApprovedList_Result::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionApprovedList.Result.message)
}

// -------------------------------------------------------------------

// TransactionApprovedList

// repeated bytes approved_list = 2;
inline int TransactionApprovedList::_internal_approved_list_size() const {
  return approved_list_.size();
}
inline int TransactionApprovedList::approved_list_size() const {
  return _internal_approved_list_size();
}
inline void TransactionApprovedList::clear_approved_list() {
  approved_list_.Clear();
}
inline std::string* TransactionApprovedList::add_approved_list() {
  std::string* _s = _internal_add_approved_list();
  // @@protoc_insertion_point(field_add_mutable:protocol.TransactionApprovedList.approved_list)
  return _s;
}
inline const std::string& TransactionApprovedList::_internal_approved_list(int index) const {
  return approved_list_.Get(index);
}
inline const std::string& TransactionApprovedList::approved_list(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionApprovedList.approved_list)
  return _internal_approved_list(index);
}
inline std::string* TransactionApprovedList::mutable_approved_list(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionApprovedList.approved_list)
  return approved_list_.Mutable(index);
}
inline void TransactionApprovedList::set_approved_list(int index, const std::string& value) {
  approved_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionApprovedList.approved_list)
}
inline void TransactionApprovedList::set_approved_list(int index, std::string&& value) {
  approved_list_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.TransactionApprovedList.approved_list)
}
inline void TransactionApprovedList::set_approved_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  approved_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.TransactionApprovedList.approved_list)
}
inline void TransactionApprovedList::set_approved_list(int index, const void* value, size_t size) {
  approved_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.TransactionApprovedList.approved_list)
}
inline std::string* TransactionApprovedList::_internal_add_approved_list() {
  return approved_list_.Add();
}
inline void TransactionApprovedList::add_approved_list(const std::string& value) {
  approved_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.TransactionApprovedList.approved_list)
}
inline void TransactionApprovedList::add_approved_list(std::string&& value) {
  approved_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.TransactionApprovedList.approved_list)
}
inline void TransactionApprovedList::add_approved_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  approved_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.TransactionApprovedList.approved_list)
}
inline void TransactionApprovedList::add_approved_list(const void* value, size_t size) {
  approved_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.TransactionApprovedList.approved_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransactionApprovedList::approved_list() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionApprovedList.approved_list)
  return approved_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransactionApprovedList::mutable_approved_list() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionApprovedList.approved_list)
  return &approved_list_;
}

// .protocol.TransactionApprovedList.Result result = 4;
inline bool TransactionApprovedList::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool TransactionApprovedList::has_result() const {
  return _internal_has_result();
}
inline void TransactionApprovedList::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::protocol::TransactionApprovedList_Result& TransactionApprovedList::_internal_result() const {
  const ::protocol::TransactionApprovedList_Result* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::TransactionApprovedList_Result&>(
      ::protocol::_TransactionApprovedList_Result_default_instance_);
}
inline const ::protocol::TransactionApprovedList_Result& TransactionApprovedList::result() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionApprovedList.result)
  return _internal_result();
}
inline void TransactionApprovedList::unsafe_arena_set_allocated_result(
    ::protocol::TransactionApprovedList_Result* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TransactionApprovedList.result)
}
inline ::protocol::TransactionApprovedList_Result* TransactionApprovedList::release_result() {
  
  ::protocol::TransactionApprovedList_Result* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::TransactionApprovedList_Result* TransactionApprovedList::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:protocol.TransactionApprovedList.result)
  
  ::protocol::TransactionApprovedList_Result* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::protocol::TransactionApprovedList_Result* TransactionApprovedList::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::TransactionApprovedList_Result>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::protocol::TransactionApprovedList_Result* TransactionApprovedList::mutable_result() {
  ::protocol::TransactionApprovedList_Result* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionApprovedList.result)
  return _msg;
}
inline void TransactionApprovedList::set_allocated_result(::protocol::TransactionApprovedList_Result* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::TransactionApprovedList_Result>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionApprovedList.result)
}

// .protocol.TransactionExtention transaction = 5;
inline bool TransactionApprovedList::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool TransactionApprovedList::has_transaction() const {
  return _internal_has_transaction();
}
inline void TransactionApprovedList::clear_transaction() {
  if (GetArenaForAllocation() == nullptr && transaction_ != nullptr) {
    delete transaction_;
  }
  transaction_ = nullptr;
}
inline const ::protocol::TransactionExtention& TransactionApprovedList::_internal_transaction() const {
  const ::protocol::TransactionExtention* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::TransactionExtention&>(
      ::protocol::_TransactionExtention_default_instance_);
}
inline const ::protocol::TransactionExtention& TransactionApprovedList::transaction() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionApprovedList.transaction)
  return _internal_transaction();
}
inline void TransactionApprovedList::unsafe_arena_set_allocated_transaction(
    ::protocol::TransactionExtention* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TransactionApprovedList.transaction)
}
inline ::protocol::TransactionExtention* TransactionApprovedList::release_transaction() {
  
  ::protocol::TransactionExtention* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::TransactionExtention* TransactionApprovedList::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:protocol.TransactionApprovedList.transaction)
  
  ::protocol::TransactionExtention* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::protocol::TransactionExtention* TransactionApprovedList::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::TransactionExtention>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::protocol::TransactionExtention* TransactionApprovedList::mutable_transaction() {
  ::protocol::TransactionExtention* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionApprovedList.transaction)
  return _msg;
}
inline void TransactionApprovedList::set_allocated_transaction(::protocol::TransactionExtention* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transaction_;
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::TransactionExtention>::GetOwningArena(transaction);
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionApprovedList.transaction)
}

// -------------------------------------------------------------------

// IvkDecryptParameters

// int64 start_block_index = 1;
inline void IvkDecryptParameters::clear_start_block_index() {
  start_block_index_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IvkDecryptParameters::_internal_start_block_index() const {
  return start_block_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IvkDecryptParameters::start_block_index() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptParameters.start_block_index)
  return _internal_start_block_index();
}
inline void IvkDecryptParameters::_internal_set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  start_block_index_ = value;
}
inline void IvkDecryptParameters::set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_block_index(value);
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptParameters.start_block_index)
}

// int64 end_block_index = 2;
inline void IvkDecryptParameters::clear_end_block_index() {
  end_block_index_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IvkDecryptParameters::_internal_end_block_index() const {
  return end_block_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IvkDecryptParameters::end_block_index() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptParameters.end_block_index)
  return _internal_end_block_index();
}
inline void IvkDecryptParameters::_internal_set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  end_block_index_ = value;
}
inline void IvkDecryptParameters::set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end_block_index(value);
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptParameters.end_block_index)
}

// bytes ivk = 3;
inline void IvkDecryptParameters::clear_ivk() {
  ivk_.ClearToEmpty();
}
inline const std::string& IvkDecryptParameters::ivk() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptParameters.ivk)
  return _internal_ivk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IvkDecryptParameters::set_ivk(ArgT0&& arg0, ArgT... args) {
 
 ivk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptParameters.ivk)
}
inline std::string* IvkDecryptParameters::mutable_ivk() {
  std::string* _s = _internal_mutable_ivk();
  // @@protoc_insertion_point(field_mutable:protocol.IvkDecryptParameters.ivk)
  return _s;
}
inline const std::string& IvkDecryptParameters::_internal_ivk() const {
  return ivk_.Get();
}
inline void IvkDecryptParameters::_internal_set_ivk(const std::string& value) {
  
  ivk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IvkDecryptParameters::_internal_mutable_ivk() {
  
  return ivk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IvkDecryptParameters::release_ivk() {
  // @@protoc_insertion_point(field_release:protocol.IvkDecryptParameters.ivk)
  return ivk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IvkDecryptParameters::set_allocated_ivk(std::string* ivk) {
  if (ivk != nullptr) {
    
  } else {
    
  }
  ivk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ivk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.IvkDecryptParameters.ivk)
}

// -------------------------------------------------------------------

// IvkDecryptAndMarkParameters

// int64 start_block_index = 1;
inline void IvkDecryptAndMarkParameters::clear_start_block_index() {
  start_block_index_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IvkDecryptAndMarkParameters::_internal_start_block_index() const {
  return start_block_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IvkDecryptAndMarkParameters::start_block_index() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptAndMarkParameters.start_block_index)
  return _internal_start_block_index();
}
inline void IvkDecryptAndMarkParameters::_internal_set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  start_block_index_ = value;
}
inline void IvkDecryptAndMarkParameters::set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_block_index(value);
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptAndMarkParameters.start_block_index)
}

// int64 end_block_index = 2;
inline void IvkDecryptAndMarkParameters::clear_end_block_index() {
  end_block_index_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IvkDecryptAndMarkParameters::_internal_end_block_index() const {
  return end_block_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IvkDecryptAndMarkParameters::end_block_index() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptAndMarkParameters.end_block_index)
  return _internal_end_block_index();
}
inline void IvkDecryptAndMarkParameters::_internal_set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  end_block_index_ = value;
}
inline void IvkDecryptAndMarkParameters::set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end_block_index(value);
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptAndMarkParameters.end_block_index)
}

// bytes ivk = 5;
inline void IvkDecryptAndMarkParameters::clear_ivk() {
  ivk_.ClearToEmpty();
}
inline const std::string& IvkDecryptAndMarkParameters::ivk() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptAndMarkParameters.ivk)
  return _internal_ivk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IvkDecryptAndMarkParameters::set_ivk(ArgT0&& arg0, ArgT... args) {
 
 ivk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptAndMarkParameters.ivk)
}
inline std::string* IvkDecryptAndMarkParameters::mutable_ivk() {
  std::string* _s = _internal_mutable_ivk();
  // @@protoc_insertion_point(field_mutable:protocol.IvkDecryptAndMarkParameters.ivk)
  return _s;
}
inline const std::string& IvkDecryptAndMarkParameters::_internal_ivk() const {
  return ivk_.Get();
}
inline void IvkDecryptAndMarkParameters::_internal_set_ivk(const std::string& value) {
  
  ivk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IvkDecryptAndMarkParameters::_internal_mutable_ivk() {
  
  return ivk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IvkDecryptAndMarkParameters::release_ivk() {
  // @@protoc_insertion_point(field_release:protocol.IvkDecryptAndMarkParameters.ivk)
  return ivk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IvkDecryptAndMarkParameters::set_allocated_ivk(std::string* ivk) {
  if (ivk != nullptr) {
    
  } else {
    
  }
  ivk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ivk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.IvkDecryptAndMarkParameters.ivk)
}

// bytes ak = 3;
inline void IvkDecryptAndMarkParameters::clear_ak() {
  ak_.ClearToEmpty();
}
inline const std::string& IvkDecryptAndMarkParameters::ak() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptAndMarkParameters.ak)
  return _internal_ak();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IvkDecryptAndMarkParameters::set_ak(ArgT0&& arg0, ArgT... args) {
 
 ak_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptAndMarkParameters.ak)
}
inline std::string* IvkDecryptAndMarkParameters::mutable_ak() {
  std::string* _s = _internal_mutable_ak();
  // @@protoc_insertion_point(field_mutable:protocol.IvkDecryptAndMarkParameters.ak)
  return _s;
}
inline const std::string& IvkDecryptAndMarkParameters::_internal_ak() const {
  return ak_.Get();
}
inline void IvkDecryptAndMarkParameters::_internal_set_ak(const std::string& value) {
  
  ak_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IvkDecryptAndMarkParameters::_internal_mutable_ak() {
  
  return ak_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IvkDecryptAndMarkParameters::release_ak() {
  // @@protoc_insertion_point(field_release:protocol.IvkDecryptAndMarkParameters.ak)
  return ak_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IvkDecryptAndMarkParameters::set_allocated_ak(std::string* ak) {
  if (ak != nullptr) {
    
  } else {
    
  }
  ak_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ak,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.IvkDecryptAndMarkParameters.ak)
}

// bytes nk = 4;
inline void IvkDecryptAndMarkParameters::clear_nk() {
  nk_.ClearToEmpty();
}
inline const std::string& IvkDecryptAndMarkParameters::nk() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptAndMarkParameters.nk)
  return _internal_nk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IvkDecryptAndMarkParameters::set_nk(ArgT0&& arg0, ArgT... args) {
 
 nk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptAndMarkParameters.nk)
}
inline std::string* IvkDecryptAndMarkParameters::mutable_nk() {
  std::string* _s = _internal_mutable_nk();
  // @@protoc_insertion_point(field_mutable:protocol.IvkDecryptAndMarkParameters.nk)
  return _s;
}
inline const std::string& IvkDecryptAndMarkParameters::_internal_nk() const {
  return nk_.Get();
}
inline void IvkDecryptAndMarkParameters::_internal_set_nk(const std::string& value) {
  
  nk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IvkDecryptAndMarkParameters::_internal_mutable_nk() {
  
  return nk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IvkDecryptAndMarkParameters::release_nk() {
  // @@protoc_insertion_point(field_release:protocol.IvkDecryptAndMarkParameters.nk)
  return nk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IvkDecryptAndMarkParameters::set_allocated_nk(std::string* nk) {
  if (nk != nullptr) {
    
  } else {
    
  }
  nk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.IvkDecryptAndMarkParameters.nk)
}

// -------------------------------------------------------------------

// OvkDecryptParameters

// int64 start_block_index = 1;
inline void OvkDecryptParameters::clear_start_block_index() {
  start_block_index_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OvkDecryptParameters::_internal_start_block_index() const {
  return start_block_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OvkDecryptParameters::start_block_index() const {
  // @@protoc_insertion_point(field_get:protocol.OvkDecryptParameters.start_block_index)
  return _internal_start_block_index();
}
inline void OvkDecryptParameters::_internal_set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  start_block_index_ = value;
}
inline void OvkDecryptParameters::set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_block_index(value);
  // @@protoc_insertion_point(field_set:protocol.OvkDecryptParameters.start_block_index)
}

// int64 end_block_index = 2;
inline void OvkDecryptParameters::clear_end_block_index() {
  end_block_index_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OvkDecryptParameters::_internal_end_block_index() const {
  return end_block_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OvkDecryptParameters::end_block_index() const {
  // @@protoc_insertion_point(field_get:protocol.OvkDecryptParameters.end_block_index)
  return _internal_end_block_index();
}
inline void OvkDecryptParameters::_internal_set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  end_block_index_ = value;
}
inline void OvkDecryptParameters::set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end_block_index(value);
  // @@protoc_insertion_point(field_set:protocol.OvkDecryptParameters.end_block_index)
}

// bytes ovk = 3;
inline void OvkDecryptParameters::clear_ovk() {
  ovk_.ClearToEmpty();
}
inline const std::string& OvkDecryptParameters::ovk() const {
  // @@protoc_insertion_point(field_get:protocol.OvkDecryptParameters.ovk)
  return _internal_ovk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OvkDecryptParameters::set_ovk(ArgT0&& arg0, ArgT... args) {
 
 ovk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.OvkDecryptParameters.ovk)
}
inline std::string* OvkDecryptParameters::mutable_ovk() {
  std::string* _s = _internal_mutable_ovk();
  // @@protoc_insertion_point(field_mutable:protocol.OvkDecryptParameters.ovk)
  return _s;
}
inline const std::string& OvkDecryptParameters::_internal_ovk() const {
  return ovk_.Get();
}
inline void OvkDecryptParameters::_internal_set_ovk(const std::string& value) {
  
  ovk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OvkDecryptParameters::_internal_mutable_ovk() {
  
  return ovk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OvkDecryptParameters::release_ovk() {
  // @@protoc_insertion_point(field_release:protocol.OvkDecryptParameters.ovk)
  return ovk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OvkDecryptParameters::set_allocated_ovk(std::string* ovk) {
  if (ovk != nullptr) {
    
  } else {
    
  }
  ovk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ovk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.OvkDecryptParameters.ovk)
}

// -------------------------------------------------------------------

// DecryptNotes_NoteTx

// .protocol.Note note = 1;
inline bool DecryptNotes_NoteTx::_internal_has_note() const {
  return this != internal_default_instance() && note_ != nullptr;
}
inline bool DecryptNotes_NoteTx::has_note() const {
  return _internal_has_note();
}
inline void DecryptNotes_NoteTx::clear_note() {
  if (GetArenaForAllocation() == nullptr && note_ != nullptr) {
    delete note_;
  }
  note_ = nullptr;
}
inline const ::protocol::Note& DecryptNotes_NoteTx::_internal_note() const {
  const ::protocol::Note* p = note_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Note&>(
      ::protocol::_Note_default_instance_);
}
inline const ::protocol::Note& DecryptNotes_NoteTx::note() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotes.NoteTx.note)
  return _internal_note();
}
inline void DecryptNotes_NoteTx::unsafe_arena_set_allocated_note(
    ::protocol::Note* note) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(note_);
  }
  note_ = note;
  if (note) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.DecryptNotes.NoteTx.note)
}
inline ::protocol::Note* DecryptNotes_NoteTx::release_note() {
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Note* DecryptNotes_NoteTx::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_release:protocol.DecryptNotes.NoteTx.note)
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
  return temp;
}
inline ::protocol::Note* DecryptNotes_NoteTx::_internal_mutable_note() {
  
  if (note_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Note>(GetArenaForAllocation());
    note_ = p;
  }
  return note_;
}
inline ::protocol::Note* DecryptNotes_NoteTx::mutable_note() {
  ::protocol::Note* _msg = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:protocol.DecryptNotes.NoteTx.note)
  return _msg;
}
inline void DecryptNotes_NoteTx::set_allocated_note(::protocol::Note* note) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete note_;
  }
  if (note) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Note>::GetOwningArena(note);
    if (message_arena != submessage_arena) {
      note = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  note_ = note;
  // @@protoc_insertion_point(field_set_allocated:protocol.DecryptNotes.NoteTx.note)
}

// bytes txid = 2;
inline void DecryptNotes_NoteTx::clear_txid() {
  txid_.ClearToEmpty();
}
inline const std::string& DecryptNotes_NoteTx::txid() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotes.NoteTx.txid)
  return _internal_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DecryptNotes_NoteTx::set_txid(ArgT0&& arg0, ArgT... args) {
 
 txid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.DecryptNotes.NoteTx.txid)
}
inline std::string* DecryptNotes_NoteTx::mutable_txid() {
  std::string* _s = _internal_mutable_txid();
  // @@protoc_insertion_point(field_mutable:protocol.DecryptNotes.NoteTx.txid)
  return _s;
}
inline const std::string& DecryptNotes_NoteTx::_internal_txid() const {
  return txid_.Get();
}
inline void DecryptNotes_NoteTx::_internal_set_txid(const std::string& value) {
  
  txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DecryptNotes_NoteTx::_internal_mutable_txid() {
  
  return txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DecryptNotes_NoteTx::release_txid() {
  // @@protoc_insertion_point(field_release:protocol.DecryptNotes.NoteTx.txid)
  return txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DecryptNotes_NoteTx::set_allocated_txid(std::string* txid) {
  if (txid != nullptr) {
    
  } else {
    
  }
  txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), txid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.DecryptNotes.NoteTx.txid)
}

// int32 index = 3;
inline void DecryptNotes_NoteTx::clear_index() {
  index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DecryptNotes_NoteTx::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DecryptNotes_NoteTx::index() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotes.NoteTx.index)
  return _internal_index();
}
inline void DecryptNotes_NoteTx::_internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  index_ = value;
}
inline void DecryptNotes_NoteTx::set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:protocol.DecryptNotes.NoteTx.index)
}

// -------------------------------------------------------------------

// DecryptNotes

// repeated .protocol.DecryptNotes.NoteTx noteTxs = 1;
inline int DecryptNotes::_internal_notetxs_size() const {
  return notetxs_.size();
}
inline int DecryptNotes::notetxs_size() const {
  return _internal_notetxs_size();
}
inline void DecryptNotes::clear_notetxs() {
  notetxs_.Clear();
}
inline ::protocol::DecryptNotes_NoteTx* DecryptNotes::mutable_notetxs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.DecryptNotes.noteTxs)
  return notetxs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotes_NoteTx >*
DecryptNotes::mutable_notetxs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.DecryptNotes.noteTxs)
  return &notetxs_;
}
inline const ::protocol::DecryptNotes_NoteTx& DecryptNotes::_internal_notetxs(int index) const {
  return notetxs_.Get(index);
}
inline const ::protocol::DecryptNotes_NoteTx& DecryptNotes::notetxs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotes.noteTxs)
  return _internal_notetxs(index);
}
inline ::protocol::DecryptNotes_NoteTx* DecryptNotes::_internal_add_notetxs() {
  return notetxs_.Add();
}
inline ::protocol::DecryptNotes_NoteTx* DecryptNotes::add_notetxs() {
  ::protocol::DecryptNotes_NoteTx* _add = _internal_add_notetxs();
  // @@protoc_insertion_point(field_add:protocol.DecryptNotes.noteTxs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotes_NoteTx >&
DecryptNotes::notetxs() const {
  // @@protoc_insertion_point(field_list:protocol.DecryptNotes.noteTxs)
  return notetxs_;
}

// -------------------------------------------------------------------

// DecryptNotesMarked_NoteTx

// .protocol.Note note = 1;
inline bool DecryptNotesMarked_NoteTx::_internal_has_note() const {
  return this != internal_default_instance() && note_ != nullptr;
}
inline bool DecryptNotesMarked_NoteTx::has_note() const {
  return _internal_has_note();
}
inline void DecryptNotesMarked_NoteTx::clear_note() {
  if (GetArenaForAllocation() == nullptr && note_ != nullptr) {
    delete note_;
  }
  note_ = nullptr;
}
inline const ::protocol::Note& DecryptNotesMarked_NoteTx::_internal_note() const {
  const ::protocol::Note* p = note_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Note&>(
      ::protocol::_Note_default_instance_);
}
inline const ::protocol::Note& DecryptNotesMarked_NoteTx::note() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotesMarked.NoteTx.note)
  return _internal_note();
}
inline void DecryptNotesMarked_NoteTx::unsafe_arena_set_allocated_note(
    ::protocol::Note* note) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(note_);
  }
  note_ = note;
  if (note) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.DecryptNotesMarked.NoteTx.note)
}
inline ::protocol::Note* DecryptNotesMarked_NoteTx::release_note() {
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Note* DecryptNotesMarked_NoteTx::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_release:protocol.DecryptNotesMarked.NoteTx.note)
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
  return temp;
}
inline ::protocol::Note* DecryptNotesMarked_NoteTx::_internal_mutable_note() {
  
  if (note_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Note>(GetArenaForAllocation());
    note_ = p;
  }
  return note_;
}
inline ::protocol::Note* DecryptNotesMarked_NoteTx::mutable_note() {
  ::protocol::Note* _msg = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:protocol.DecryptNotesMarked.NoteTx.note)
  return _msg;
}
inline void DecryptNotesMarked_NoteTx::set_allocated_note(::protocol::Note* note) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete note_;
  }
  if (note) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Note>::GetOwningArena(note);
    if (message_arena != submessage_arena) {
      note = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  note_ = note;
  // @@protoc_insertion_point(field_set_allocated:protocol.DecryptNotesMarked.NoteTx.note)
}

// bytes txid = 2;
inline void DecryptNotesMarked_NoteTx::clear_txid() {
  txid_.ClearToEmpty();
}
inline const std::string& DecryptNotesMarked_NoteTx::txid() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotesMarked.NoteTx.txid)
  return _internal_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DecryptNotesMarked_NoteTx::set_txid(ArgT0&& arg0, ArgT... args) {
 
 txid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.DecryptNotesMarked.NoteTx.txid)
}
inline std::string* DecryptNotesMarked_NoteTx::mutable_txid() {
  std::string* _s = _internal_mutable_txid();
  // @@protoc_insertion_point(field_mutable:protocol.DecryptNotesMarked.NoteTx.txid)
  return _s;
}
inline const std::string& DecryptNotesMarked_NoteTx::_internal_txid() const {
  return txid_.Get();
}
inline void DecryptNotesMarked_NoteTx::_internal_set_txid(const std::string& value) {
  
  txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DecryptNotesMarked_NoteTx::_internal_mutable_txid() {
  
  return txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DecryptNotesMarked_NoteTx::release_txid() {
  // @@protoc_insertion_point(field_release:protocol.DecryptNotesMarked.NoteTx.txid)
  return txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DecryptNotesMarked_NoteTx::set_allocated_txid(std::string* txid) {
  if (txid != nullptr) {
    
  } else {
    
  }
  txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), txid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.DecryptNotesMarked.NoteTx.txid)
}

// int32 index = 3;
inline void DecryptNotesMarked_NoteTx::clear_index() {
  index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DecryptNotesMarked_NoteTx::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DecryptNotesMarked_NoteTx::index() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotesMarked.NoteTx.index)
  return _internal_index();
}
inline void DecryptNotesMarked_NoteTx::_internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  index_ = value;
}
inline void DecryptNotesMarked_NoteTx::set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:protocol.DecryptNotesMarked.NoteTx.index)
}

// bool is_spend = 4;
inline void DecryptNotesMarked_NoteTx::clear_is_spend() {
  is_spend_ = false;
}
inline bool DecryptNotesMarked_NoteTx::_internal_is_spend() const {
  return is_spend_;
}
inline bool DecryptNotesMarked_NoteTx::is_spend() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotesMarked.NoteTx.is_spend)
  return _internal_is_spend();
}
inline void DecryptNotesMarked_NoteTx::_internal_set_is_spend(bool value) {
  
  is_spend_ = value;
}
inline void DecryptNotesMarked_NoteTx::set_is_spend(bool value) {
  _internal_set_is_spend(value);
  // @@protoc_insertion_point(field_set:protocol.DecryptNotesMarked.NoteTx.is_spend)
}

// -------------------------------------------------------------------

// DecryptNotesMarked

// repeated .protocol.DecryptNotesMarked.NoteTx noteTxs = 1;
inline int DecryptNotesMarked::_internal_notetxs_size() const {
  return notetxs_.size();
}
inline int DecryptNotesMarked::notetxs_size() const {
  return _internal_notetxs_size();
}
inline void DecryptNotesMarked::clear_notetxs() {
  notetxs_.Clear();
}
inline ::protocol::DecryptNotesMarked_NoteTx* DecryptNotesMarked::mutable_notetxs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.DecryptNotesMarked.noteTxs)
  return notetxs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotesMarked_NoteTx >*
DecryptNotesMarked::mutable_notetxs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.DecryptNotesMarked.noteTxs)
  return &notetxs_;
}
inline const ::protocol::DecryptNotesMarked_NoteTx& DecryptNotesMarked::_internal_notetxs(int index) const {
  return notetxs_.Get(index);
}
inline const ::protocol::DecryptNotesMarked_NoteTx& DecryptNotesMarked::notetxs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotesMarked.noteTxs)
  return _internal_notetxs(index);
}
inline ::protocol::DecryptNotesMarked_NoteTx* DecryptNotesMarked::_internal_add_notetxs() {
  return notetxs_.Add();
}
inline ::protocol::DecryptNotesMarked_NoteTx* DecryptNotesMarked::add_notetxs() {
  ::protocol::DecryptNotesMarked_NoteTx* _add = _internal_add_notetxs();
  // @@protoc_insertion_point(field_add:protocol.DecryptNotesMarked.noteTxs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotesMarked_NoteTx >&
DecryptNotesMarked::notetxs() const {
  // @@protoc_insertion_point(field_list:protocol.DecryptNotesMarked.noteTxs)
  return notetxs_;
}

// -------------------------------------------------------------------

// Note

// int64 value = 1;
inline void Note::clear_value() {
  value_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Note::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Note::value() const {
  // @@protoc_insertion_point(field_get:protocol.Note.value)
  return _internal_value();
}
inline void Note::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  value_ = value;
}
inline void Note::set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:protocol.Note.value)
}

// string payment_address = 2;
inline void Note::clear_payment_address() {
  payment_address_.ClearToEmpty();
}
inline const std::string& Note::payment_address() const {
  // @@protoc_insertion_point(field_get:protocol.Note.payment_address)
  return _internal_payment_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Note::set_payment_address(ArgT0&& arg0, ArgT... args) {
 
 payment_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Note.payment_address)
}
inline std::string* Note::mutable_payment_address() {
  std::string* _s = _internal_mutable_payment_address();
  // @@protoc_insertion_point(field_mutable:protocol.Note.payment_address)
  return _s;
}
inline const std::string& Note::_internal_payment_address() const {
  return payment_address_.Get();
}
inline void Note::_internal_set_payment_address(const std::string& value) {
  
  payment_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Note::_internal_mutable_payment_address() {
  
  return payment_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Note::release_payment_address() {
  // @@protoc_insertion_point(field_release:protocol.Note.payment_address)
  return payment_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Note::set_allocated_payment_address(std::string* payment_address) {
  if (payment_address != nullptr) {
    
  } else {
    
  }
  payment_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payment_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Note.payment_address)
}

// bytes rcm = 3;
inline void Note::clear_rcm() {
  rcm_.ClearToEmpty();
}
inline const std::string& Note::rcm() const {
  // @@protoc_insertion_point(field_get:protocol.Note.rcm)
  return _internal_rcm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Note::set_rcm(ArgT0&& arg0, ArgT... args) {
 
 rcm_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Note.rcm)
}
inline std::string* Note::mutable_rcm() {
  std::string* _s = _internal_mutable_rcm();
  // @@protoc_insertion_point(field_mutable:protocol.Note.rcm)
  return _s;
}
inline const std::string& Note::_internal_rcm() const {
  return rcm_.Get();
}
inline void Note::_internal_set_rcm(const std::string& value) {
  
  rcm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Note::_internal_mutable_rcm() {
  
  return rcm_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Note::release_rcm() {
  // @@protoc_insertion_point(field_release:protocol.Note.rcm)
  return rcm_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Note::set_allocated_rcm(std::string* rcm) {
  if (rcm != nullptr) {
    
  } else {
    
  }
  rcm_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rcm,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Note.rcm)
}

// bytes memo = 4;
inline void Note::clear_memo() {
  memo_.ClearToEmpty();
}
inline const std::string& Note::memo() const {
  // @@protoc_insertion_point(field_get:protocol.Note.memo)
  return _internal_memo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Note::set_memo(ArgT0&& arg0, ArgT... args) {
 
 memo_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Note.memo)
}
inline std::string* Note::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:protocol.Note.memo)
  return _s;
}
inline const std::string& Note::_internal_memo() const {
  return memo_.Get();
}
inline void Note::_internal_set_memo(const std::string& value) {
  
  memo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Note::_internal_mutable_memo() {
  
  return memo_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Note::release_memo() {
  // @@protoc_insertion_point(field_release:protocol.Note.memo)
  return memo_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Note::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    
  } else {
    
  }
  memo_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), memo,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.Note.memo)
}

// -------------------------------------------------------------------

// SpendNote

// .protocol.Note note = 3;
inline bool SpendNote::_internal_has_note() const {
  return this != internal_default_instance() && note_ != nullptr;
}
inline bool SpendNote::has_note() const {
  return _internal_has_note();
}
inline void SpendNote::clear_note() {
  if (GetArenaForAllocation() == nullptr && note_ != nullptr) {
    delete note_;
  }
  note_ = nullptr;
}
inline const ::protocol::Note& SpendNote::_internal_note() const {
  const ::protocol::Note* p = note_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Note&>(
      ::protocol::_Note_default_instance_);
}
inline const ::protocol::Note& SpendNote::note() const {
  // @@protoc_insertion_point(field_get:protocol.SpendNote.note)
  return _internal_note();
}
inline void SpendNote::unsafe_arena_set_allocated_note(
    ::protocol::Note* note) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(note_);
  }
  note_ = note;
  if (note) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SpendNote.note)
}
inline ::protocol::Note* SpendNote::release_note() {
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Note* SpendNote::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_release:protocol.SpendNote.note)
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
  return temp;
}
inline ::protocol::Note* SpendNote::_internal_mutable_note() {
  
  if (note_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Note>(GetArenaForAllocation());
    note_ = p;
  }
  return note_;
}
inline ::protocol::Note* SpendNote::mutable_note() {
  ::protocol::Note* _msg = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:protocol.SpendNote.note)
  return _msg;
}
inline void SpendNote::set_allocated_note(::protocol::Note* note) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete note_;
  }
  if (note) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Note>::GetOwningArena(note);
    if (message_arena != submessage_arena) {
      note = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  note_ = note;
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendNote.note)
}

// bytes alpha = 4;
inline void SpendNote::clear_alpha() {
  alpha_.ClearToEmpty();
}
inline const std::string& SpendNote::alpha() const {
  // @@protoc_insertion_point(field_get:protocol.SpendNote.alpha)
  return _internal_alpha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendNote::set_alpha(ArgT0&& arg0, ArgT... args) {
 
 alpha_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendNote.alpha)
}
inline std::string* SpendNote::mutable_alpha() {
  std::string* _s = _internal_mutable_alpha();
  // @@protoc_insertion_point(field_mutable:protocol.SpendNote.alpha)
  return _s;
}
inline const std::string& SpendNote::_internal_alpha() const {
  return alpha_.Get();
}
inline void SpendNote::_internal_set_alpha(const std::string& value) {
  
  alpha_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SpendNote::_internal_mutable_alpha() {
  
  return alpha_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SpendNote::release_alpha() {
  // @@protoc_insertion_point(field_release:protocol.SpendNote.alpha)
  return alpha_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SpendNote::set_allocated_alpha(std::string* alpha) {
  if (alpha != nullptr) {
    
  } else {
    
  }
  alpha_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), alpha,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendNote.alpha)
}

// .protocol.IncrementalMerkleVoucher voucher = 5;
inline bool SpendNote::_internal_has_voucher() const {
  return this != internal_default_instance() && voucher_ != nullptr;
}
inline bool SpendNote::has_voucher() const {
  return _internal_has_voucher();
}
inline const ::protocol::IncrementalMerkleVoucher& SpendNote::_internal_voucher() const {
  const ::protocol::IncrementalMerkleVoucher* p = voucher_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::IncrementalMerkleVoucher&>(
      ::protocol::_IncrementalMerkleVoucher_default_instance_);
}
inline const ::protocol::IncrementalMerkleVoucher& SpendNote::voucher() const {
  // @@protoc_insertion_point(field_get:protocol.SpendNote.voucher)
  return _internal_voucher();
}
inline void SpendNote::unsafe_arena_set_allocated_voucher(
    ::protocol::IncrementalMerkleVoucher* voucher) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voucher_);
  }
  voucher_ = voucher;
  if (voucher) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SpendNote.voucher)
}
inline ::protocol::IncrementalMerkleVoucher* SpendNote::release_voucher() {
  
  ::protocol::IncrementalMerkleVoucher* temp = voucher_;
  voucher_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::IncrementalMerkleVoucher* SpendNote::unsafe_arena_release_voucher() {
  // @@protoc_insertion_point(field_release:protocol.SpendNote.voucher)
  
  ::protocol::IncrementalMerkleVoucher* temp = voucher_;
  voucher_ = nullptr;
  return temp;
}
inline ::protocol::IncrementalMerkleVoucher* SpendNote::_internal_mutable_voucher() {
  
  if (voucher_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::IncrementalMerkleVoucher>(GetArenaForAllocation());
    voucher_ = p;
  }
  return voucher_;
}
inline ::protocol::IncrementalMerkleVoucher* SpendNote::mutable_voucher() {
  ::protocol::IncrementalMerkleVoucher* _msg = _internal_mutable_voucher();
  // @@protoc_insertion_point(field_mutable:protocol.SpendNote.voucher)
  return _msg;
}
inline void SpendNote::set_allocated_voucher(::protocol::IncrementalMerkleVoucher* voucher) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(voucher_);
  }
  if (voucher) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voucher));
    if (message_arena != submessage_arena) {
      voucher = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voucher, submessage_arena);
    }
    
  } else {
    
  }
  voucher_ = voucher;
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendNote.voucher)
}

// bytes path = 6;
inline void SpendNote::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& SpendNote::path() const {
  // @@protoc_insertion_point(field_get:protocol.SpendNote.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendNote::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendNote.path)
}
inline std::string* SpendNote::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:protocol.SpendNote.path)
  return _s;
}
inline const std::string& SpendNote::_internal_path() const {
  return path_.Get();
}
inline void SpendNote::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SpendNote::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SpendNote::release_path() {
  // @@protoc_insertion_point(field_release:protocol.SpendNote.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SpendNote::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendNote.path)
}

// -------------------------------------------------------------------

// ReceiveNote

// .protocol.Note note = 1;
inline bool ReceiveNote::_internal_has_note() const {
  return this != internal_default_instance() && note_ != nullptr;
}
inline bool ReceiveNote::has_note() const {
  return _internal_has_note();
}
inline void ReceiveNote::clear_note() {
  if (GetArenaForAllocation() == nullptr && note_ != nullptr) {
    delete note_;
  }
  note_ = nullptr;
}
inline const ::protocol::Note& ReceiveNote::_internal_note() const {
  const ::protocol::Note* p = note_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Note&>(
      ::protocol::_Note_default_instance_);
}
inline const ::protocol::Note& ReceiveNote::note() const {
  // @@protoc_insertion_point(field_get:protocol.ReceiveNote.note)
  return _internal_note();
}
inline void ReceiveNote::unsafe_arena_set_allocated_note(
    ::protocol::Note* note) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(note_);
  }
  note_ = note;
  if (note) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.ReceiveNote.note)
}
inline ::protocol::Note* ReceiveNote::release_note() {
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Note* ReceiveNote::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_release:protocol.ReceiveNote.note)
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
  return temp;
}
inline ::protocol::Note* ReceiveNote::_internal_mutable_note() {
  
  if (note_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Note>(GetArenaForAllocation());
    note_ = p;
  }
  return note_;
}
inline ::protocol::Note* ReceiveNote::mutable_note() {
  ::protocol::Note* _msg = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:protocol.ReceiveNote.note)
  return _msg;
}
inline void ReceiveNote::set_allocated_note(::protocol::Note* note) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete note_;
  }
  if (note) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Note>::GetOwningArena(note);
    if (message_arena != submessage_arena) {
      note = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  note_ = note;
  // @@protoc_insertion_point(field_set_allocated:protocol.ReceiveNote.note)
}

// -------------------------------------------------------------------

// PrivateParameters

// bytes transparent_from_address = 1;
inline void PrivateParameters::clear_transparent_from_address() {
  transparent_from_address_.ClearToEmpty();
}
inline const std::string& PrivateParameters::transparent_from_address() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParameters.transparent_from_address)
  return _internal_transparent_from_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateParameters::set_transparent_from_address(ArgT0&& arg0, ArgT... args) {
 
 transparent_from_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateParameters.transparent_from_address)
}
inline std::string* PrivateParameters::mutable_transparent_from_address() {
  std::string* _s = _internal_mutable_transparent_from_address();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParameters.transparent_from_address)
  return _s;
}
inline const std::string& PrivateParameters::_internal_transparent_from_address() const {
  return transparent_from_address_.Get();
}
inline void PrivateParameters::_internal_set_transparent_from_address(const std::string& value) {
  
  transparent_from_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateParameters::_internal_mutable_transparent_from_address() {
  
  return transparent_from_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateParameters::release_transparent_from_address() {
  // @@protoc_insertion_point(field_release:protocol.PrivateParameters.transparent_from_address)
  return transparent_from_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateParameters::set_allocated_transparent_from_address(std::string* transparent_from_address) {
  if (transparent_from_address != nullptr) {
    
  } else {
    
  }
  transparent_from_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transparent_from_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateParameters.transparent_from_address)
}

// bytes ask = 2;
inline void PrivateParameters::clear_ask() {
  ask_.ClearToEmpty();
}
inline const std::string& PrivateParameters::ask() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParameters.ask)
  return _internal_ask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateParameters::set_ask(ArgT0&& arg0, ArgT... args) {
 
 ask_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateParameters.ask)
}
inline std::string* PrivateParameters::mutable_ask() {
  std::string* _s = _internal_mutable_ask();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParameters.ask)
  return _s;
}
inline const std::string& PrivateParameters::_internal_ask() const {
  return ask_.Get();
}
inline void PrivateParameters::_internal_set_ask(const std::string& value) {
  
  ask_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateParameters::_internal_mutable_ask() {
  
  return ask_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateParameters::release_ask() {
  // @@protoc_insertion_point(field_release:protocol.PrivateParameters.ask)
  return ask_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateParameters::set_allocated_ask(std::string* ask) {
  if (ask != nullptr) {
    
  } else {
    
  }
  ask_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ask,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateParameters.ask)
}

// bytes nsk = 3;
inline void PrivateParameters::clear_nsk() {
  nsk_.ClearToEmpty();
}
inline const std::string& PrivateParameters::nsk() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParameters.nsk)
  return _internal_nsk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateParameters::set_nsk(ArgT0&& arg0, ArgT... args) {
 
 nsk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateParameters.nsk)
}
inline std::string* PrivateParameters::mutable_nsk() {
  std::string* _s = _internal_mutable_nsk();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParameters.nsk)
  return _s;
}
inline const std::string& PrivateParameters::_internal_nsk() const {
  return nsk_.Get();
}
inline void PrivateParameters::_internal_set_nsk(const std::string& value) {
  
  nsk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateParameters::_internal_mutable_nsk() {
  
  return nsk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateParameters::release_nsk() {
  // @@protoc_insertion_point(field_release:protocol.PrivateParameters.nsk)
  return nsk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateParameters::set_allocated_nsk(std::string* nsk) {
  if (nsk != nullptr) {
    
  } else {
    
  }
  nsk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nsk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateParameters.nsk)
}

// bytes ovk = 4;
inline void PrivateParameters::clear_ovk() {
  ovk_.ClearToEmpty();
}
inline const std::string& PrivateParameters::ovk() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParameters.ovk)
  return _internal_ovk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateParameters::set_ovk(ArgT0&& arg0, ArgT... args) {
 
 ovk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateParameters.ovk)
}
inline std::string* PrivateParameters::mutable_ovk() {
  std::string* _s = _internal_mutable_ovk();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParameters.ovk)
  return _s;
}
inline const std::string& PrivateParameters::_internal_ovk() const {
  return ovk_.Get();
}
inline void PrivateParameters::_internal_set_ovk(const std::string& value) {
  
  ovk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateParameters::_internal_mutable_ovk() {
  
  return ovk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateParameters::release_ovk() {
  // @@protoc_insertion_point(field_release:protocol.PrivateParameters.ovk)
  return ovk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateParameters::set_allocated_ovk(std::string* ovk) {
  if (ovk != nullptr) {
    
  } else {
    
  }
  ovk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ovk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateParameters.ovk)
}

// int64 from_amount = 5;
inline void PrivateParameters::clear_from_amount() {
  from_amount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivateParameters::_internal_from_amount() const {
  return from_amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivateParameters::from_amount() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParameters.from_amount)
  return _internal_from_amount();
}
inline void PrivateParameters::_internal_set_from_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  from_amount_ = value;
}
inline void PrivateParameters::set_from_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_from_amount(value);
  // @@protoc_insertion_point(field_set:protocol.PrivateParameters.from_amount)
}

// repeated .protocol.SpendNote shielded_spends = 6;
inline int PrivateParameters::_internal_shielded_spends_size() const {
  return shielded_spends_.size();
}
inline int PrivateParameters::shielded_spends_size() const {
  return _internal_shielded_spends_size();
}
inline void PrivateParameters::clear_shielded_spends() {
  shielded_spends_.Clear();
}
inline ::protocol::SpendNote* PrivateParameters::mutable_shielded_spends(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParameters.shielded_spends)
  return shielded_spends_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNote >*
PrivateParameters::mutable_shielded_spends() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PrivateParameters.shielded_spends)
  return &shielded_spends_;
}
inline const ::protocol::SpendNote& PrivateParameters::_internal_shielded_spends(int index) const {
  return shielded_spends_.Get(index);
}
inline const ::protocol::SpendNote& PrivateParameters::shielded_spends(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParameters.shielded_spends)
  return _internal_shielded_spends(index);
}
inline ::protocol::SpendNote* PrivateParameters::_internal_add_shielded_spends() {
  return shielded_spends_.Add();
}
inline ::protocol::SpendNote* PrivateParameters::add_shielded_spends() {
  ::protocol::SpendNote* _add = _internal_add_shielded_spends();
  // @@protoc_insertion_point(field_add:protocol.PrivateParameters.shielded_spends)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNote >&
PrivateParameters::shielded_spends() const {
  // @@protoc_insertion_point(field_list:protocol.PrivateParameters.shielded_spends)
  return shielded_spends_;
}

// repeated .protocol.ReceiveNote shielded_receives = 7;
inline int PrivateParameters::_internal_shielded_receives_size() const {
  return shielded_receives_.size();
}
inline int PrivateParameters::shielded_receives_size() const {
  return _internal_shielded_receives_size();
}
inline void PrivateParameters::clear_shielded_receives() {
  shielded_receives_.Clear();
}
inline ::protocol::ReceiveNote* PrivateParameters::mutable_shielded_receives(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParameters.shielded_receives)
  return shielded_receives_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >*
PrivateParameters::mutable_shielded_receives() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PrivateParameters.shielded_receives)
  return &shielded_receives_;
}
inline const ::protocol::ReceiveNote& PrivateParameters::_internal_shielded_receives(int index) const {
  return shielded_receives_.Get(index);
}
inline const ::protocol::ReceiveNote& PrivateParameters::shielded_receives(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParameters.shielded_receives)
  return _internal_shielded_receives(index);
}
inline ::protocol::ReceiveNote* PrivateParameters::_internal_add_shielded_receives() {
  return shielded_receives_.Add();
}
inline ::protocol::ReceiveNote* PrivateParameters::add_shielded_receives() {
  ::protocol::ReceiveNote* _add = _internal_add_shielded_receives();
  // @@protoc_insertion_point(field_add:protocol.PrivateParameters.shielded_receives)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >&
PrivateParameters::shielded_receives() const {
  // @@protoc_insertion_point(field_list:protocol.PrivateParameters.shielded_receives)
  return shielded_receives_;
}

// bytes transparent_to_address = 8;
inline void PrivateParameters::clear_transparent_to_address() {
  transparent_to_address_.ClearToEmpty();
}
inline const std::string& PrivateParameters::transparent_to_address() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParameters.transparent_to_address)
  return _internal_transparent_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateParameters::set_transparent_to_address(ArgT0&& arg0, ArgT... args) {
 
 transparent_to_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateParameters.transparent_to_address)
}
inline std::string* PrivateParameters::mutable_transparent_to_address() {
  std::string* _s = _internal_mutable_transparent_to_address();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParameters.transparent_to_address)
  return _s;
}
inline const std::string& PrivateParameters::_internal_transparent_to_address() const {
  return transparent_to_address_.Get();
}
inline void PrivateParameters::_internal_set_transparent_to_address(const std::string& value) {
  
  transparent_to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateParameters::_internal_mutable_transparent_to_address() {
  
  return transparent_to_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateParameters::release_transparent_to_address() {
  // @@protoc_insertion_point(field_release:protocol.PrivateParameters.transparent_to_address)
  return transparent_to_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateParameters::set_allocated_transparent_to_address(std::string* transparent_to_address) {
  if (transparent_to_address != nullptr) {
    
  } else {
    
  }
  transparent_to_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transparent_to_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateParameters.transparent_to_address)
}

// int64 to_amount = 9;
inline void PrivateParameters::clear_to_amount() {
  to_amount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivateParameters::_internal_to_amount() const {
  return to_amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivateParameters::to_amount() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParameters.to_amount)
  return _internal_to_amount();
}
inline void PrivateParameters::_internal_set_to_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  to_amount_ = value;
}
inline void PrivateParameters::set_to_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_to_amount(value);
  // @@protoc_insertion_point(field_set:protocol.PrivateParameters.to_amount)
}

// int64 timeout = 10;
inline void PrivateParameters::clear_timeout() {
  timeout_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivateParameters::_internal_timeout() const {
  return timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivateParameters::timeout() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParameters.timeout)
  return _internal_timeout();
}
inline void PrivateParameters::_internal_set_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timeout_ = value;
}
inline void PrivateParameters::set_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:protocol.PrivateParameters.timeout)
}

// -------------------------------------------------------------------

// PrivateParametersWithoutAsk

// bytes transparent_from_address = 1;
inline void PrivateParametersWithoutAsk::clear_transparent_from_address() {
  transparent_from_address_.ClearToEmpty();
}
inline const std::string& PrivateParametersWithoutAsk::transparent_from_address() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParametersWithoutAsk.transparent_from_address)
  return _internal_transparent_from_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateParametersWithoutAsk::set_transparent_from_address(ArgT0&& arg0, ArgT... args) {
 
 transparent_from_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateParametersWithoutAsk.transparent_from_address)
}
inline std::string* PrivateParametersWithoutAsk::mutable_transparent_from_address() {
  std::string* _s = _internal_mutable_transparent_from_address();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParametersWithoutAsk.transparent_from_address)
  return _s;
}
inline const std::string& PrivateParametersWithoutAsk::_internal_transparent_from_address() const {
  return transparent_from_address_.Get();
}
inline void PrivateParametersWithoutAsk::_internal_set_transparent_from_address(const std::string& value) {
  
  transparent_from_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateParametersWithoutAsk::_internal_mutable_transparent_from_address() {
  
  return transparent_from_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateParametersWithoutAsk::release_transparent_from_address() {
  // @@protoc_insertion_point(field_release:protocol.PrivateParametersWithoutAsk.transparent_from_address)
  return transparent_from_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateParametersWithoutAsk::set_allocated_transparent_from_address(std::string* transparent_from_address) {
  if (transparent_from_address != nullptr) {
    
  } else {
    
  }
  transparent_from_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transparent_from_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateParametersWithoutAsk.transparent_from_address)
}

// bytes ak = 2;
inline void PrivateParametersWithoutAsk::clear_ak() {
  ak_.ClearToEmpty();
}
inline const std::string& PrivateParametersWithoutAsk::ak() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParametersWithoutAsk.ak)
  return _internal_ak();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateParametersWithoutAsk::set_ak(ArgT0&& arg0, ArgT... args) {
 
 ak_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateParametersWithoutAsk.ak)
}
inline std::string* PrivateParametersWithoutAsk::mutable_ak() {
  std::string* _s = _internal_mutable_ak();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParametersWithoutAsk.ak)
  return _s;
}
inline const std::string& PrivateParametersWithoutAsk::_internal_ak() const {
  return ak_.Get();
}
inline void PrivateParametersWithoutAsk::_internal_set_ak(const std::string& value) {
  
  ak_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateParametersWithoutAsk::_internal_mutable_ak() {
  
  return ak_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateParametersWithoutAsk::release_ak() {
  // @@protoc_insertion_point(field_release:protocol.PrivateParametersWithoutAsk.ak)
  return ak_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateParametersWithoutAsk::set_allocated_ak(std::string* ak) {
  if (ak != nullptr) {
    
  } else {
    
  }
  ak_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ak,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateParametersWithoutAsk.ak)
}

// bytes nsk = 3;
inline void PrivateParametersWithoutAsk::clear_nsk() {
  nsk_.ClearToEmpty();
}
inline const std::string& PrivateParametersWithoutAsk::nsk() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParametersWithoutAsk.nsk)
  return _internal_nsk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateParametersWithoutAsk::set_nsk(ArgT0&& arg0, ArgT... args) {
 
 nsk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateParametersWithoutAsk.nsk)
}
inline std::string* PrivateParametersWithoutAsk::mutable_nsk() {
  std::string* _s = _internal_mutable_nsk();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParametersWithoutAsk.nsk)
  return _s;
}
inline const std::string& PrivateParametersWithoutAsk::_internal_nsk() const {
  return nsk_.Get();
}
inline void PrivateParametersWithoutAsk::_internal_set_nsk(const std::string& value) {
  
  nsk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateParametersWithoutAsk::_internal_mutable_nsk() {
  
  return nsk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateParametersWithoutAsk::release_nsk() {
  // @@protoc_insertion_point(field_release:protocol.PrivateParametersWithoutAsk.nsk)
  return nsk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateParametersWithoutAsk::set_allocated_nsk(std::string* nsk) {
  if (nsk != nullptr) {
    
  } else {
    
  }
  nsk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nsk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateParametersWithoutAsk.nsk)
}

// bytes ovk = 4;
inline void PrivateParametersWithoutAsk::clear_ovk() {
  ovk_.ClearToEmpty();
}
inline const std::string& PrivateParametersWithoutAsk::ovk() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParametersWithoutAsk.ovk)
  return _internal_ovk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateParametersWithoutAsk::set_ovk(ArgT0&& arg0, ArgT... args) {
 
 ovk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateParametersWithoutAsk.ovk)
}
inline std::string* PrivateParametersWithoutAsk::mutable_ovk() {
  std::string* _s = _internal_mutable_ovk();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParametersWithoutAsk.ovk)
  return _s;
}
inline const std::string& PrivateParametersWithoutAsk::_internal_ovk() const {
  return ovk_.Get();
}
inline void PrivateParametersWithoutAsk::_internal_set_ovk(const std::string& value) {
  
  ovk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateParametersWithoutAsk::_internal_mutable_ovk() {
  
  return ovk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateParametersWithoutAsk::release_ovk() {
  // @@protoc_insertion_point(field_release:protocol.PrivateParametersWithoutAsk.ovk)
  return ovk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateParametersWithoutAsk::set_allocated_ovk(std::string* ovk) {
  if (ovk != nullptr) {
    
  } else {
    
  }
  ovk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ovk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateParametersWithoutAsk.ovk)
}

// int64 from_amount = 5;
inline void PrivateParametersWithoutAsk::clear_from_amount() {
  from_amount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivateParametersWithoutAsk::_internal_from_amount() const {
  return from_amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivateParametersWithoutAsk::from_amount() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParametersWithoutAsk.from_amount)
  return _internal_from_amount();
}
inline void PrivateParametersWithoutAsk::_internal_set_from_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  from_amount_ = value;
}
inline void PrivateParametersWithoutAsk::set_from_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_from_amount(value);
  // @@protoc_insertion_point(field_set:protocol.PrivateParametersWithoutAsk.from_amount)
}

// repeated .protocol.SpendNote shielded_spends = 6;
inline int PrivateParametersWithoutAsk::_internal_shielded_spends_size() const {
  return shielded_spends_.size();
}
inline int PrivateParametersWithoutAsk::shielded_spends_size() const {
  return _internal_shielded_spends_size();
}
inline void PrivateParametersWithoutAsk::clear_shielded_spends() {
  shielded_spends_.Clear();
}
inline ::protocol::SpendNote* PrivateParametersWithoutAsk::mutable_shielded_spends(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParametersWithoutAsk.shielded_spends)
  return shielded_spends_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNote >*
PrivateParametersWithoutAsk::mutable_shielded_spends() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PrivateParametersWithoutAsk.shielded_spends)
  return &shielded_spends_;
}
inline const ::protocol::SpendNote& PrivateParametersWithoutAsk::_internal_shielded_spends(int index) const {
  return shielded_spends_.Get(index);
}
inline const ::protocol::SpendNote& PrivateParametersWithoutAsk::shielded_spends(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParametersWithoutAsk.shielded_spends)
  return _internal_shielded_spends(index);
}
inline ::protocol::SpendNote* PrivateParametersWithoutAsk::_internal_add_shielded_spends() {
  return shielded_spends_.Add();
}
inline ::protocol::SpendNote* PrivateParametersWithoutAsk::add_shielded_spends() {
  ::protocol::SpendNote* _add = _internal_add_shielded_spends();
  // @@protoc_insertion_point(field_add:protocol.PrivateParametersWithoutAsk.shielded_spends)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNote >&
PrivateParametersWithoutAsk::shielded_spends() const {
  // @@protoc_insertion_point(field_list:protocol.PrivateParametersWithoutAsk.shielded_spends)
  return shielded_spends_;
}

// repeated .protocol.ReceiveNote shielded_receives = 7;
inline int PrivateParametersWithoutAsk::_internal_shielded_receives_size() const {
  return shielded_receives_.size();
}
inline int PrivateParametersWithoutAsk::shielded_receives_size() const {
  return _internal_shielded_receives_size();
}
inline void PrivateParametersWithoutAsk::clear_shielded_receives() {
  shielded_receives_.Clear();
}
inline ::protocol::ReceiveNote* PrivateParametersWithoutAsk::mutable_shielded_receives(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParametersWithoutAsk.shielded_receives)
  return shielded_receives_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >*
PrivateParametersWithoutAsk::mutable_shielded_receives() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PrivateParametersWithoutAsk.shielded_receives)
  return &shielded_receives_;
}
inline const ::protocol::ReceiveNote& PrivateParametersWithoutAsk::_internal_shielded_receives(int index) const {
  return shielded_receives_.Get(index);
}
inline const ::protocol::ReceiveNote& PrivateParametersWithoutAsk::shielded_receives(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParametersWithoutAsk.shielded_receives)
  return _internal_shielded_receives(index);
}
inline ::protocol::ReceiveNote* PrivateParametersWithoutAsk::_internal_add_shielded_receives() {
  return shielded_receives_.Add();
}
inline ::protocol::ReceiveNote* PrivateParametersWithoutAsk::add_shielded_receives() {
  ::protocol::ReceiveNote* _add = _internal_add_shielded_receives();
  // @@protoc_insertion_point(field_add:protocol.PrivateParametersWithoutAsk.shielded_receives)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >&
PrivateParametersWithoutAsk::shielded_receives() const {
  // @@protoc_insertion_point(field_list:protocol.PrivateParametersWithoutAsk.shielded_receives)
  return shielded_receives_;
}

// bytes transparent_to_address = 8;
inline void PrivateParametersWithoutAsk::clear_transparent_to_address() {
  transparent_to_address_.ClearToEmpty();
}
inline const std::string& PrivateParametersWithoutAsk::transparent_to_address() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParametersWithoutAsk.transparent_to_address)
  return _internal_transparent_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateParametersWithoutAsk::set_transparent_to_address(ArgT0&& arg0, ArgT... args) {
 
 transparent_to_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateParametersWithoutAsk.transparent_to_address)
}
inline std::string* PrivateParametersWithoutAsk::mutable_transparent_to_address() {
  std::string* _s = _internal_mutable_transparent_to_address();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateParametersWithoutAsk.transparent_to_address)
  return _s;
}
inline const std::string& PrivateParametersWithoutAsk::_internal_transparent_to_address() const {
  return transparent_to_address_.Get();
}
inline void PrivateParametersWithoutAsk::_internal_set_transparent_to_address(const std::string& value) {
  
  transparent_to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateParametersWithoutAsk::_internal_mutable_transparent_to_address() {
  
  return transparent_to_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateParametersWithoutAsk::release_transparent_to_address() {
  // @@protoc_insertion_point(field_release:protocol.PrivateParametersWithoutAsk.transparent_to_address)
  return transparent_to_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateParametersWithoutAsk::set_allocated_transparent_to_address(std::string* transparent_to_address) {
  if (transparent_to_address != nullptr) {
    
  } else {
    
  }
  transparent_to_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transparent_to_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateParametersWithoutAsk.transparent_to_address)
}

// int64 to_amount = 9;
inline void PrivateParametersWithoutAsk::clear_to_amount() {
  to_amount_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivateParametersWithoutAsk::_internal_to_amount() const {
  return to_amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivateParametersWithoutAsk::to_amount() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParametersWithoutAsk.to_amount)
  return _internal_to_amount();
}
inline void PrivateParametersWithoutAsk::_internal_set_to_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  to_amount_ = value;
}
inline void PrivateParametersWithoutAsk::set_to_amount(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_to_amount(value);
  // @@protoc_insertion_point(field_set:protocol.PrivateParametersWithoutAsk.to_amount)
}

// int64 timeout = 10;
inline void PrivateParametersWithoutAsk::clear_timeout() {
  timeout_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivateParametersWithoutAsk::_internal_timeout() const {
  return timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivateParametersWithoutAsk::timeout() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateParametersWithoutAsk.timeout)
  return _internal_timeout();
}
inline void PrivateParametersWithoutAsk::_internal_set_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timeout_ = value;
}
inline void PrivateParametersWithoutAsk::set_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:protocol.PrivateParametersWithoutAsk.timeout)
}

// -------------------------------------------------------------------

// SpendAuthSigParameters

// bytes ask = 1;
inline void SpendAuthSigParameters::clear_ask() {
  ask_.ClearToEmpty();
}
inline const std::string& SpendAuthSigParameters::ask() const {
  // @@protoc_insertion_point(field_get:protocol.SpendAuthSigParameters.ask)
  return _internal_ask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendAuthSigParameters::set_ask(ArgT0&& arg0, ArgT... args) {
 
 ask_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendAuthSigParameters.ask)
}
inline std::string* SpendAuthSigParameters::mutable_ask() {
  std::string* _s = _internal_mutable_ask();
  // @@protoc_insertion_point(field_mutable:protocol.SpendAuthSigParameters.ask)
  return _s;
}
inline const std::string& SpendAuthSigParameters::_internal_ask() const {
  return ask_.Get();
}
inline void SpendAuthSigParameters::_internal_set_ask(const std::string& value) {
  
  ask_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SpendAuthSigParameters::_internal_mutable_ask() {
  
  return ask_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SpendAuthSigParameters::release_ask() {
  // @@protoc_insertion_point(field_release:protocol.SpendAuthSigParameters.ask)
  return ask_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SpendAuthSigParameters::set_allocated_ask(std::string* ask) {
  if (ask != nullptr) {
    
  } else {
    
  }
  ask_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ask,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendAuthSigParameters.ask)
}

// bytes tx_hash = 2;
inline void SpendAuthSigParameters::clear_tx_hash() {
  tx_hash_.ClearToEmpty();
}
inline const std::string& SpendAuthSigParameters::tx_hash() const {
  // @@protoc_insertion_point(field_get:protocol.SpendAuthSigParameters.tx_hash)
  return _internal_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendAuthSigParameters::set_tx_hash(ArgT0&& arg0, ArgT... args) {
 
 tx_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendAuthSigParameters.tx_hash)
}
inline std::string* SpendAuthSigParameters::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:protocol.SpendAuthSigParameters.tx_hash)
  return _s;
}
inline const std::string& SpendAuthSigParameters::_internal_tx_hash() const {
  return tx_hash_.Get();
}
inline void SpendAuthSigParameters::_internal_set_tx_hash(const std::string& value) {
  
  tx_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SpendAuthSigParameters::_internal_mutable_tx_hash() {
  
  return tx_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SpendAuthSigParameters::release_tx_hash() {
  // @@protoc_insertion_point(field_release:protocol.SpendAuthSigParameters.tx_hash)
  return tx_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SpendAuthSigParameters::set_allocated_tx_hash(std::string* tx_hash) {
  if (tx_hash != nullptr) {
    
  } else {
    
  }
  tx_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tx_hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendAuthSigParameters.tx_hash)
}

// bytes alpha = 3;
inline void SpendAuthSigParameters::clear_alpha() {
  alpha_.ClearToEmpty();
}
inline const std::string& SpendAuthSigParameters::alpha() const {
  // @@protoc_insertion_point(field_get:protocol.SpendAuthSigParameters.alpha)
  return _internal_alpha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendAuthSigParameters::set_alpha(ArgT0&& arg0, ArgT... args) {
 
 alpha_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendAuthSigParameters.alpha)
}
inline std::string* SpendAuthSigParameters::mutable_alpha() {
  std::string* _s = _internal_mutable_alpha();
  // @@protoc_insertion_point(field_mutable:protocol.SpendAuthSigParameters.alpha)
  return _s;
}
inline const std::string& SpendAuthSigParameters::_internal_alpha() const {
  return alpha_.Get();
}
inline void SpendAuthSigParameters::_internal_set_alpha(const std::string& value) {
  
  alpha_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SpendAuthSigParameters::_internal_mutable_alpha() {
  
  return alpha_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SpendAuthSigParameters::release_alpha() {
  // @@protoc_insertion_point(field_release:protocol.SpendAuthSigParameters.alpha)
  return alpha_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SpendAuthSigParameters::set_allocated_alpha(std::string* alpha) {
  if (alpha != nullptr) {
    
  } else {
    
  }
  alpha_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), alpha,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendAuthSigParameters.alpha)
}

// -------------------------------------------------------------------

// NfParameters

// .protocol.Note note = 1;
inline bool NfParameters::_internal_has_note() const {
  return this != internal_default_instance() && note_ != nullptr;
}
inline bool NfParameters::has_note() const {
  return _internal_has_note();
}
inline void NfParameters::clear_note() {
  if (GetArenaForAllocation() == nullptr && note_ != nullptr) {
    delete note_;
  }
  note_ = nullptr;
}
inline const ::protocol::Note& NfParameters::_internal_note() const {
  const ::protocol::Note* p = note_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Note&>(
      ::protocol::_Note_default_instance_);
}
inline const ::protocol::Note& NfParameters::note() const {
  // @@protoc_insertion_point(field_get:protocol.NfParameters.note)
  return _internal_note();
}
inline void NfParameters::unsafe_arena_set_allocated_note(
    ::protocol::Note* note) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(note_);
  }
  note_ = note;
  if (note) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.NfParameters.note)
}
inline ::protocol::Note* NfParameters::release_note() {
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Note* NfParameters::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_release:protocol.NfParameters.note)
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
  return temp;
}
inline ::protocol::Note* NfParameters::_internal_mutable_note() {
  
  if (note_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Note>(GetArenaForAllocation());
    note_ = p;
  }
  return note_;
}
inline ::protocol::Note* NfParameters::mutable_note() {
  ::protocol::Note* _msg = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:protocol.NfParameters.note)
  return _msg;
}
inline void NfParameters::set_allocated_note(::protocol::Note* note) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete note_;
  }
  if (note) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Note>::GetOwningArena(note);
    if (message_arena != submessage_arena) {
      note = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  note_ = note;
  // @@protoc_insertion_point(field_set_allocated:protocol.NfParameters.note)
}

// .protocol.IncrementalMerkleVoucher voucher = 2;
inline bool NfParameters::_internal_has_voucher() const {
  return this != internal_default_instance() && voucher_ != nullptr;
}
inline bool NfParameters::has_voucher() const {
  return _internal_has_voucher();
}
inline const ::protocol::IncrementalMerkleVoucher& NfParameters::_internal_voucher() const {
  const ::protocol::IncrementalMerkleVoucher* p = voucher_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::IncrementalMerkleVoucher&>(
      ::protocol::_IncrementalMerkleVoucher_default_instance_);
}
inline const ::protocol::IncrementalMerkleVoucher& NfParameters::voucher() const {
  // @@protoc_insertion_point(field_get:protocol.NfParameters.voucher)
  return _internal_voucher();
}
inline void NfParameters::unsafe_arena_set_allocated_voucher(
    ::protocol::IncrementalMerkleVoucher* voucher) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voucher_);
  }
  voucher_ = voucher;
  if (voucher) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.NfParameters.voucher)
}
inline ::protocol::IncrementalMerkleVoucher* NfParameters::release_voucher() {
  
  ::protocol::IncrementalMerkleVoucher* temp = voucher_;
  voucher_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::IncrementalMerkleVoucher* NfParameters::unsafe_arena_release_voucher() {
  // @@protoc_insertion_point(field_release:protocol.NfParameters.voucher)
  
  ::protocol::IncrementalMerkleVoucher* temp = voucher_;
  voucher_ = nullptr;
  return temp;
}
inline ::protocol::IncrementalMerkleVoucher* NfParameters::_internal_mutable_voucher() {
  
  if (voucher_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::IncrementalMerkleVoucher>(GetArenaForAllocation());
    voucher_ = p;
  }
  return voucher_;
}
inline ::protocol::IncrementalMerkleVoucher* NfParameters::mutable_voucher() {
  ::protocol::IncrementalMerkleVoucher* _msg = _internal_mutable_voucher();
  // @@protoc_insertion_point(field_mutable:protocol.NfParameters.voucher)
  return _msg;
}
inline void NfParameters::set_allocated_voucher(::protocol::IncrementalMerkleVoucher* voucher) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(voucher_);
  }
  if (voucher) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voucher));
    if (message_arena != submessage_arena) {
      voucher = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voucher, submessage_arena);
    }
    
  } else {
    
  }
  voucher_ = voucher;
  // @@protoc_insertion_point(field_set_allocated:protocol.NfParameters.voucher)
}

// bytes ak = 3;
inline void NfParameters::clear_ak() {
  ak_.ClearToEmpty();
}
inline const std::string& NfParameters::ak() const {
  // @@protoc_insertion_point(field_get:protocol.NfParameters.ak)
  return _internal_ak();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NfParameters::set_ak(ArgT0&& arg0, ArgT... args) {
 
 ak_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NfParameters.ak)
}
inline std::string* NfParameters::mutable_ak() {
  std::string* _s = _internal_mutable_ak();
  // @@protoc_insertion_point(field_mutable:protocol.NfParameters.ak)
  return _s;
}
inline const std::string& NfParameters::_internal_ak() const {
  return ak_.Get();
}
inline void NfParameters::_internal_set_ak(const std::string& value) {
  
  ak_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NfParameters::_internal_mutable_ak() {
  
  return ak_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NfParameters::release_ak() {
  // @@protoc_insertion_point(field_release:protocol.NfParameters.ak)
  return ak_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NfParameters::set_allocated_ak(std::string* ak) {
  if (ak != nullptr) {
    
  } else {
    
  }
  ak_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ak,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.NfParameters.ak)
}

// bytes nk = 4;
inline void NfParameters::clear_nk() {
  nk_.ClearToEmpty();
}
inline const std::string& NfParameters::nk() const {
  // @@protoc_insertion_point(field_get:protocol.NfParameters.nk)
  return _internal_nk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NfParameters::set_nk(ArgT0&& arg0, ArgT... args) {
 
 nk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NfParameters.nk)
}
inline std::string* NfParameters::mutable_nk() {
  std::string* _s = _internal_mutable_nk();
  // @@protoc_insertion_point(field_mutable:protocol.NfParameters.nk)
  return _s;
}
inline const std::string& NfParameters::_internal_nk() const {
  return nk_.Get();
}
inline void NfParameters::_internal_set_nk(const std::string& value) {
  
  nk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NfParameters::_internal_mutable_nk() {
  
  return nk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NfParameters::release_nk() {
  // @@protoc_insertion_point(field_release:protocol.NfParameters.nk)
  return nk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NfParameters::set_allocated_nk(std::string* nk) {
  if (nk != nullptr) {
    
  } else {
    
  }
  nk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.NfParameters.nk)
}

// -------------------------------------------------------------------

// ExpandedSpendingKeyMessage

// bytes ask = 1;
inline void ExpandedSpendingKeyMessage::clear_ask() {
  ask_.ClearToEmpty();
}
inline const std::string& ExpandedSpendingKeyMessage::ask() const {
  // @@protoc_insertion_point(field_get:protocol.ExpandedSpendingKeyMessage.ask)
  return _internal_ask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExpandedSpendingKeyMessage::set_ask(ArgT0&& arg0, ArgT... args) {
 
 ask_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ExpandedSpendingKeyMessage.ask)
}
inline std::string* ExpandedSpendingKeyMessage::mutable_ask() {
  std::string* _s = _internal_mutable_ask();
  // @@protoc_insertion_point(field_mutable:protocol.ExpandedSpendingKeyMessage.ask)
  return _s;
}
inline const std::string& ExpandedSpendingKeyMessage::_internal_ask() const {
  return ask_.Get();
}
inline void ExpandedSpendingKeyMessage::_internal_set_ask(const std::string& value) {
  
  ask_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExpandedSpendingKeyMessage::_internal_mutable_ask() {
  
  return ask_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExpandedSpendingKeyMessage::release_ask() {
  // @@protoc_insertion_point(field_release:protocol.ExpandedSpendingKeyMessage.ask)
  return ask_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExpandedSpendingKeyMessage::set_allocated_ask(std::string* ask) {
  if (ask != nullptr) {
    
  } else {
    
  }
  ask_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ask,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ExpandedSpendingKeyMessage.ask)
}

// bytes nsk = 2;
inline void ExpandedSpendingKeyMessage::clear_nsk() {
  nsk_.ClearToEmpty();
}
inline const std::string& ExpandedSpendingKeyMessage::nsk() const {
  // @@protoc_insertion_point(field_get:protocol.ExpandedSpendingKeyMessage.nsk)
  return _internal_nsk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExpandedSpendingKeyMessage::set_nsk(ArgT0&& arg0, ArgT... args) {
 
 nsk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ExpandedSpendingKeyMessage.nsk)
}
inline std::string* ExpandedSpendingKeyMessage::mutable_nsk() {
  std::string* _s = _internal_mutable_nsk();
  // @@protoc_insertion_point(field_mutable:protocol.ExpandedSpendingKeyMessage.nsk)
  return _s;
}
inline const std::string& ExpandedSpendingKeyMessage::_internal_nsk() const {
  return nsk_.Get();
}
inline void ExpandedSpendingKeyMessage::_internal_set_nsk(const std::string& value) {
  
  nsk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExpandedSpendingKeyMessage::_internal_mutable_nsk() {
  
  return nsk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExpandedSpendingKeyMessage::release_nsk() {
  // @@protoc_insertion_point(field_release:protocol.ExpandedSpendingKeyMessage.nsk)
  return nsk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExpandedSpendingKeyMessage::set_allocated_nsk(std::string* nsk) {
  if (nsk != nullptr) {
    
  } else {
    
  }
  nsk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nsk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ExpandedSpendingKeyMessage.nsk)
}

// bytes ovk = 3;
inline void ExpandedSpendingKeyMessage::clear_ovk() {
  ovk_.ClearToEmpty();
}
inline const std::string& ExpandedSpendingKeyMessage::ovk() const {
  // @@protoc_insertion_point(field_get:protocol.ExpandedSpendingKeyMessage.ovk)
  return _internal_ovk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExpandedSpendingKeyMessage::set_ovk(ArgT0&& arg0, ArgT... args) {
 
 ovk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ExpandedSpendingKeyMessage.ovk)
}
inline std::string* ExpandedSpendingKeyMessage::mutable_ovk() {
  std::string* _s = _internal_mutable_ovk();
  // @@protoc_insertion_point(field_mutable:protocol.ExpandedSpendingKeyMessage.ovk)
  return _s;
}
inline const std::string& ExpandedSpendingKeyMessage::_internal_ovk() const {
  return ovk_.Get();
}
inline void ExpandedSpendingKeyMessage::_internal_set_ovk(const std::string& value) {
  
  ovk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExpandedSpendingKeyMessage::_internal_mutable_ovk() {
  
  return ovk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExpandedSpendingKeyMessage::release_ovk() {
  // @@protoc_insertion_point(field_release:protocol.ExpandedSpendingKeyMessage.ovk)
  return ovk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExpandedSpendingKeyMessage::set_allocated_ovk(std::string* ovk) {
  if (ovk != nullptr) {
    
  } else {
    
  }
  ovk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ovk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ExpandedSpendingKeyMessage.ovk)
}

// -------------------------------------------------------------------

// ViewingKeyMessage

// bytes ak = 1;
inline void ViewingKeyMessage::clear_ak() {
  ak_.ClearToEmpty();
}
inline const std::string& ViewingKeyMessage::ak() const {
  // @@protoc_insertion_point(field_get:protocol.ViewingKeyMessage.ak)
  return _internal_ak();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ViewingKeyMessage::set_ak(ArgT0&& arg0, ArgT... args) {
 
 ak_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ViewingKeyMessage.ak)
}
inline std::string* ViewingKeyMessage::mutable_ak() {
  std::string* _s = _internal_mutable_ak();
  // @@protoc_insertion_point(field_mutable:protocol.ViewingKeyMessage.ak)
  return _s;
}
inline const std::string& ViewingKeyMessage::_internal_ak() const {
  return ak_.Get();
}
inline void ViewingKeyMessage::_internal_set_ak(const std::string& value) {
  
  ak_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ViewingKeyMessage::_internal_mutable_ak() {
  
  return ak_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ViewingKeyMessage::release_ak() {
  // @@protoc_insertion_point(field_release:protocol.ViewingKeyMessage.ak)
  return ak_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ViewingKeyMessage::set_allocated_ak(std::string* ak) {
  if (ak != nullptr) {
    
  } else {
    
  }
  ak_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ak,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ViewingKeyMessage.ak)
}

// bytes nk = 2;
inline void ViewingKeyMessage::clear_nk() {
  nk_.ClearToEmpty();
}
inline const std::string& ViewingKeyMessage::nk() const {
  // @@protoc_insertion_point(field_get:protocol.ViewingKeyMessage.nk)
  return _internal_nk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ViewingKeyMessage::set_nk(ArgT0&& arg0, ArgT... args) {
 
 nk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ViewingKeyMessage.nk)
}
inline std::string* ViewingKeyMessage::mutable_nk() {
  std::string* _s = _internal_mutable_nk();
  // @@protoc_insertion_point(field_mutable:protocol.ViewingKeyMessage.nk)
  return _s;
}
inline const std::string& ViewingKeyMessage::_internal_nk() const {
  return nk_.Get();
}
inline void ViewingKeyMessage::_internal_set_nk(const std::string& value) {
  
  nk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ViewingKeyMessage::_internal_mutable_nk() {
  
  return nk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ViewingKeyMessage::release_nk() {
  // @@protoc_insertion_point(field_release:protocol.ViewingKeyMessage.nk)
  return nk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ViewingKeyMessage::set_allocated_nk(std::string* nk) {
  if (nk != nullptr) {
    
  } else {
    
  }
  nk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ViewingKeyMessage.nk)
}

// -------------------------------------------------------------------

// IncomingViewingKeyMessage

// bytes ivk = 1;
inline void IncomingViewingKeyMessage::clear_ivk() {
  ivk_.ClearToEmpty();
}
inline const std::string& IncomingViewingKeyMessage::ivk() const {
  // @@protoc_insertion_point(field_get:protocol.IncomingViewingKeyMessage.ivk)
  return _internal_ivk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncomingViewingKeyMessage::set_ivk(ArgT0&& arg0, ArgT... args) {
 
 ivk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.IncomingViewingKeyMessage.ivk)
}
inline std::string* IncomingViewingKeyMessage::mutable_ivk() {
  std::string* _s = _internal_mutable_ivk();
  // @@protoc_insertion_point(field_mutable:protocol.IncomingViewingKeyMessage.ivk)
  return _s;
}
inline const std::string& IncomingViewingKeyMessage::_internal_ivk() const {
  return ivk_.Get();
}
inline void IncomingViewingKeyMessage::_internal_set_ivk(const std::string& value) {
  
  ivk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IncomingViewingKeyMessage::_internal_mutable_ivk() {
  
  return ivk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IncomingViewingKeyMessage::release_ivk() {
  // @@protoc_insertion_point(field_release:protocol.IncomingViewingKeyMessage.ivk)
  return ivk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IncomingViewingKeyMessage::set_allocated_ivk(std::string* ivk) {
  if (ivk != nullptr) {
    
  } else {
    
  }
  ivk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ivk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.IncomingViewingKeyMessage.ivk)
}

// -------------------------------------------------------------------

// DiversifierMessage

// bytes d = 1;
inline void DiversifierMessage::clear_d() {
  d_.ClearToEmpty();
}
inline const std::string& DiversifierMessage::d() const {
  // @@protoc_insertion_point(field_get:protocol.DiversifierMessage.d)
  return _internal_d();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiversifierMessage::set_d(ArgT0&& arg0, ArgT... args) {
 
 d_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.DiversifierMessage.d)
}
inline std::string* DiversifierMessage::mutable_d() {
  std::string* _s = _internal_mutable_d();
  // @@protoc_insertion_point(field_mutable:protocol.DiversifierMessage.d)
  return _s;
}
inline const std::string& DiversifierMessage::_internal_d() const {
  return d_.Get();
}
inline void DiversifierMessage::_internal_set_d(const std::string& value) {
  
  d_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DiversifierMessage::_internal_mutable_d() {
  
  return d_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DiversifierMessage::release_d() {
  // @@protoc_insertion_point(field_release:protocol.DiversifierMessage.d)
  return d_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DiversifierMessage::set_allocated_d(std::string* d) {
  if (d != nullptr) {
    
  } else {
    
  }
  d_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), d,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.DiversifierMessage.d)
}

// -------------------------------------------------------------------

// IncomingViewingKeyDiversifierMessage

// .protocol.IncomingViewingKeyMessage ivk = 1;
inline bool IncomingViewingKeyDiversifierMessage::_internal_has_ivk() const {
  return this != internal_default_instance() && ivk_ != nullptr;
}
inline bool IncomingViewingKeyDiversifierMessage::has_ivk() const {
  return _internal_has_ivk();
}
inline void IncomingViewingKeyDiversifierMessage::clear_ivk() {
  if (GetArenaForAllocation() == nullptr && ivk_ != nullptr) {
    delete ivk_;
  }
  ivk_ = nullptr;
}
inline const ::protocol::IncomingViewingKeyMessage& IncomingViewingKeyDiversifierMessage::_internal_ivk() const {
  const ::protocol::IncomingViewingKeyMessage* p = ivk_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::IncomingViewingKeyMessage&>(
      ::protocol::_IncomingViewingKeyMessage_default_instance_);
}
inline const ::protocol::IncomingViewingKeyMessage& IncomingViewingKeyDiversifierMessage::ivk() const {
  // @@protoc_insertion_point(field_get:protocol.IncomingViewingKeyDiversifierMessage.ivk)
  return _internal_ivk();
}
inline void IncomingViewingKeyDiversifierMessage::unsafe_arena_set_allocated_ivk(
    ::protocol::IncomingViewingKeyMessage* ivk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ivk_);
  }
  ivk_ = ivk;
  if (ivk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.IncomingViewingKeyDiversifierMessage.ivk)
}
inline ::protocol::IncomingViewingKeyMessage* IncomingViewingKeyDiversifierMessage::release_ivk() {
  
  ::protocol::IncomingViewingKeyMessage* temp = ivk_;
  ivk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::IncomingViewingKeyMessage* IncomingViewingKeyDiversifierMessage::unsafe_arena_release_ivk() {
  // @@protoc_insertion_point(field_release:protocol.IncomingViewingKeyDiversifierMessage.ivk)
  
  ::protocol::IncomingViewingKeyMessage* temp = ivk_;
  ivk_ = nullptr;
  return temp;
}
inline ::protocol::IncomingViewingKeyMessage* IncomingViewingKeyDiversifierMessage::_internal_mutable_ivk() {
  
  if (ivk_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::IncomingViewingKeyMessage>(GetArenaForAllocation());
    ivk_ = p;
  }
  return ivk_;
}
inline ::protocol::IncomingViewingKeyMessage* IncomingViewingKeyDiversifierMessage::mutable_ivk() {
  ::protocol::IncomingViewingKeyMessage* _msg = _internal_mutable_ivk();
  // @@protoc_insertion_point(field_mutable:protocol.IncomingViewingKeyDiversifierMessage.ivk)
  return _msg;
}
inline void IncomingViewingKeyDiversifierMessage::set_allocated_ivk(::protocol::IncomingViewingKeyMessage* ivk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ivk_;
  }
  if (ivk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::IncomingViewingKeyMessage>::GetOwningArena(ivk);
    if (message_arena != submessage_arena) {
      ivk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ivk, submessage_arena);
    }
    
  } else {
    
  }
  ivk_ = ivk;
  // @@protoc_insertion_point(field_set_allocated:protocol.IncomingViewingKeyDiversifierMessage.ivk)
}

// .protocol.DiversifierMessage d = 2;
inline bool IncomingViewingKeyDiversifierMessage::_internal_has_d() const {
  return this != internal_default_instance() && d_ != nullptr;
}
inline bool IncomingViewingKeyDiversifierMessage::has_d() const {
  return _internal_has_d();
}
inline void IncomingViewingKeyDiversifierMessage::clear_d() {
  if (GetArenaForAllocation() == nullptr && d_ != nullptr) {
    delete d_;
  }
  d_ = nullptr;
}
inline const ::protocol::DiversifierMessage& IncomingViewingKeyDiversifierMessage::_internal_d() const {
  const ::protocol::DiversifierMessage* p = d_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::DiversifierMessage&>(
      ::protocol::_DiversifierMessage_default_instance_);
}
inline const ::protocol::DiversifierMessage& IncomingViewingKeyDiversifierMessage::d() const {
  // @@protoc_insertion_point(field_get:protocol.IncomingViewingKeyDiversifierMessage.d)
  return _internal_d();
}
inline void IncomingViewingKeyDiversifierMessage::unsafe_arena_set_allocated_d(
    ::protocol::DiversifierMessage* d) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(d_);
  }
  d_ = d;
  if (d) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.IncomingViewingKeyDiversifierMessage.d)
}
inline ::protocol::DiversifierMessage* IncomingViewingKeyDiversifierMessage::release_d() {
  
  ::protocol::DiversifierMessage* temp = d_;
  d_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::DiversifierMessage* IncomingViewingKeyDiversifierMessage::unsafe_arena_release_d() {
  // @@protoc_insertion_point(field_release:protocol.IncomingViewingKeyDiversifierMessage.d)
  
  ::protocol::DiversifierMessage* temp = d_;
  d_ = nullptr;
  return temp;
}
inline ::protocol::DiversifierMessage* IncomingViewingKeyDiversifierMessage::_internal_mutable_d() {
  
  if (d_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::DiversifierMessage>(GetArenaForAllocation());
    d_ = p;
  }
  return d_;
}
inline ::protocol::DiversifierMessage* IncomingViewingKeyDiversifierMessage::mutable_d() {
  ::protocol::DiversifierMessage* _msg = _internal_mutable_d();
  // @@protoc_insertion_point(field_mutable:protocol.IncomingViewingKeyDiversifierMessage.d)
  return _msg;
}
inline void IncomingViewingKeyDiversifierMessage::set_allocated_d(::protocol::DiversifierMessage* d) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete d_;
  }
  if (d) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::DiversifierMessage>::GetOwningArena(d);
    if (message_arena != submessage_arena) {
      d = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, d, submessage_arena);
    }
    
  } else {
    
  }
  d_ = d;
  // @@protoc_insertion_point(field_set_allocated:protocol.IncomingViewingKeyDiversifierMessage.d)
}

// -------------------------------------------------------------------

// PaymentAddressMessage

// .protocol.DiversifierMessage d = 1;
inline bool PaymentAddressMessage::_internal_has_d() const {
  return this != internal_default_instance() && d_ != nullptr;
}
inline bool PaymentAddressMessage::has_d() const {
  return _internal_has_d();
}
inline void PaymentAddressMessage::clear_d() {
  if (GetArenaForAllocation() == nullptr && d_ != nullptr) {
    delete d_;
  }
  d_ = nullptr;
}
inline const ::protocol::DiversifierMessage& PaymentAddressMessage::_internal_d() const {
  const ::protocol::DiversifierMessage* p = d_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::DiversifierMessage&>(
      ::protocol::_DiversifierMessage_default_instance_);
}
inline const ::protocol::DiversifierMessage& PaymentAddressMessage::d() const {
  // @@protoc_insertion_point(field_get:protocol.PaymentAddressMessage.d)
  return _internal_d();
}
inline void PaymentAddressMessage::unsafe_arena_set_allocated_d(
    ::protocol::DiversifierMessage* d) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(d_);
  }
  d_ = d;
  if (d) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.PaymentAddressMessage.d)
}
inline ::protocol::DiversifierMessage* PaymentAddressMessage::release_d() {
  
  ::protocol::DiversifierMessage* temp = d_;
  d_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::DiversifierMessage* PaymentAddressMessage::unsafe_arena_release_d() {
  // @@protoc_insertion_point(field_release:protocol.PaymentAddressMessage.d)
  
  ::protocol::DiversifierMessage* temp = d_;
  d_ = nullptr;
  return temp;
}
inline ::protocol::DiversifierMessage* PaymentAddressMessage::_internal_mutable_d() {
  
  if (d_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::DiversifierMessage>(GetArenaForAllocation());
    d_ = p;
  }
  return d_;
}
inline ::protocol::DiversifierMessage* PaymentAddressMessage::mutable_d() {
  ::protocol::DiversifierMessage* _msg = _internal_mutable_d();
  // @@protoc_insertion_point(field_mutable:protocol.PaymentAddressMessage.d)
  return _msg;
}
inline void PaymentAddressMessage::set_allocated_d(::protocol::DiversifierMessage* d) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete d_;
  }
  if (d) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::DiversifierMessage>::GetOwningArena(d);
    if (message_arena != submessage_arena) {
      d = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, d, submessage_arena);
    }
    
  } else {
    
  }
  d_ = d;
  // @@protoc_insertion_point(field_set_allocated:protocol.PaymentAddressMessage.d)
}

// bytes pkD = 2;
inline void PaymentAddressMessage::clear_pkd() {
  pkd_.ClearToEmpty();
}
inline const std::string& PaymentAddressMessage::pkd() const {
  // @@protoc_insertion_point(field_get:protocol.PaymentAddressMessage.pkD)
  return _internal_pkd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentAddressMessage::set_pkd(ArgT0&& arg0, ArgT... args) {
 
 pkd_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PaymentAddressMessage.pkD)
}
inline std::string* PaymentAddressMessage::mutable_pkd() {
  std::string* _s = _internal_mutable_pkd();
  // @@protoc_insertion_point(field_mutable:protocol.PaymentAddressMessage.pkD)
  return _s;
}
inline const std::string& PaymentAddressMessage::_internal_pkd() const {
  return pkd_.Get();
}
inline void PaymentAddressMessage::_internal_set_pkd(const std::string& value) {
  
  pkd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PaymentAddressMessage::_internal_mutable_pkd() {
  
  return pkd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PaymentAddressMessage::release_pkd() {
  // @@protoc_insertion_point(field_release:protocol.PaymentAddressMessage.pkD)
  return pkd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PaymentAddressMessage::set_allocated_pkd(std::string* pkd) {
  if (pkd != nullptr) {
    
  } else {
    
  }
  pkd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pkd,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PaymentAddressMessage.pkD)
}

// string payment_address = 3;
inline void PaymentAddressMessage::clear_payment_address() {
  payment_address_.ClearToEmpty();
}
inline const std::string& PaymentAddressMessage::payment_address() const {
  // @@protoc_insertion_point(field_get:protocol.PaymentAddressMessage.payment_address)
  return _internal_payment_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentAddressMessage::set_payment_address(ArgT0&& arg0, ArgT... args) {
 
 payment_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PaymentAddressMessage.payment_address)
}
inline std::string* PaymentAddressMessage::mutable_payment_address() {
  std::string* _s = _internal_mutable_payment_address();
  // @@protoc_insertion_point(field_mutable:protocol.PaymentAddressMessage.payment_address)
  return _s;
}
inline const std::string& PaymentAddressMessage::_internal_payment_address() const {
  return payment_address_.Get();
}
inline void PaymentAddressMessage::_internal_set_payment_address(const std::string& value) {
  
  payment_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PaymentAddressMessage::_internal_mutable_payment_address() {
  
  return payment_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PaymentAddressMessage::release_payment_address() {
  // @@protoc_insertion_point(field_release:protocol.PaymentAddressMessage.payment_address)
  return payment_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PaymentAddressMessage::set_allocated_payment_address(std::string* payment_address) {
  if (payment_address != nullptr) {
    
  } else {
    
  }
  payment_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payment_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PaymentAddressMessage.payment_address)
}

// -------------------------------------------------------------------

// ShieldedAddressInfo

// bytes sk = 1;
inline void ShieldedAddressInfo::clear_sk() {
  sk_.ClearToEmpty();
}
inline const std::string& ShieldedAddressInfo::sk() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedAddressInfo.sk)
  return _internal_sk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedAddressInfo::set_sk(ArgT0&& arg0, ArgT... args) {
 
 sk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedAddressInfo.sk)
}
inline std::string* ShieldedAddressInfo::mutable_sk() {
  std::string* _s = _internal_mutable_sk();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedAddressInfo.sk)
  return _s;
}
inline const std::string& ShieldedAddressInfo::_internal_sk() const {
  return sk_.Get();
}
inline void ShieldedAddressInfo::_internal_set_sk(const std::string& value) {
  
  sk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::_internal_mutable_sk() {
  
  return sk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::release_sk() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedAddressInfo.sk)
  return sk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedAddressInfo::set_allocated_sk(std::string* sk) {
  if (sk != nullptr) {
    
  } else {
    
  }
  sk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedAddressInfo.sk)
}

// bytes ask = 2;
inline void ShieldedAddressInfo::clear_ask() {
  ask_.ClearToEmpty();
}
inline const std::string& ShieldedAddressInfo::ask() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedAddressInfo.ask)
  return _internal_ask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedAddressInfo::set_ask(ArgT0&& arg0, ArgT... args) {
 
 ask_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedAddressInfo.ask)
}
inline std::string* ShieldedAddressInfo::mutable_ask() {
  std::string* _s = _internal_mutable_ask();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedAddressInfo.ask)
  return _s;
}
inline const std::string& ShieldedAddressInfo::_internal_ask() const {
  return ask_.Get();
}
inline void ShieldedAddressInfo::_internal_set_ask(const std::string& value) {
  
  ask_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::_internal_mutable_ask() {
  
  return ask_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::release_ask() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedAddressInfo.ask)
  return ask_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedAddressInfo::set_allocated_ask(std::string* ask) {
  if (ask != nullptr) {
    
  } else {
    
  }
  ask_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ask,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedAddressInfo.ask)
}

// bytes nsk = 3;
inline void ShieldedAddressInfo::clear_nsk() {
  nsk_.ClearToEmpty();
}
inline const std::string& ShieldedAddressInfo::nsk() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedAddressInfo.nsk)
  return _internal_nsk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedAddressInfo::set_nsk(ArgT0&& arg0, ArgT... args) {
 
 nsk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedAddressInfo.nsk)
}
inline std::string* ShieldedAddressInfo::mutable_nsk() {
  std::string* _s = _internal_mutable_nsk();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedAddressInfo.nsk)
  return _s;
}
inline const std::string& ShieldedAddressInfo::_internal_nsk() const {
  return nsk_.Get();
}
inline void ShieldedAddressInfo::_internal_set_nsk(const std::string& value) {
  
  nsk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::_internal_mutable_nsk() {
  
  return nsk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::release_nsk() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedAddressInfo.nsk)
  return nsk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedAddressInfo::set_allocated_nsk(std::string* nsk) {
  if (nsk != nullptr) {
    
  } else {
    
  }
  nsk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nsk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedAddressInfo.nsk)
}

// bytes ovk = 4;
inline void ShieldedAddressInfo::clear_ovk() {
  ovk_.ClearToEmpty();
}
inline const std::string& ShieldedAddressInfo::ovk() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedAddressInfo.ovk)
  return _internal_ovk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedAddressInfo::set_ovk(ArgT0&& arg0, ArgT... args) {
 
 ovk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedAddressInfo.ovk)
}
inline std::string* ShieldedAddressInfo::mutable_ovk() {
  std::string* _s = _internal_mutable_ovk();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedAddressInfo.ovk)
  return _s;
}
inline const std::string& ShieldedAddressInfo::_internal_ovk() const {
  return ovk_.Get();
}
inline void ShieldedAddressInfo::_internal_set_ovk(const std::string& value) {
  
  ovk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::_internal_mutable_ovk() {
  
  return ovk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::release_ovk() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedAddressInfo.ovk)
  return ovk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedAddressInfo::set_allocated_ovk(std::string* ovk) {
  if (ovk != nullptr) {
    
  } else {
    
  }
  ovk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ovk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedAddressInfo.ovk)
}

// bytes ak = 5;
inline void ShieldedAddressInfo::clear_ak() {
  ak_.ClearToEmpty();
}
inline const std::string& ShieldedAddressInfo::ak() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedAddressInfo.ak)
  return _internal_ak();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedAddressInfo::set_ak(ArgT0&& arg0, ArgT... args) {
 
 ak_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedAddressInfo.ak)
}
inline std::string* ShieldedAddressInfo::mutable_ak() {
  std::string* _s = _internal_mutable_ak();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedAddressInfo.ak)
  return _s;
}
inline const std::string& ShieldedAddressInfo::_internal_ak() const {
  return ak_.Get();
}
inline void ShieldedAddressInfo::_internal_set_ak(const std::string& value) {
  
  ak_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::_internal_mutable_ak() {
  
  return ak_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::release_ak() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedAddressInfo.ak)
  return ak_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedAddressInfo::set_allocated_ak(std::string* ak) {
  if (ak != nullptr) {
    
  } else {
    
  }
  ak_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ak,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedAddressInfo.ak)
}

// bytes nk = 6;
inline void ShieldedAddressInfo::clear_nk() {
  nk_.ClearToEmpty();
}
inline const std::string& ShieldedAddressInfo::nk() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedAddressInfo.nk)
  return _internal_nk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedAddressInfo::set_nk(ArgT0&& arg0, ArgT... args) {
 
 nk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedAddressInfo.nk)
}
inline std::string* ShieldedAddressInfo::mutable_nk() {
  std::string* _s = _internal_mutable_nk();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedAddressInfo.nk)
  return _s;
}
inline const std::string& ShieldedAddressInfo::_internal_nk() const {
  return nk_.Get();
}
inline void ShieldedAddressInfo::_internal_set_nk(const std::string& value) {
  
  nk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::_internal_mutable_nk() {
  
  return nk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::release_nk() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedAddressInfo.nk)
  return nk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedAddressInfo::set_allocated_nk(std::string* nk) {
  if (nk != nullptr) {
    
  } else {
    
  }
  nk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedAddressInfo.nk)
}

// bytes ivk = 7;
inline void ShieldedAddressInfo::clear_ivk() {
  ivk_.ClearToEmpty();
}
inline const std::string& ShieldedAddressInfo::ivk() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedAddressInfo.ivk)
  return _internal_ivk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedAddressInfo::set_ivk(ArgT0&& arg0, ArgT... args) {
 
 ivk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedAddressInfo.ivk)
}
inline std::string* ShieldedAddressInfo::mutable_ivk() {
  std::string* _s = _internal_mutable_ivk();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedAddressInfo.ivk)
  return _s;
}
inline const std::string& ShieldedAddressInfo::_internal_ivk() const {
  return ivk_.Get();
}
inline void ShieldedAddressInfo::_internal_set_ivk(const std::string& value) {
  
  ivk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::_internal_mutable_ivk() {
  
  return ivk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::release_ivk() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedAddressInfo.ivk)
  return ivk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedAddressInfo::set_allocated_ivk(std::string* ivk) {
  if (ivk != nullptr) {
    
  } else {
    
  }
  ivk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ivk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedAddressInfo.ivk)
}

// bytes d = 8;
inline void ShieldedAddressInfo::clear_d() {
  d_.ClearToEmpty();
}
inline const std::string& ShieldedAddressInfo::d() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedAddressInfo.d)
  return _internal_d();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedAddressInfo::set_d(ArgT0&& arg0, ArgT... args) {
 
 d_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedAddressInfo.d)
}
inline std::string* ShieldedAddressInfo::mutable_d() {
  std::string* _s = _internal_mutable_d();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedAddressInfo.d)
  return _s;
}
inline const std::string& ShieldedAddressInfo::_internal_d() const {
  return d_.Get();
}
inline void ShieldedAddressInfo::_internal_set_d(const std::string& value) {
  
  d_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::_internal_mutable_d() {
  
  return d_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::release_d() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedAddressInfo.d)
  return d_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedAddressInfo::set_allocated_d(std::string* d) {
  if (d != nullptr) {
    
  } else {
    
  }
  d_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), d,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedAddressInfo.d)
}

// bytes pkD = 9;
inline void ShieldedAddressInfo::clear_pkd() {
  pkd_.ClearToEmpty();
}
inline const std::string& ShieldedAddressInfo::pkd() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedAddressInfo.pkD)
  return _internal_pkd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedAddressInfo::set_pkd(ArgT0&& arg0, ArgT... args) {
 
 pkd_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedAddressInfo.pkD)
}
inline std::string* ShieldedAddressInfo::mutable_pkd() {
  std::string* _s = _internal_mutable_pkd();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedAddressInfo.pkD)
  return _s;
}
inline const std::string& ShieldedAddressInfo::_internal_pkd() const {
  return pkd_.Get();
}
inline void ShieldedAddressInfo::_internal_set_pkd(const std::string& value) {
  
  pkd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::_internal_mutable_pkd() {
  
  return pkd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::release_pkd() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedAddressInfo.pkD)
  return pkd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedAddressInfo::set_allocated_pkd(std::string* pkd) {
  if (pkd != nullptr) {
    
  } else {
    
  }
  pkd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pkd,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedAddressInfo.pkD)
}

// string payment_address = 10;
inline void ShieldedAddressInfo::clear_payment_address() {
  payment_address_.ClearToEmpty();
}
inline const std::string& ShieldedAddressInfo::payment_address() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedAddressInfo.payment_address)
  return _internal_payment_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedAddressInfo::set_payment_address(ArgT0&& arg0, ArgT... args) {
 
 payment_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedAddressInfo.payment_address)
}
inline std::string* ShieldedAddressInfo::mutable_payment_address() {
  std::string* _s = _internal_mutable_payment_address();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedAddressInfo.payment_address)
  return _s;
}
inline const std::string& ShieldedAddressInfo::_internal_payment_address() const {
  return payment_address_.Get();
}
inline void ShieldedAddressInfo::_internal_set_payment_address(const std::string& value) {
  
  payment_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::_internal_mutable_payment_address() {
  
  return payment_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedAddressInfo::release_payment_address() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedAddressInfo.payment_address)
  return payment_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedAddressInfo::set_allocated_payment_address(std::string* payment_address) {
  if (payment_address != nullptr) {
    
  } else {
    
  }
  payment_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payment_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedAddressInfo.payment_address)
}

// -------------------------------------------------------------------

// NoteParameters

// bytes ak = 1;
inline void NoteParameters::clear_ak() {
  ak_.ClearToEmpty();
}
inline const std::string& NoteParameters::ak() const {
  // @@protoc_insertion_point(field_get:protocol.NoteParameters.ak)
  return _internal_ak();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoteParameters::set_ak(ArgT0&& arg0, ArgT... args) {
 
 ak_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NoteParameters.ak)
}
inline std::string* NoteParameters::mutable_ak() {
  std::string* _s = _internal_mutable_ak();
  // @@protoc_insertion_point(field_mutable:protocol.NoteParameters.ak)
  return _s;
}
inline const std::string& NoteParameters::_internal_ak() const {
  return ak_.Get();
}
inline void NoteParameters::_internal_set_ak(const std::string& value) {
  
  ak_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NoteParameters::_internal_mutable_ak() {
  
  return ak_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NoteParameters::release_ak() {
  // @@protoc_insertion_point(field_release:protocol.NoteParameters.ak)
  return ak_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NoteParameters::set_allocated_ak(std::string* ak) {
  if (ak != nullptr) {
    
  } else {
    
  }
  ak_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ak,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.NoteParameters.ak)
}

// bytes nk = 2;
inline void NoteParameters::clear_nk() {
  nk_.ClearToEmpty();
}
inline const std::string& NoteParameters::nk() const {
  // @@protoc_insertion_point(field_get:protocol.NoteParameters.nk)
  return _internal_nk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoteParameters::set_nk(ArgT0&& arg0, ArgT... args) {
 
 nk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NoteParameters.nk)
}
inline std::string* NoteParameters::mutable_nk() {
  std::string* _s = _internal_mutable_nk();
  // @@protoc_insertion_point(field_mutable:protocol.NoteParameters.nk)
  return _s;
}
inline const std::string& NoteParameters::_internal_nk() const {
  return nk_.Get();
}
inline void NoteParameters::_internal_set_nk(const std::string& value) {
  
  nk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NoteParameters::_internal_mutable_nk() {
  
  return nk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NoteParameters::release_nk() {
  // @@protoc_insertion_point(field_release:protocol.NoteParameters.nk)
  return nk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NoteParameters::set_allocated_nk(std::string* nk) {
  if (nk != nullptr) {
    
  } else {
    
  }
  nk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.NoteParameters.nk)
}

// .protocol.Note note = 3;
inline bool NoteParameters::_internal_has_note() const {
  return this != internal_default_instance() && note_ != nullptr;
}
inline bool NoteParameters::has_note() const {
  return _internal_has_note();
}
inline void NoteParameters::clear_note() {
  if (GetArenaForAllocation() == nullptr && note_ != nullptr) {
    delete note_;
  }
  note_ = nullptr;
}
inline const ::protocol::Note& NoteParameters::_internal_note() const {
  const ::protocol::Note* p = note_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Note&>(
      ::protocol::_Note_default_instance_);
}
inline const ::protocol::Note& NoteParameters::note() const {
  // @@protoc_insertion_point(field_get:protocol.NoteParameters.note)
  return _internal_note();
}
inline void NoteParameters::unsafe_arena_set_allocated_note(
    ::protocol::Note* note) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(note_);
  }
  note_ = note;
  if (note) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.NoteParameters.note)
}
inline ::protocol::Note* NoteParameters::release_note() {
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Note* NoteParameters::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_release:protocol.NoteParameters.note)
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
  return temp;
}
inline ::protocol::Note* NoteParameters::_internal_mutable_note() {
  
  if (note_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Note>(GetArenaForAllocation());
    note_ = p;
  }
  return note_;
}
inline ::protocol::Note* NoteParameters::mutable_note() {
  ::protocol::Note* _msg = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:protocol.NoteParameters.note)
  return _msg;
}
inline void NoteParameters::set_allocated_note(::protocol::Note* note) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete note_;
  }
  if (note) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Note>::GetOwningArena(note);
    if (message_arena != submessage_arena) {
      note = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  note_ = note;
  // @@protoc_insertion_point(field_set_allocated:protocol.NoteParameters.note)
}

// bytes txid = 4;
inline void NoteParameters::clear_txid() {
  txid_.ClearToEmpty();
}
inline const std::string& NoteParameters::txid() const {
  // @@protoc_insertion_point(field_get:protocol.NoteParameters.txid)
  return _internal_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoteParameters::set_txid(ArgT0&& arg0, ArgT... args) {
 
 txid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NoteParameters.txid)
}
inline std::string* NoteParameters::mutable_txid() {
  std::string* _s = _internal_mutable_txid();
  // @@protoc_insertion_point(field_mutable:protocol.NoteParameters.txid)
  return _s;
}
inline const std::string& NoteParameters::_internal_txid() const {
  return txid_.Get();
}
inline void NoteParameters::_internal_set_txid(const std::string& value) {
  
  txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NoteParameters::_internal_mutable_txid() {
  
  return txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NoteParameters::release_txid() {
  // @@protoc_insertion_point(field_release:protocol.NoteParameters.txid)
  return txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NoteParameters::set_allocated_txid(std::string* txid) {
  if (txid != nullptr) {
    
  } else {
    
  }
  txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), txid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.NoteParameters.txid)
}

// int32 index = 5;
inline void NoteParameters::clear_index() {
  index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NoteParameters::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NoteParameters::index() const {
  // @@protoc_insertion_point(field_get:protocol.NoteParameters.index)
  return _internal_index();
}
inline void NoteParameters::_internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  index_ = value;
}
inline void NoteParameters::set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:protocol.NoteParameters.index)
}

// -------------------------------------------------------------------

// SpendResult

// bool result = 1;
inline void SpendResult::clear_result() {
  result_ = false;
}
inline bool SpendResult::_internal_result() const {
  return result_;
}
inline bool SpendResult::result() const {
  // @@protoc_insertion_point(field_get:protocol.SpendResult.result)
  return _internal_result();
}
inline void SpendResult::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void SpendResult::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:protocol.SpendResult.result)
}

// string message = 2;
inline void SpendResult::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& SpendResult::message() const {
  // @@protoc_insertion_point(field_get:protocol.SpendResult.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendResult::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendResult.message)
}
inline std::string* SpendResult::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protocol.SpendResult.message)
  return _s;
}
inline const std::string& SpendResult::_internal_message() const {
  return message_.Get();
}
inline void SpendResult::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SpendResult::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SpendResult::release_message() {
  // @@protoc_insertion_point(field_release:protocol.SpendResult.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SpendResult::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendResult.message)
}

// -------------------------------------------------------------------

// TransactionInfoList

// repeated .protocol.TransactionInfo transactionInfo = 1;
inline int TransactionInfoList::_internal_transactioninfo_size() const {
  return transactioninfo_.size();
}
inline int TransactionInfoList::transactioninfo_size() const {
  return _internal_transactioninfo_size();
}
inline ::protocol::TransactionInfo* TransactionInfoList::mutable_transactioninfo(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfoList.transactionInfo)
  return transactioninfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo >*
TransactionInfoList::mutable_transactioninfo() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionInfoList.transactionInfo)
  return &transactioninfo_;
}
inline const ::protocol::TransactionInfo& TransactionInfoList::_internal_transactioninfo(int index) const {
  return transactioninfo_.Get(index);
}
inline const ::protocol::TransactionInfo& TransactionInfoList::transactioninfo(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfoList.transactionInfo)
  return _internal_transactioninfo(index);
}
inline ::protocol::TransactionInfo* TransactionInfoList::_internal_add_transactioninfo() {
  return transactioninfo_.Add();
}
inline ::protocol::TransactionInfo* TransactionInfoList::add_transactioninfo() {
  ::protocol::TransactionInfo* _add = _internal_add_transactioninfo();
  // @@protoc_insertion_point(field_add:protocol.TransactionInfoList.transactionInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo >&
TransactionInfoList::transactioninfo() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionInfoList.transactionInfo)
  return transactioninfo_;
}

// -------------------------------------------------------------------

// SpendNoteTRC20

// .protocol.Note note = 1;
inline bool SpendNoteTRC20::_internal_has_note() const {
  return this != internal_default_instance() && note_ != nullptr;
}
inline bool SpendNoteTRC20::has_note() const {
  return _internal_has_note();
}
inline void SpendNoteTRC20::clear_note() {
  if (GetArenaForAllocation() == nullptr && note_ != nullptr) {
    delete note_;
  }
  note_ = nullptr;
}
inline const ::protocol::Note& SpendNoteTRC20::_internal_note() const {
  const ::protocol::Note* p = note_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Note&>(
      ::protocol::_Note_default_instance_);
}
inline const ::protocol::Note& SpendNoteTRC20::note() const {
  // @@protoc_insertion_point(field_get:protocol.SpendNoteTRC20.note)
  return _internal_note();
}
inline void SpendNoteTRC20::unsafe_arena_set_allocated_note(
    ::protocol::Note* note) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(note_);
  }
  note_ = note;
  if (note) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.SpendNoteTRC20.note)
}
inline ::protocol::Note* SpendNoteTRC20::release_note() {
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Note* SpendNoteTRC20::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_release:protocol.SpendNoteTRC20.note)
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
  return temp;
}
inline ::protocol::Note* SpendNoteTRC20::_internal_mutable_note() {
  
  if (note_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Note>(GetArenaForAllocation());
    note_ = p;
  }
  return note_;
}
inline ::protocol::Note* SpendNoteTRC20::mutable_note() {
  ::protocol::Note* _msg = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:protocol.SpendNoteTRC20.note)
  return _msg;
}
inline void SpendNoteTRC20::set_allocated_note(::protocol::Note* note) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete note_;
  }
  if (note) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Note>::GetOwningArena(note);
    if (message_arena != submessage_arena) {
      note = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  note_ = note;
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendNoteTRC20.note)
}

// bytes alpha = 2;
inline void SpendNoteTRC20::clear_alpha() {
  alpha_.ClearToEmpty();
}
inline const std::string& SpendNoteTRC20::alpha() const {
  // @@protoc_insertion_point(field_get:protocol.SpendNoteTRC20.alpha)
  return _internal_alpha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendNoteTRC20::set_alpha(ArgT0&& arg0, ArgT... args) {
 
 alpha_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendNoteTRC20.alpha)
}
inline std::string* SpendNoteTRC20::mutable_alpha() {
  std::string* _s = _internal_mutable_alpha();
  // @@protoc_insertion_point(field_mutable:protocol.SpendNoteTRC20.alpha)
  return _s;
}
inline const std::string& SpendNoteTRC20::_internal_alpha() const {
  return alpha_.Get();
}
inline void SpendNoteTRC20::_internal_set_alpha(const std::string& value) {
  
  alpha_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SpendNoteTRC20::_internal_mutable_alpha() {
  
  return alpha_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SpendNoteTRC20::release_alpha() {
  // @@protoc_insertion_point(field_release:protocol.SpendNoteTRC20.alpha)
  return alpha_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SpendNoteTRC20::set_allocated_alpha(std::string* alpha) {
  if (alpha != nullptr) {
    
  } else {
    
  }
  alpha_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), alpha,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendNoteTRC20.alpha)
}

// bytes root = 3;
inline void SpendNoteTRC20::clear_root() {
  root_.ClearToEmpty();
}
inline const std::string& SpendNoteTRC20::root() const {
  // @@protoc_insertion_point(field_get:protocol.SpendNoteTRC20.root)
  return _internal_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendNoteTRC20::set_root(ArgT0&& arg0, ArgT... args) {
 
 root_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendNoteTRC20.root)
}
inline std::string* SpendNoteTRC20::mutable_root() {
  std::string* _s = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:protocol.SpendNoteTRC20.root)
  return _s;
}
inline const std::string& SpendNoteTRC20::_internal_root() const {
  return root_.Get();
}
inline void SpendNoteTRC20::_internal_set_root(const std::string& value) {
  
  root_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SpendNoteTRC20::_internal_mutable_root() {
  
  return root_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SpendNoteTRC20::release_root() {
  // @@protoc_insertion_point(field_release:protocol.SpendNoteTRC20.root)
  return root_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SpendNoteTRC20::set_allocated_root(std::string* root) {
  if (root != nullptr) {
    
  } else {
    
  }
  root_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), root,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendNoteTRC20.root)
}

// bytes path = 4;
inline void SpendNoteTRC20::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& SpendNoteTRC20::path() const {
  // @@protoc_insertion_point(field_get:protocol.SpendNoteTRC20.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpendNoteTRC20::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.SpendNoteTRC20.path)
}
inline std::string* SpendNoteTRC20::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:protocol.SpendNoteTRC20.path)
  return _s;
}
inline const std::string& SpendNoteTRC20::_internal_path() const {
  return path_.Get();
}
inline void SpendNoteTRC20::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SpendNoteTRC20::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SpendNoteTRC20::release_path() {
  // @@protoc_insertion_point(field_release:protocol.SpendNoteTRC20.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SpendNoteTRC20::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.SpendNoteTRC20.path)
}

// int64 pos = 5;
inline void SpendNoteTRC20::clear_pos() {
  pos_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SpendNoteTRC20::_internal_pos() const {
  return pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SpendNoteTRC20::pos() const {
  // @@protoc_insertion_point(field_get:protocol.SpendNoteTRC20.pos)
  return _internal_pos();
}
inline void SpendNoteTRC20::_internal_set_pos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  pos_ = value;
}
inline void SpendNoteTRC20::set_pos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:protocol.SpendNoteTRC20.pos)
}

// -------------------------------------------------------------------

// PrivateShieldedTRC20Parameters

// bytes ask = 1;
inline void PrivateShieldedTRC20Parameters::clear_ask() {
  ask_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20Parameters::ask() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20Parameters.ask)
  return _internal_ask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20Parameters::set_ask(ArgT0&& arg0, ArgT... args) {
 
 ask_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20Parameters.ask)
}
inline std::string* PrivateShieldedTRC20Parameters::mutable_ask() {
  std::string* _s = _internal_mutable_ask();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20Parameters.ask)
  return _s;
}
inline const std::string& PrivateShieldedTRC20Parameters::_internal_ask() const {
  return ask_.Get();
}
inline void PrivateShieldedTRC20Parameters::_internal_set_ask(const std::string& value) {
  
  ask_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::_internal_mutable_ask() {
  
  return ask_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::release_ask() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20Parameters.ask)
  return ask_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20Parameters::set_allocated_ask(std::string* ask) {
  if (ask != nullptr) {
    
  } else {
    
  }
  ask_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ask,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20Parameters.ask)
}

// bytes nsk = 2;
inline void PrivateShieldedTRC20Parameters::clear_nsk() {
  nsk_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20Parameters::nsk() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20Parameters.nsk)
  return _internal_nsk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20Parameters::set_nsk(ArgT0&& arg0, ArgT... args) {
 
 nsk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20Parameters.nsk)
}
inline std::string* PrivateShieldedTRC20Parameters::mutable_nsk() {
  std::string* _s = _internal_mutable_nsk();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20Parameters.nsk)
  return _s;
}
inline const std::string& PrivateShieldedTRC20Parameters::_internal_nsk() const {
  return nsk_.Get();
}
inline void PrivateShieldedTRC20Parameters::_internal_set_nsk(const std::string& value) {
  
  nsk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::_internal_mutable_nsk() {
  
  return nsk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::release_nsk() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20Parameters.nsk)
  return nsk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20Parameters::set_allocated_nsk(std::string* nsk) {
  if (nsk != nullptr) {
    
  } else {
    
  }
  nsk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nsk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20Parameters.nsk)
}

// bytes ovk = 3;
inline void PrivateShieldedTRC20Parameters::clear_ovk() {
  ovk_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20Parameters::ovk() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20Parameters.ovk)
  return _internal_ovk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20Parameters::set_ovk(ArgT0&& arg0, ArgT... args) {
 
 ovk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20Parameters.ovk)
}
inline std::string* PrivateShieldedTRC20Parameters::mutable_ovk() {
  std::string* _s = _internal_mutable_ovk();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20Parameters.ovk)
  return _s;
}
inline const std::string& PrivateShieldedTRC20Parameters::_internal_ovk() const {
  return ovk_.Get();
}
inline void PrivateShieldedTRC20Parameters::_internal_set_ovk(const std::string& value) {
  
  ovk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::_internal_mutable_ovk() {
  
  return ovk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::release_ovk() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20Parameters.ovk)
  return ovk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20Parameters::set_allocated_ovk(std::string* ovk) {
  if (ovk != nullptr) {
    
  } else {
    
  }
  ovk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ovk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20Parameters.ovk)
}

// string from_amount = 4;
inline void PrivateShieldedTRC20Parameters::clear_from_amount() {
  from_amount_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20Parameters::from_amount() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20Parameters.from_amount)
  return _internal_from_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20Parameters::set_from_amount(ArgT0&& arg0, ArgT... args) {
 
 from_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20Parameters.from_amount)
}
inline std::string* PrivateShieldedTRC20Parameters::mutable_from_amount() {
  std::string* _s = _internal_mutable_from_amount();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20Parameters.from_amount)
  return _s;
}
inline const std::string& PrivateShieldedTRC20Parameters::_internal_from_amount() const {
  return from_amount_.Get();
}
inline void PrivateShieldedTRC20Parameters::_internal_set_from_amount(const std::string& value) {
  
  from_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::_internal_mutable_from_amount() {
  
  return from_amount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::release_from_amount() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20Parameters.from_amount)
  return from_amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20Parameters::set_allocated_from_amount(std::string* from_amount) {
  if (from_amount != nullptr) {
    
  } else {
    
  }
  from_amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from_amount,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20Parameters.from_amount)
}

// repeated .protocol.SpendNoteTRC20 shielded_spends = 5;
inline int PrivateShieldedTRC20Parameters::_internal_shielded_spends_size() const {
  return shielded_spends_.size();
}
inline int PrivateShieldedTRC20Parameters::shielded_spends_size() const {
  return _internal_shielded_spends_size();
}
inline void PrivateShieldedTRC20Parameters::clear_shielded_spends() {
  shielded_spends_.Clear();
}
inline ::protocol::SpendNoteTRC20* PrivateShieldedTRC20Parameters::mutable_shielded_spends(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20Parameters.shielded_spends)
  return shielded_spends_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNoteTRC20 >*
PrivateShieldedTRC20Parameters::mutable_shielded_spends() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PrivateShieldedTRC20Parameters.shielded_spends)
  return &shielded_spends_;
}
inline const ::protocol::SpendNoteTRC20& PrivateShieldedTRC20Parameters::_internal_shielded_spends(int index) const {
  return shielded_spends_.Get(index);
}
inline const ::protocol::SpendNoteTRC20& PrivateShieldedTRC20Parameters::shielded_spends(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20Parameters.shielded_spends)
  return _internal_shielded_spends(index);
}
inline ::protocol::SpendNoteTRC20* PrivateShieldedTRC20Parameters::_internal_add_shielded_spends() {
  return shielded_spends_.Add();
}
inline ::protocol::SpendNoteTRC20* PrivateShieldedTRC20Parameters::add_shielded_spends() {
  ::protocol::SpendNoteTRC20* _add = _internal_add_shielded_spends();
  // @@protoc_insertion_point(field_add:protocol.PrivateShieldedTRC20Parameters.shielded_spends)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNoteTRC20 >&
PrivateShieldedTRC20Parameters::shielded_spends() const {
  // @@protoc_insertion_point(field_list:protocol.PrivateShieldedTRC20Parameters.shielded_spends)
  return shielded_spends_;
}

// repeated .protocol.ReceiveNote shielded_receives = 6;
inline int PrivateShieldedTRC20Parameters::_internal_shielded_receives_size() const {
  return shielded_receives_.size();
}
inline int PrivateShieldedTRC20Parameters::shielded_receives_size() const {
  return _internal_shielded_receives_size();
}
inline void PrivateShieldedTRC20Parameters::clear_shielded_receives() {
  shielded_receives_.Clear();
}
inline ::protocol::ReceiveNote* PrivateShieldedTRC20Parameters::mutable_shielded_receives(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20Parameters.shielded_receives)
  return shielded_receives_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >*
PrivateShieldedTRC20Parameters::mutable_shielded_receives() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PrivateShieldedTRC20Parameters.shielded_receives)
  return &shielded_receives_;
}
inline const ::protocol::ReceiveNote& PrivateShieldedTRC20Parameters::_internal_shielded_receives(int index) const {
  return shielded_receives_.Get(index);
}
inline const ::protocol::ReceiveNote& PrivateShieldedTRC20Parameters::shielded_receives(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20Parameters.shielded_receives)
  return _internal_shielded_receives(index);
}
inline ::protocol::ReceiveNote* PrivateShieldedTRC20Parameters::_internal_add_shielded_receives() {
  return shielded_receives_.Add();
}
inline ::protocol::ReceiveNote* PrivateShieldedTRC20Parameters::add_shielded_receives() {
  ::protocol::ReceiveNote* _add = _internal_add_shielded_receives();
  // @@protoc_insertion_point(field_add:protocol.PrivateShieldedTRC20Parameters.shielded_receives)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >&
PrivateShieldedTRC20Parameters::shielded_receives() const {
  // @@protoc_insertion_point(field_list:protocol.PrivateShieldedTRC20Parameters.shielded_receives)
  return shielded_receives_;
}

// bytes transparent_to_address = 7;
inline void PrivateShieldedTRC20Parameters::clear_transparent_to_address() {
  transparent_to_address_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20Parameters::transparent_to_address() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20Parameters.transparent_to_address)
  return _internal_transparent_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20Parameters::set_transparent_to_address(ArgT0&& arg0, ArgT... args) {
 
 transparent_to_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20Parameters.transparent_to_address)
}
inline std::string* PrivateShieldedTRC20Parameters::mutable_transparent_to_address() {
  std::string* _s = _internal_mutable_transparent_to_address();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20Parameters.transparent_to_address)
  return _s;
}
inline const std::string& PrivateShieldedTRC20Parameters::_internal_transparent_to_address() const {
  return transparent_to_address_.Get();
}
inline void PrivateShieldedTRC20Parameters::_internal_set_transparent_to_address(const std::string& value) {
  
  transparent_to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::_internal_mutable_transparent_to_address() {
  
  return transparent_to_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::release_transparent_to_address() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20Parameters.transparent_to_address)
  return transparent_to_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20Parameters::set_allocated_transparent_to_address(std::string* transparent_to_address) {
  if (transparent_to_address != nullptr) {
    
  } else {
    
  }
  transparent_to_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transparent_to_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20Parameters.transparent_to_address)
}

// string to_amount = 8;
inline void PrivateShieldedTRC20Parameters::clear_to_amount() {
  to_amount_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20Parameters::to_amount() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20Parameters.to_amount)
  return _internal_to_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20Parameters::set_to_amount(ArgT0&& arg0, ArgT... args) {
 
 to_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20Parameters.to_amount)
}
inline std::string* PrivateShieldedTRC20Parameters::mutable_to_amount() {
  std::string* _s = _internal_mutable_to_amount();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20Parameters.to_amount)
  return _s;
}
inline const std::string& PrivateShieldedTRC20Parameters::_internal_to_amount() const {
  return to_amount_.Get();
}
inline void PrivateShieldedTRC20Parameters::_internal_set_to_amount(const std::string& value) {
  
  to_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::_internal_mutable_to_amount() {
  
  return to_amount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::release_to_amount() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20Parameters.to_amount)
  return to_amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20Parameters::set_allocated_to_amount(std::string* to_amount) {
  if (to_amount != nullptr) {
    
  } else {
    
  }
  to_amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to_amount,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20Parameters.to_amount)
}

// bytes shielded_TRC20_contract_address = 9;
inline void PrivateShieldedTRC20Parameters::clear_shielded_trc20_contract_address() {
  shielded_trc20_contract_address_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20Parameters::shielded_trc20_contract_address() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20Parameters.shielded_TRC20_contract_address)
  return _internal_shielded_trc20_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20Parameters::set_shielded_trc20_contract_address(ArgT0&& arg0, ArgT... args) {
 
 shielded_trc20_contract_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20Parameters.shielded_TRC20_contract_address)
}
inline std::string* PrivateShieldedTRC20Parameters::mutable_shielded_trc20_contract_address() {
  std::string* _s = _internal_mutable_shielded_trc20_contract_address();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20Parameters.shielded_TRC20_contract_address)
  return _s;
}
inline const std::string& PrivateShieldedTRC20Parameters::_internal_shielded_trc20_contract_address() const {
  return shielded_trc20_contract_address_.Get();
}
inline void PrivateShieldedTRC20Parameters::_internal_set_shielded_trc20_contract_address(const std::string& value) {
  
  shielded_trc20_contract_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::_internal_mutable_shielded_trc20_contract_address() {
  
  return shielded_trc20_contract_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20Parameters::release_shielded_trc20_contract_address() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20Parameters.shielded_TRC20_contract_address)
  return shielded_trc20_contract_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20Parameters::set_allocated_shielded_trc20_contract_address(std::string* shielded_trc20_contract_address) {
  if (shielded_trc20_contract_address != nullptr) {
    
  } else {
    
  }
  shielded_trc20_contract_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shielded_trc20_contract_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20Parameters.shielded_TRC20_contract_address)
}

// -------------------------------------------------------------------

// PrivateShieldedTRC20ParametersWithoutAsk

// bytes ak = 1;
inline void PrivateShieldedTRC20ParametersWithoutAsk::clear_ak() {
  ak_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::ak() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20ParametersWithoutAsk.ak)
  return _internal_ak();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20ParametersWithoutAsk::set_ak(ArgT0&& arg0, ArgT... args) {
 
 ak_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20ParametersWithoutAsk.ak)
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::mutable_ak() {
  std::string* _s = _internal_mutable_ak();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20ParametersWithoutAsk.ak)
  return _s;
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::_internal_ak() const {
  return ak_.Get();
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::_internal_set_ak(const std::string& value) {
  
  ak_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::_internal_mutable_ak() {
  
  return ak_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::release_ak() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20ParametersWithoutAsk.ak)
  return ak_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::set_allocated_ak(std::string* ak) {
  if (ak != nullptr) {
    
  } else {
    
  }
  ak_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ak,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20ParametersWithoutAsk.ak)
}

// bytes nsk = 2;
inline void PrivateShieldedTRC20ParametersWithoutAsk::clear_nsk() {
  nsk_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::nsk() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20ParametersWithoutAsk.nsk)
  return _internal_nsk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20ParametersWithoutAsk::set_nsk(ArgT0&& arg0, ArgT... args) {
 
 nsk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20ParametersWithoutAsk.nsk)
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::mutable_nsk() {
  std::string* _s = _internal_mutable_nsk();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20ParametersWithoutAsk.nsk)
  return _s;
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::_internal_nsk() const {
  return nsk_.Get();
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::_internal_set_nsk(const std::string& value) {
  
  nsk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::_internal_mutable_nsk() {
  
  return nsk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::release_nsk() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20ParametersWithoutAsk.nsk)
  return nsk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::set_allocated_nsk(std::string* nsk) {
  if (nsk != nullptr) {
    
  } else {
    
  }
  nsk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nsk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20ParametersWithoutAsk.nsk)
}

// bytes ovk = 3;
inline void PrivateShieldedTRC20ParametersWithoutAsk::clear_ovk() {
  ovk_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::ovk() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20ParametersWithoutAsk.ovk)
  return _internal_ovk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20ParametersWithoutAsk::set_ovk(ArgT0&& arg0, ArgT... args) {
 
 ovk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20ParametersWithoutAsk.ovk)
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::mutable_ovk() {
  std::string* _s = _internal_mutable_ovk();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20ParametersWithoutAsk.ovk)
  return _s;
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::_internal_ovk() const {
  return ovk_.Get();
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::_internal_set_ovk(const std::string& value) {
  
  ovk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::_internal_mutable_ovk() {
  
  return ovk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::release_ovk() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20ParametersWithoutAsk.ovk)
  return ovk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::set_allocated_ovk(std::string* ovk) {
  if (ovk != nullptr) {
    
  } else {
    
  }
  ovk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ovk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20ParametersWithoutAsk.ovk)
}

// string from_amount = 4;
inline void PrivateShieldedTRC20ParametersWithoutAsk::clear_from_amount() {
  from_amount_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::from_amount() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20ParametersWithoutAsk.from_amount)
  return _internal_from_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20ParametersWithoutAsk::set_from_amount(ArgT0&& arg0, ArgT... args) {
 
 from_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20ParametersWithoutAsk.from_amount)
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::mutable_from_amount() {
  std::string* _s = _internal_mutable_from_amount();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20ParametersWithoutAsk.from_amount)
  return _s;
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::_internal_from_amount() const {
  return from_amount_.Get();
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::_internal_set_from_amount(const std::string& value) {
  
  from_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::_internal_mutable_from_amount() {
  
  return from_amount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::release_from_amount() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20ParametersWithoutAsk.from_amount)
  return from_amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::set_allocated_from_amount(std::string* from_amount) {
  if (from_amount != nullptr) {
    
  } else {
    
  }
  from_amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from_amount,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20ParametersWithoutAsk.from_amount)
}

// repeated .protocol.SpendNoteTRC20 shielded_spends = 5;
inline int PrivateShieldedTRC20ParametersWithoutAsk::_internal_shielded_spends_size() const {
  return shielded_spends_.size();
}
inline int PrivateShieldedTRC20ParametersWithoutAsk::shielded_spends_size() const {
  return _internal_shielded_spends_size();
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::clear_shielded_spends() {
  shielded_spends_.Clear();
}
inline ::protocol::SpendNoteTRC20* PrivateShieldedTRC20ParametersWithoutAsk::mutable_shielded_spends(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_spends)
  return shielded_spends_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNoteTRC20 >*
PrivateShieldedTRC20ParametersWithoutAsk::mutable_shielded_spends() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_spends)
  return &shielded_spends_;
}
inline const ::protocol::SpendNoteTRC20& PrivateShieldedTRC20ParametersWithoutAsk::_internal_shielded_spends(int index) const {
  return shielded_spends_.Get(index);
}
inline const ::protocol::SpendNoteTRC20& PrivateShieldedTRC20ParametersWithoutAsk::shielded_spends(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_spends)
  return _internal_shielded_spends(index);
}
inline ::protocol::SpendNoteTRC20* PrivateShieldedTRC20ParametersWithoutAsk::_internal_add_shielded_spends() {
  return shielded_spends_.Add();
}
inline ::protocol::SpendNoteTRC20* PrivateShieldedTRC20ParametersWithoutAsk::add_shielded_spends() {
  ::protocol::SpendNoteTRC20* _add = _internal_add_shielded_spends();
  // @@protoc_insertion_point(field_add:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_spends)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendNoteTRC20 >&
PrivateShieldedTRC20ParametersWithoutAsk::shielded_spends() const {
  // @@protoc_insertion_point(field_list:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_spends)
  return shielded_spends_;
}

// repeated .protocol.ReceiveNote shielded_receives = 6;
inline int PrivateShieldedTRC20ParametersWithoutAsk::_internal_shielded_receives_size() const {
  return shielded_receives_.size();
}
inline int PrivateShieldedTRC20ParametersWithoutAsk::shielded_receives_size() const {
  return _internal_shielded_receives_size();
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::clear_shielded_receives() {
  shielded_receives_.Clear();
}
inline ::protocol::ReceiveNote* PrivateShieldedTRC20ParametersWithoutAsk::mutable_shielded_receives(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_receives)
  return shielded_receives_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >*
PrivateShieldedTRC20ParametersWithoutAsk::mutable_shielded_receives() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_receives)
  return &shielded_receives_;
}
inline const ::protocol::ReceiveNote& PrivateShieldedTRC20ParametersWithoutAsk::_internal_shielded_receives(int index) const {
  return shielded_receives_.Get(index);
}
inline const ::protocol::ReceiveNote& PrivateShieldedTRC20ParametersWithoutAsk::shielded_receives(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_receives)
  return _internal_shielded_receives(index);
}
inline ::protocol::ReceiveNote* PrivateShieldedTRC20ParametersWithoutAsk::_internal_add_shielded_receives() {
  return shielded_receives_.Add();
}
inline ::protocol::ReceiveNote* PrivateShieldedTRC20ParametersWithoutAsk::add_shielded_receives() {
  ::protocol::ReceiveNote* _add = _internal_add_shielded_receives();
  // @@protoc_insertion_point(field_add:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_receives)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveNote >&
PrivateShieldedTRC20ParametersWithoutAsk::shielded_receives() const {
  // @@protoc_insertion_point(field_list:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_receives)
  return shielded_receives_;
}

// bytes transparent_to_address = 7;
inline void PrivateShieldedTRC20ParametersWithoutAsk::clear_transparent_to_address() {
  transparent_to_address_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::transparent_to_address() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20ParametersWithoutAsk.transparent_to_address)
  return _internal_transparent_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20ParametersWithoutAsk::set_transparent_to_address(ArgT0&& arg0, ArgT... args) {
 
 transparent_to_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20ParametersWithoutAsk.transparent_to_address)
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::mutable_transparent_to_address() {
  std::string* _s = _internal_mutable_transparent_to_address();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20ParametersWithoutAsk.transparent_to_address)
  return _s;
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::_internal_transparent_to_address() const {
  return transparent_to_address_.Get();
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::_internal_set_transparent_to_address(const std::string& value) {
  
  transparent_to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::_internal_mutable_transparent_to_address() {
  
  return transparent_to_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::release_transparent_to_address() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20ParametersWithoutAsk.transparent_to_address)
  return transparent_to_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::set_allocated_transparent_to_address(std::string* transparent_to_address) {
  if (transparent_to_address != nullptr) {
    
  } else {
    
  }
  transparent_to_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transparent_to_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20ParametersWithoutAsk.transparent_to_address)
}

// string to_amount = 8;
inline void PrivateShieldedTRC20ParametersWithoutAsk::clear_to_amount() {
  to_amount_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::to_amount() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20ParametersWithoutAsk.to_amount)
  return _internal_to_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20ParametersWithoutAsk::set_to_amount(ArgT0&& arg0, ArgT... args) {
 
 to_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20ParametersWithoutAsk.to_amount)
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::mutable_to_amount() {
  std::string* _s = _internal_mutable_to_amount();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20ParametersWithoutAsk.to_amount)
  return _s;
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::_internal_to_amount() const {
  return to_amount_.Get();
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::_internal_set_to_amount(const std::string& value) {
  
  to_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::_internal_mutable_to_amount() {
  
  return to_amount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::release_to_amount() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20ParametersWithoutAsk.to_amount)
  return to_amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::set_allocated_to_amount(std::string* to_amount) {
  if (to_amount != nullptr) {
    
  } else {
    
  }
  to_amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to_amount,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20ParametersWithoutAsk.to_amount)
}

// bytes shielded_TRC20_contract_address = 9;
inline void PrivateShieldedTRC20ParametersWithoutAsk::clear_shielded_trc20_contract_address() {
  shielded_trc20_contract_address_.ClearToEmpty();
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::shielded_trc20_contract_address() const {
  // @@protoc_insertion_point(field_get:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_TRC20_contract_address)
  return _internal_shielded_trc20_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShieldedTRC20ParametersWithoutAsk::set_shielded_trc20_contract_address(ArgT0&& arg0, ArgT... args) {
 
 shielded_trc20_contract_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_TRC20_contract_address)
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::mutable_shielded_trc20_contract_address() {
  std::string* _s = _internal_mutable_shielded_trc20_contract_address();
  // @@protoc_insertion_point(field_mutable:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_TRC20_contract_address)
  return _s;
}
inline const std::string& PrivateShieldedTRC20ParametersWithoutAsk::_internal_shielded_trc20_contract_address() const {
  return shielded_trc20_contract_address_.Get();
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::_internal_set_shielded_trc20_contract_address(const std::string& value) {
  
  shielded_trc20_contract_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::_internal_mutable_shielded_trc20_contract_address() {
  
  return shielded_trc20_contract_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivateShieldedTRC20ParametersWithoutAsk::release_shielded_trc20_contract_address() {
  // @@protoc_insertion_point(field_release:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_TRC20_contract_address)
  return shielded_trc20_contract_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivateShieldedTRC20ParametersWithoutAsk::set_allocated_shielded_trc20_contract_address(std::string* shielded_trc20_contract_address) {
  if (shielded_trc20_contract_address != nullptr) {
    
  } else {
    
  }
  shielded_trc20_contract_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shielded_trc20_contract_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.PrivateShieldedTRC20ParametersWithoutAsk.shielded_TRC20_contract_address)
}

// -------------------------------------------------------------------

// ShieldedTRC20Parameters

// repeated .protocol.SpendDescription spend_description = 1;
inline int ShieldedTRC20Parameters::_internal_spend_description_size() const {
  return spend_description_.size();
}
inline int ShieldedTRC20Parameters::spend_description_size() const {
  return _internal_spend_description_size();
}
inline ::protocol::SpendDescription* ShieldedTRC20Parameters::mutable_spend_description(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTRC20Parameters.spend_description)
  return spend_description_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendDescription >*
ShieldedTRC20Parameters::mutable_spend_description() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ShieldedTRC20Parameters.spend_description)
  return &spend_description_;
}
inline const ::protocol::SpendDescription& ShieldedTRC20Parameters::_internal_spend_description(int index) const {
  return spend_description_.Get(index);
}
inline const ::protocol::SpendDescription& ShieldedTRC20Parameters::spend_description(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTRC20Parameters.spend_description)
  return _internal_spend_description(index);
}
inline ::protocol::SpendDescription* ShieldedTRC20Parameters::_internal_add_spend_description() {
  return spend_description_.Add();
}
inline ::protocol::SpendDescription* ShieldedTRC20Parameters::add_spend_description() {
  ::protocol::SpendDescription* _add = _internal_add_spend_description();
  // @@protoc_insertion_point(field_add:protocol.ShieldedTRC20Parameters.spend_description)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::SpendDescription >&
ShieldedTRC20Parameters::spend_description() const {
  // @@protoc_insertion_point(field_list:protocol.ShieldedTRC20Parameters.spend_description)
  return spend_description_;
}

// repeated .protocol.ReceiveDescription receive_description = 2;
inline int ShieldedTRC20Parameters::_internal_receive_description_size() const {
  return receive_description_.size();
}
inline int ShieldedTRC20Parameters::receive_description_size() const {
  return _internal_receive_description_size();
}
inline ::protocol::ReceiveDescription* ShieldedTRC20Parameters::mutable_receive_description(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTRC20Parameters.receive_description)
  return receive_description_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveDescription >*
ShieldedTRC20Parameters::mutable_receive_description() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ShieldedTRC20Parameters.receive_description)
  return &receive_description_;
}
inline const ::protocol::ReceiveDescription& ShieldedTRC20Parameters::_internal_receive_description(int index) const {
  return receive_description_.Get(index);
}
inline const ::protocol::ReceiveDescription& ShieldedTRC20Parameters::receive_description(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTRC20Parameters.receive_description)
  return _internal_receive_description(index);
}
inline ::protocol::ReceiveDescription* ShieldedTRC20Parameters::_internal_add_receive_description() {
  return receive_description_.Add();
}
inline ::protocol::ReceiveDescription* ShieldedTRC20Parameters::add_receive_description() {
  ::protocol::ReceiveDescription* _add = _internal_add_receive_description();
  // @@protoc_insertion_point(field_add:protocol.ShieldedTRC20Parameters.receive_description)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ReceiveDescription >&
ShieldedTRC20Parameters::receive_description() const {
  // @@protoc_insertion_point(field_list:protocol.ShieldedTRC20Parameters.receive_description)
  return receive_description_;
}

// bytes binding_signature = 3;
inline void ShieldedTRC20Parameters::clear_binding_signature() {
  binding_signature_.ClearToEmpty();
}
inline const std::string& ShieldedTRC20Parameters::binding_signature() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTRC20Parameters.binding_signature)
  return _internal_binding_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedTRC20Parameters::set_binding_signature(ArgT0&& arg0, ArgT... args) {
 
 binding_signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedTRC20Parameters.binding_signature)
}
inline std::string* ShieldedTRC20Parameters::mutable_binding_signature() {
  std::string* _s = _internal_mutable_binding_signature();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTRC20Parameters.binding_signature)
  return _s;
}
inline const std::string& ShieldedTRC20Parameters::_internal_binding_signature() const {
  return binding_signature_.Get();
}
inline void ShieldedTRC20Parameters::_internal_set_binding_signature(const std::string& value) {
  
  binding_signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedTRC20Parameters::_internal_mutable_binding_signature() {
  
  return binding_signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedTRC20Parameters::release_binding_signature() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedTRC20Parameters.binding_signature)
  return binding_signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedTRC20Parameters::set_allocated_binding_signature(std::string* binding_signature) {
  if (binding_signature != nullptr) {
    
  } else {
    
  }
  binding_signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), binding_signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedTRC20Parameters.binding_signature)
}

// bytes message_hash = 4;
inline void ShieldedTRC20Parameters::clear_message_hash() {
  message_hash_.ClearToEmpty();
}
inline const std::string& ShieldedTRC20Parameters::message_hash() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTRC20Parameters.message_hash)
  return _internal_message_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedTRC20Parameters::set_message_hash(ArgT0&& arg0, ArgT... args) {
 
 message_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedTRC20Parameters.message_hash)
}
inline std::string* ShieldedTRC20Parameters::mutable_message_hash() {
  std::string* _s = _internal_mutable_message_hash();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTRC20Parameters.message_hash)
  return _s;
}
inline const std::string& ShieldedTRC20Parameters::_internal_message_hash() const {
  return message_hash_.Get();
}
inline void ShieldedTRC20Parameters::_internal_set_message_hash(const std::string& value) {
  
  message_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedTRC20Parameters::_internal_mutable_message_hash() {
  
  return message_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedTRC20Parameters::release_message_hash() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedTRC20Parameters.message_hash)
  return message_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedTRC20Parameters::set_allocated_message_hash(std::string* message_hash) {
  if (message_hash != nullptr) {
    
  } else {
    
  }
  message_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedTRC20Parameters.message_hash)
}

// string trigger_contract_input = 5;
inline void ShieldedTRC20Parameters::clear_trigger_contract_input() {
  trigger_contract_input_.ClearToEmpty();
}
inline const std::string& ShieldedTRC20Parameters::trigger_contract_input() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTRC20Parameters.trigger_contract_input)
  return _internal_trigger_contract_input();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedTRC20Parameters::set_trigger_contract_input(ArgT0&& arg0, ArgT... args) {
 
 trigger_contract_input_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedTRC20Parameters.trigger_contract_input)
}
inline std::string* ShieldedTRC20Parameters::mutable_trigger_contract_input() {
  std::string* _s = _internal_mutable_trigger_contract_input();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTRC20Parameters.trigger_contract_input)
  return _s;
}
inline const std::string& ShieldedTRC20Parameters::_internal_trigger_contract_input() const {
  return trigger_contract_input_.Get();
}
inline void ShieldedTRC20Parameters::_internal_set_trigger_contract_input(const std::string& value) {
  
  trigger_contract_input_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedTRC20Parameters::_internal_mutable_trigger_contract_input() {
  
  return trigger_contract_input_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedTRC20Parameters::release_trigger_contract_input() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedTRC20Parameters.trigger_contract_input)
  return trigger_contract_input_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedTRC20Parameters::set_allocated_trigger_contract_input(std::string* trigger_contract_input) {
  if (trigger_contract_input != nullptr) {
    
  } else {
    
  }
  trigger_contract_input_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trigger_contract_input,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedTRC20Parameters.trigger_contract_input)
}

// string parameter_type = 6;
inline void ShieldedTRC20Parameters::clear_parameter_type() {
  parameter_type_.ClearToEmpty();
}
inline const std::string& ShieldedTRC20Parameters::parameter_type() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTRC20Parameters.parameter_type)
  return _internal_parameter_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedTRC20Parameters::set_parameter_type(ArgT0&& arg0, ArgT... args) {
 
 parameter_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedTRC20Parameters.parameter_type)
}
inline std::string* ShieldedTRC20Parameters::mutable_parameter_type() {
  std::string* _s = _internal_mutable_parameter_type();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTRC20Parameters.parameter_type)
  return _s;
}
inline const std::string& ShieldedTRC20Parameters::_internal_parameter_type() const {
  return parameter_type_.Get();
}
inline void ShieldedTRC20Parameters::_internal_set_parameter_type(const std::string& value) {
  
  parameter_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedTRC20Parameters::_internal_mutable_parameter_type() {
  
  return parameter_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedTRC20Parameters::release_parameter_type() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedTRC20Parameters.parameter_type)
  return parameter_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedTRC20Parameters::set_allocated_parameter_type(std::string* parameter_type) {
  if (parameter_type != nullptr) {
    
  } else {
    
  }
  parameter_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parameter_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedTRC20Parameters.parameter_type)
}

// -------------------------------------------------------------------

// IvkDecryptTRC20Parameters

// int64 start_block_index = 1;
inline void IvkDecryptTRC20Parameters::clear_start_block_index() {
  start_block_index_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IvkDecryptTRC20Parameters::_internal_start_block_index() const {
  return start_block_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IvkDecryptTRC20Parameters::start_block_index() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptTRC20Parameters.start_block_index)
  return _internal_start_block_index();
}
inline void IvkDecryptTRC20Parameters::_internal_set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  start_block_index_ = value;
}
inline void IvkDecryptTRC20Parameters::set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_block_index(value);
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptTRC20Parameters.start_block_index)
}

// int64 end_block_index = 2;
inline void IvkDecryptTRC20Parameters::clear_end_block_index() {
  end_block_index_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IvkDecryptTRC20Parameters::_internal_end_block_index() const {
  return end_block_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IvkDecryptTRC20Parameters::end_block_index() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptTRC20Parameters.end_block_index)
  return _internal_end_block_index();
}
inline void IvkDecryptTRC20Parameters::_internal_set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  end_block_index_ = value;
}
inline void IvkDecryptTRC20Parameters::set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end_block_index(value);
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptTRC20Parameters.end_block_index)
}

// bytes shielded_TRC20_contract_address = 3;
inline void IvkDecryptTRC20Parameters::clear_shielded_trc20_contract_address() {
  shielded_trc20_contract_address_.ClearToEmpty();
}
inline const std::string& IvkDecryptTRC20Parameters::shielded_trc20_contract_address() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptTRC20Parameters.shielded_TRC20_contract_address)
  return _internal_shielded_trc20_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IvkDecryptTRC20Parameters::set_shielded_trc20_contract_address(ArgT0&& arg0, ArgT... args) {
 
 shielded_trc20_contract_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptTRC20Parameters.shielded_TRC20_contract_address)
}
inline std::string* IvkDecryptTRC20Parameters::mutable_shielded_trc20_contract_address() {
  std::string* _s = _internal_mutable_shielded_trc20_contract_address();
  // @@protoc_insertion_point(field_mutable:protocol.IvkDecryptTRC20Parameters.shielded_TRC20_contract_address)
  return _s;
}
inline const std::string& IvkDecryptTRC20Parameters::_internal_shielded_trc20_contract_address() const {
  return shielded_trc20_contract_address_.Get();
}
inline void IvkDecryptTRC20Parameters::_internal_set_shielded_trc20_contract_address(const std::string& value) {
  
  shielded_trc20_contract_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IvkDecryptTRC20Parameters::_internal_mutable_shielded_trc20_contract_address() {
  
  return shielded_trc20_contract_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IvkDecryptTRC20Parameters::release_shielded_trc20_contract_address() {
  // @@protoc_insertion_point(field_release:protocol.IvkDecryptTRC20Parameters.shielded_TRC20_contract_address)
  return shielded_trc20_contract_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IvkDecryptTRC20Parameters::set_allocated_shielded_trc20_contract_address(std::string* shielded_trc20_contract_address) {
  if (shielded_trc20_contract_address != nullptr) {
    
  } else {
    
  }
  shielded_trc20_contract_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shielded_trc20_contract_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.IvkDecryptTRC20Parameters.shielded_TRC20_contract_address)
}

// bytes ivk = 4;
inline void IvkDecryptTRC20Parameters::clear_ivk() {
  ivk_.ClearToEmpty();
}
inline const std::string& IvkDecryptTRC20Parameters::ivk() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptTRC20Parameters.ivk)
  return _internal_ivk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IvkDecryptTRC20Parameters::set_ivk(ArgT0&& arg0, ArgT... args) {
 
 ivk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptTRC20Parameters.ivk)
}
inline std::string* IvkDecryptTRC20Parameters::mutable_ivk() {
  std::string* _s = _internal_mutable_ivk();
  // @@protoc_insertion_point(field_mutable:protocol.IvkDecryptTRC20Parameters.ivk)
  return _s;
}
inline const std::string& IvkDecryptTRC20Parameters::_internal_ivk() const {
  return ivk_.Get();
}
inline void IvkDecryptTRC20Parameters::_internal_set_ivk(const std::string& value) {
  
  ivk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IvkDecryptTRC20Parameters::_internal_mutable_ivk() {
  
  return ivk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IvkDecryptTRC20Parameters::release_ivk() {
  // @@protoc_insertion_point(field_release:protocol.IvkDecryptTRC20Parameters.ivk)
  return ivk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IvkDecryptTRC20Parameters::set_allocated_ivk(std::string* ivk) {
  if (ivk != nullptr) {
    
  } else {
    
  }
  ivk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ivk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.IvkDecryptTRC20Parameters.ivk)
}

// bytes ak = 5;
inline void IvkDecryptTRC20Parameters::clear_ak() {
  ak_.ClearToEmpty();
}
inline const std::string& IvkDecryptTRC20Parameters::ak() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptTRC20Parameters.ak)
  return _internal_ak();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IvkDecryptTRC20Parameters::set_ak(ArgT0&& arg0, ArgT... args) {
 
 ak_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptTRC20Parameters.ak)
}
inline std::string* IvkDecryptTRC20Parameters::mutable_ak() {
  std::string* _s = _internal_mutable_ak();
  // @@protoc_insertion_point(field_mutable:protocol.IvkDecryptTRC20Parameters.ak)
  return _s;
}
inline const std::string& IvkDecryptTRC20Parameters::_internal_ak() const {
  return ak_.Get();
}
inline void IvkDecryptTRC20Parameters::_internal_set_ak(const std::string& value) {
  
  ak_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IvkDecryptTRC20Parameters::_internal_mutable_ak() {
  
  return ak_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IvkDecryptTRC20Parameters::release_ak() {
  // @@protoc_insertion_point(field_release:protocol.IvkDecryptTRC20Parameters.ak)
  return ak_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IvkDecryptTRC20Parameters::set_allocated_ak(std::string* ak) {
  if (ak != nullptr) {
    
  } else {
    
  }
  ak_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ak,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.IvkDecryptTRC20Parameters.ak)
}

// bytes nk = 6;
inline void IvkDecryptTRC20Parameters::clear_nk() {
  nk_.ClearToEmpty();
}
inline const std::string& IvkDecryptTRC20Parameters::nk() const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptTRC20Parameters.nk)
  return _internal_nk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IvkDecryptTRC20Parameters::set_nk(ArgT0&& arg0, ArgT... args) {
 
 nk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptTRC20Parameters.nk)
}
inline std::string* IvkDecryptTRC20Parameters::mutable_nk() {
  std::string* _s = _internal_mutable_nk();
  // @@protoc_insertion_point(field_mutable:protocol.IvkDecryptTRC20Parameters.nk)
  return _s;
}
inline const std::string& IvkDecryptTRC20Parameters::_internal_nk() const {
  return nk_.Get();
}
inline void IvkDecryptTRC20Parameters::_internal_set_nk(const std::string& value) {
  
  nk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IvkDecryptTRC20Parameters::_internal_mutable_nk() {
  
  return nk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IvkDecryptTRC20Parameters::release_nk() {
  // @@protoc_insertion_point(field_release:protocol.IvkDecryptTRC20Parameters.nk)
  return nk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IvkDecryptTRC20Parameters::set_allocated_nk(std::string* nk) {
  if (nk != nullptr) {
    
  } else {
    
  }
  nk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.IvkDecryptTRC20Parameters.nk)
}

// repeated string events = 7;
inline int IvkDecryptTRC20Parameters::_internal_events_size() const {
  return events_.size();
}
inline int IvkDecryptTRC20Parameters::events_size() const {
  return _internal_events_size();
}
inline void IvkDecryptTRC20Parameters::clear_events() {
  events_.Clear();
}
inline std::string* IvkDecryptTRC20Parameters::add_events() {
  std::string* _s = _internal_add_events();
  // @@protoc_insertion_point(field_add_mutable:protocol.IvkDecryptTRC20Parameters.events)
  return _s;
}
inline const std::string& IvkDecryptTRC20Parameters::_internal_events(int index) const {
  return events_.Get(index);
}
inline const std::string& IvkDecryptTRC20Parameters::events(int index) const {
  // @@protoc_insertion_point(field_get:protocol.IvkDecryptTRC20Parameters.events)
  return _internal_events(index);
}
inline std::string* IvkDecryptTRC20Parameters::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.IvkDecryptTRC20Parameters.events)
  return events_.Mutable(index);
}
inline void IvkDecryptTRC20Parameters::set_events(int index, const std::string& value) {
  events_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptTRC20Parameters.events)
}
inline void IvkDecryptTRC20Parameters::set_events(int index, std::string&& value) {
  events_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.IvkDecryptTRC20Parameters.events)
}
inline void IvkDecryptTRC20Parameters::set_events(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  events_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.IvkDecryptTRC20Parameters.events)
}
inline void IvkDecryptTRC20Parameters::set_events(int index, const char* value, size_t size) {
  events_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.IvkDecryptTRC20Parameters.events)
}
inline std::string* IvkDecryptTRC20Parameters::_internal_add_events() {
  return events_.Add();
}
inline void IvkDecryptTRC20Parameters::add_events(const std::string& value) {
  events_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.IvkDecryptTRC20Parameters.events)
}
inline void IvkDecryptTRC20Parameters::add_events(std::string&& value) {
  events_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.IvkDecryptTRC20Parameters.events)
}
inline void IvkDecryptTRC20Parameters::add_events(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  events_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.IvkDecryptTRC20Parameters.events)
}
inline void IvkDecryptTRC20Parameters::add_events(const char* value, size_t size) {
  events_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.IvkDecryptTRC20Parameters.events)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IvkDecryptTRC20Parameters::events() const {
  // @@protoc_insertion_point(field_list:protocol.IvkDecryptTRC20Parameters.events)
  return events_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IvkDecryptTRC20Parameters::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:protocol.IvkDecryptTRC20Parameters.events)
  return &events_;
}

// -------------------------------------------------------------------

// OvkDecryptTRC20Parameters

// int64 start_block_index = 1;
inline void OvkDecryptTRC20Parameters::clear_start_block_index() {
  start_block_index_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OvkDecryptTRC20Parameters::_internal_start_block_index() const {
  return start_block_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OvkDecryptTRC20Parameters::start_block_index() const {
  // @@protoc_insertion_point(field_get:protocol.OvkDecryptTRC20Parameters.start_block_index)
  return _internal_start_block_index();
}
inline void OvkDecryptTRC20Parameters::_internal_set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  start_block_index_ = value;
}
inline void OvkDecryptTRC20Parameters::set_start_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_block_index(value);
  // @@protoc_insertion_point(field_set:protocol.OvkDecryptTRC20Parameters.start_block_index)
}

// int64 end_block_index = 2;
inline void OvkDecryptTRC20Parameters::clear_end_block_index() {
  end_block_index_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OvkDecryptTRC20Parameters::_internal_end_block_index() const {
  return end_block_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OvkDecryptTRC20Parameters::end_block_index() const {
  // @@protoc_insertion_point(field_get:protocol.OvkDecryptTRC20Parameters.end_block_index)
  return _internal_end_block_index();
}
inline void OvkDecryptTRC20Parameters::_internal_set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  end_block_index_ = value;
}
inline void OvkDecryptTRC20Parameters::set_end_block_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end_block_index(value);
  // @@protoc_insertion_point(field_set:protocol.OvkDecryptTRC20Parameters.end_block_index)
}

// bytes ovk = 3;
inline void OvkDecryptTRC20Parameters::clear_ovk() {
  ovk_.ClearToEmpty();
}
inline const std::string& OvkDecryptTRC20Parameters::ovk() const {
  // @@protoc_insertion_point(field_get:protocol.OvkDecryptTRC20Parameters.ovk)
  return _internal_ovk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OvkDecryptTRC20Parameters::set_ovk(ArgT0&& arg0, ArgT... args) {
 
 ovk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.OvkDecryptTRC20Parameters.ovk)
}
inline std::string* OvkDecryptTRC20Parameters::mutable_ovk() {
  std::string* _s = _internal_mutable_ovk();
  // @@protoc_insertion_point(field_mutable:protocol.OvkDecryptTRC20Parameters.ovk)
  return _s;
}
inline const std::string& OvkDecryptTRC20Parameters::_internal_ovk() const {
  return ovk_.Get();
}
inline void OvkDecryptTRC20Parameters::_internal_set_ovk(const std::string& value) {
  
  ovk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OvkDecryptTRC20Parameters::_internal_mutable_ovk() {
  
  return ovk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OvkDecryptTRC20Parameters::release_ovk() {
  // @@protoc_insertion_point(field_release:protocol.OvkDecryptTRC20Parameters.ovk)
  return ovk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OvkDecryptTRC20Parameters::set_allocated_ovk(std::string* ovk) {
  if (ovk != nullptr) {
    
  } else {
    
  }
  ovk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ovk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.OvkDecryptTRC20Parameters.ovk)
}

// bytes shielded_TRC20_contract_address = 4;
inline void OvkDecryptTRC20Parameters::clear_shielded_trc20_contract_address() {
  shielded_trc20_contract_address_.ClearToEmpty();
}
inline const std::string& OvkDecryptTRC20Parameters::shielded_trc20_contract_address() const {
  // @@protoc_insertion_point(field_get:protocol.OvkDecryptTRC20Parameters.shielded_TRC20_contract_address)
  return _internal_shielded_trc20_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OvkDecryptTRC20Parameters::set_shielded_trc20_contract_address(ArgT0&& arg0, ArgT... args) {
 
 shielded_trc20_contract_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.OvkDecryptTRC20Parameters.shielded_TRC20_contract_address)
}
inline std::string* OvkDecryptTRC20Parameters::mutable_shielded_trc20_contract_address() {
  std::string* _s = _internal_mutable_shielded_trc20_contract_address();
  // @@protoc_insertion_point(field_mutable:protocol.OvkDecryptTRC20Parameters.shielded_TRC20_contract_address)
  return _s;
}
inline const std::string& OvkDecryptTRC20Parameters::_internal_shielded_trc20_contract_address() const {
  return shielded_trc20_contract_address_.Get();
}
inline void OvkDecryptTRC20Parameters::_internal_set_shielded_trc20_contract_address(const std::string& value) {
  
  shielded_trc20_contract_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OvkDecryptTRC20Parameters::_internal_mutable_shielded_trc20_contract_address() {
  
  return shielded_trc20_contract_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OvkDecryptTRC20Parameters::release_shielded_trc20_contract_address() {
  // @@protoc_insertion_point(field_release:protocol.OvkDecryptTRC20Parameters.shielded_TRC20_contract_address)
  return shielded_trc20_contract_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OvkDecryptTRC20Parameters::set_allocated_shielded_trc20_contract_address(std::string* shielded_trc20_contract_address) {
  if (shielded_trc20_contract_address != nullptr) {
    
  } else {
    
  }
  shielded_trc20_contract_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shielded_trc20_contract_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.OvkDecryptTRC20Parameters.shielded_TRC20_contract_address)
}

// repeated string events = 5;
inline int OvkDecryptTRC20Parameters::_internal_events_size() const {
  return events_.size();
}
inline int OvkDecryptTRC20Parameters::events_size() const {
  return _internal_events_size();
}
inline void OvkDecryptTRC20Parameters::clear_events() {
  events_.Clear();
}
inline std::string* OvkDecryptTRC20Parameters::add_events() {
  std::string* _s = _internal_add_events();
  // @@protoc_insertion_point(field_add_mutable:protocol.OvkDecryptTRC20Parameters.events)
  return _s;
}
inline const std::string& OvkDecryptTRC20Parameters::_internal_events(int index) const {
  return events_.Get(index);
}
inline const std::string& OvkDecryptTRC20Parameters::events(int index) const {
  // @@protoc_insertion_point(field_get:protocol.OvkDecryptTRC20Parameters.events)
  return _internal_events(index);
}
inline std::string* OvkDecryptTRC20Parameters::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.OvkDecryptTRC20Parameters.events)
  return events_.Mutable(index);
}
inline void OvkDecryptTRC20Parameters::set_events(int index, const std::string& value) {
  events_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.OvkDecryptTRC20Parameters.events)
}
inline void OvkDecryptTRC20Parameters::set_events(int index, std::string&& value) {
  events_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.OvkDecryptTRC20Parameters.events)
}
inline void OvkDecryptTRC20Parameters::set_events(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  events_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.OvkDecryptTRC20Parameters.events)
}
inline void OvkDecryptTRC20Parameters::set_events(int index, const char* value, size_t size) {
  events_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.OvkDecryptTRC20Parameters.events)
}
inline std::string* OvkDecryptTRC20Parameters::_internal_add_events() {
  return events_.Add();
}
inline void OvkDecryptTRC20Parameters::add_events(const std::string& value) {
  events_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.OvkDecryptTRC20Parameters.events)
}
inline void OvkDecryptTRC20Parameters::add_events(std::string&& value) {
  events_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.OvkDecryptTRC20Parameters.events)
}
inline void OvkDecryptTRC20Parameters::add_events(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  events_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.OvkDecryptTRC20Parameters.events)
}
inline void OvkDecryptTRC20Parameters::add_events(const char* value, size_t size) {
  events_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.OvkDecryptTRC20Parameters.events)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OvkDecryptTRC20Parameters::events() const {
  // @@protoc_insertion_point(field_list:protocol.OvkDecryptTRC20Parameters.events)
  return events_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OvkDecryptTRC20Parameters::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:protocol.OvkDecryptTRC20Parameters.events)
  return &events_;
}

// -------------------------------------------------------------------

// DecryptNotesTRC20_NoteTx

// .protocol.Note note = 1;
inline bool DecryptNotesTRC20_NoteTx::_internal_has_note() const {
  return this != internal_default_instance() && note_ != nullptr;
}
inline bool DecryptNotesTRC20_NoteTx::has_note() const {
  return _internal_has_note();
}
inline void DecryptNotesTRC20_NoteTx::clear_note() {
  if (GetArenaForAllocation() == nullptr && note_ != nullptr) {
    delete note_;
  }
  note_ = nullptr;
}
inline const ::protocol::Note& DecryptNotesTRC20_NoteTx::_internal_note() const {
  const ::protocol::Note* p = note_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Note&>(
      ::protocol::_Note_default_instance_);
}
inline const ::protocol::Note& DecryptNotesTRC20_NoteTx::note() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotesTRC20.NoteTx.note)
  return _internal_note();
}
inline void DecryptNotesTRC20_NoteTx::unsafe_arena_set_allocated_note(
    ::protocol::Note* note) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(note_);
  }
  note_ = note;
  if (note) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.DecryptNotesTRC20.NoteTx.note)
}
inline ::protocol::Note* DecryptNotesTRC20_NoteTx::release_note() {
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Note* DecryptNotesTRC20_NoteTx::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_release:protocol.DecryptNotesTRC20.NoteTx.note)
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
  return temp;
}
inline ::protocol::Note* DecryptNotesTRC20_NoteTx::_internal_mutable_note() {
  
  if (note_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Note>(GetArenaForAllocation());
    note_ = p;
  }
  return note_;
}
inline ::protocol::Note* DecryptNotesTRC20_NoteTx::mutable_note() {
  ::protocol::Note* _msg = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:protocol.DecryptNotesTRC20.NoteTx.note)
  return _msg;
}
inline void DecryptNotesTRC20_NoteTx::set_allocated_note(::protocol::Note* note) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete note_;
  }
  if (note) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Note>::GetOwningArena(note);
    if (message_arena != submessage_arena) {
      note = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  note_ = note;
  // @@protoc_insertion_point(field_set_allocated:protocol.DecryptNotesTRC20.NoteTx.note)
}

// int64 position = 2;
inline void DecryptNotesTRC20_NoteTx::clear_position() {
  position_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DecryptNotesTRC20_NoteTx::_internal_position() const {
  return position_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DecryptNotesTRC20_NoteTx::position() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotesTRC20.NoteTx.position)
  return _internal_position();
}
inline void DecryptNotesTRC20_NoteTx::_internal_set_position(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  position_ = value;
}
inline void DecryptNotesTRC20_NoteTx::set_position(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:protocol.DecryptNotesTRC20.NoteTx.position)
}

// bool is_spent = 3;
inline void DecryptNotesTRC20_NoteTx::clear_is_spent() {
  is_spent_ = false;
}
inline bool DecryptNotesTRC20_NoteTx::_internal_is_spent() const {
  return is_spent_;
}
inline bool DecryptNotesTRC20_NoteTx::is_spent() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotesTRC20.NoteTx.is_spent)
  return _internal_is_spent();
}
inline void DecryptNotesTRC20_NoteTx::_internal_set_is_spent(bool value) {
  
  is_spent_ = value;
}
inline void DecryptNotesTRC20_NoteTx::set_is_spent(bool value) {
  _internal_set_is_spent(value);
  // @@protoc_insertion_point(field_set:protocol.DecryptNotesTRC20.NoteTx.is_spent)
}

// bytes txid = 4;
inline void DecryptNotesTRC20_NoteTx::clear_txid() {
  txid_.ClearToEmpty();
}
inline const std::string& DecryptNotesTRC20_NoteTx::txid() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotesTRC20.NoteTx.txid)
  return _internal_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DecryptNotesTRC20_NoteTx::set_txid(ArgT0&& arg0, ArgT... args) {
 
 txid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.DecryptNotesTRC20.NoteTx.txid)
}
inline std::string* DecryptNotesTRC20_NoteTx::mutable_txid() {
  std::string* _s = _internal_mutable_txid();
  // @@protoc_insertion_point(field_mutable:protocol.DecryptNotesTRC20.NoteTx.txid)
  return _s;
}
inline const std::string& DecryptNotesTRC20_NoteTx::_internal_txid() const {
  return txid_.Get();
}
inline void DecryptNotesTRC20_NoteTx::_internal_set_txid(const std::string& value) {
  
  txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DecryptNotesTRC20_NoteTx::_internal_mutable_txid() {
  
  return txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DecryptNotesTRC20_NoteTx::release_txid() {
  // @@protoc_insertion_point(field_release:protocol.DecryptNotesTRC20.NoteTx.txid)
  return txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DecryptNotesTRC20_NoteTx::set_allocated_txid(std::string* txid) {
  if (txid != nullptr) {
    
  } else {
    
  }
  txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), txid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.DecryptNotesTRC20.NoteTx.txid)
}

// int32 index = 5;
inline void DecryptNotesTRC20_NoteTx::clear_index() {
  index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DecryptNotesTRC20_NoteTx::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DecryptNotesTRC20_NoteTx::index() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotesTRC20.NoteTx.index)
  return _internal_index();
}
inline void DecryptNotesTRC20_NoteTx::_internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  index_ = value;
}
inline void DecryptNotesTRC20_NoteTx::set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:protocol.DecryptNotesTRC20.NoteTx.index)
}

// string to_amount = 6;
inline void DecryptNotesTRC20_NoteTx::clear_to_amount() {
  to_amount_.ClearToEmpty();
}
inline const std::string& DecryptNotesTRC20_NoteTx::to_amount() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotesTRC20.NoteTx.to_amount)
  return _internal_to_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DecryptNotesTRC20_NoteTx::set_to_amount(ArgT0&& arg0, ArgT... args) {
 
 to_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.DecryptNotesTRC20.NoteTx.to_amount)
}
inline std::string* DecryptNotesTRC20_NoteTx::mutable_to_amount() {
  std::string* _s = _internal_mutable_to_amount();
  // @@protoc_insertion_point(field_mutable:protocol.DecryptNotesTRC20.NoteTx.to_amount)
  return _s;
}
inline const std::string& DecryptNotesTRC20_NoteTx::_internal_to_amount() const {
  return to_amount_.Get();
}
inline void DecryptNotesTRC20_NoteTx::_internal_set_to_amount(const std::string& value) {
  
  to_amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DecryptNotesTRC20_NoteTx::_internal_mutable_to_amount() {
  
  return to_amount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DecryptNotesTRC20_NoteTx::release_to_amount() {
  // @@protoc_insertion_point(field_release:protocol.DecryptNotesTRC20.NoteTx.to_amount)
  return to_amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DecryptNotesTRC20_NoteTx::set_allocated_to_amount(std::string* to_amount) {
  if (to_amount != nullptr) {
    
  } else {
    
  }
  to_amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to_amount,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.DecryptNotesTRC20.NoteTx.to_amount)
}

// bytes transparent_to_address = 7;
inline void DecryptNotesTRC20_NoteTx::clear_transparent_to_address() {
  transparent_to_address_.ClearToEmpty();
}
inline const std::string& DecryptNotesTRC20_NoteTx::transparent_to_address() const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotesTRC20.NoteTx.transparent_to_address)
  return _internal_transparent_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DecryptNotesTRC20_NoteTx::set_transparent_to_address(ArgT0&& arg0, ArgT... args) {
 
 transparent_to_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.DecryptNotesTRC20.NoteTx.transparent_to_address)
}
inline std::string* DecryptNotesTRC20_NoteTx::mutable_transparent_to_address() {
  std::string* _s = _internal_mutable_transparent_to_address();
  // @@protoc_insertion_point(field_mutable:protocol.DecryptNotesTRC20.NoteTx.transparent_to_address)
  return _s;
}
inline const std::string& DecryptNotesTRC20_NoteTx::_internal_transparent_to_address() const {
  return transparent_to_address_.Get();
}
inline void DecryptNotesTRC20_NoteTx::_internal_set_transparent_to_address(const std::string& value) {
  
  transparent_to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DecryptNotesTRC20_NoteTx::_internal_mutable_transparent_to_address() {
  
  return transparent_to_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DecryptNotesTRC20_NoteTx::release_transparent_to_address() {
  // @@protoc_insertion_point(field_release:protocol.DecryptNotesTRC20.NoteTx.transparent_to_address)
  return transparent_to_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DecryptNotesTRC20_NoteTx::set_allocated_transparent_to_address(std::string* transparent_to_address) {
  if (transparent_to_address != nullptr) {
    
  } else {
    
  }
  transparent_to_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transparent_to_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.DecryptNotesTRC20.NoteTx.transparent_to_address)
}

// -------------------------------------------------------------------

// DecryptNotesTRC20

// repeated .protocol.DecryptNotesTRC20.NoteTx noteTxs = 1;
inline int DecryptNotesTRC20::_internal_notetxs_size() const {
  return notetxs_.size();
}
inline int DecryptNotesTRC20::notetxs_size() const {
  return _internal_notetxs_size();
}
inline void DecryptNotesTRC20::clear_notetxs() {
  notetxs_.Clear();
}
inline ::protocol::DecryptNotesTRC20_NoteTx* DecryptNotesTRC20::mutable_notetxs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.DecryptNotesTRC20.noteTxs)
  return notetxs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotesTRC20_NoteTx >*
DecryptNotesTRC20::mutable_notetxs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.DecryptNotesTRC20.noteTxs)
  return &notetxs_;
}
inline const ::protocol::DecryptNotesTRC20_NoteTx& DecryptNotesTRC20::_internal_notetxs(int index) const {
  return notetxs_.Get(index);
}
inline const ::protocol::DecryptNotesTRC20_NoteTx& DecryptNotesTRC20::notetxs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.DecryptNotesTRC20.noteTxs)
  return _internal_notetxs(index);
}
inline ::protocol::DecryptNotesTRC20_NoteTx* DecryptNotesTRC20::_internal_add_notetxs() {
  return notetxs_.Add();
}
inline ::protocol::DecryptNotesTRC20_NoteTx* DecryptNotesTRC20::add_notetxs() {
  ::protocol::DecryptNotesTRC20_NoteTx* _add = _internal_add_notetxs();
  // @@protoc_insertion_point(field_add:protocol.DecryptNotesTRC20.noteTxs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::DecryptNotesTRC20_NoteTx >&
DecryptNotesTRC20::notetxs() const {
  // @@protoc_insertion_point(field_list:protocol.DecryptNotesTRC20.noteTxs)
  return notetxs_;
}

// -------------------------------------------------------------------

// NfTRC20Parameters

// .protocol.Note note = 1;
inline bool NfTRC20Parameters::_internal_has_note() const {
  return this != internal_default_instance() && note_ != nullptr;
}
inline bool NfTRC20Parameters::has_note() const {
  return _internal_has_note();
}
inline void NfTRC20Parameters::clear_note() {
  if (GetArenaForAllocation() == nullptr && note_ != nullptr) {
    delete note_;
  }
  note_ = nullptr;
}
inline const ::protocol::Note& NfTRC20Parameters::_internal_note() const {
  const ::protocol::Note* p = note_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Note&>(
      ::protocol::_Note_default_instance_);
}
inline const ::protocol::Note& NfTRC20Parameters::note() const {
  // @@protoc_insertion_point(field_get:protocol.NfTRC20Parameters.note)
  return _internal_note();
}
inline void NfTRC20Parameters::unsafe_arena_set_allocated_note(
    ::protocol::Note* note) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(note_);
  }
  note_ = note;
  if (note) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.NfTRC20Parameters.note)
}
inline ::protocol::Note* NfTRC20Parameters::release_note() {
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Note* NfTRC20Parameters::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_release:protocol.NfTRC20Parameters.note)
  
  ::protocol::Note* temp = note_;
  note_ = nullptr;
  return temp;
}
inline ::protocol::Note* NfTRC20Parameters::_internal_mutable_note() {
  
  if (note_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Note>(GetArenaForAllocation());
    note_ = p;
  }
  return note_;
}
inline ::protocol::Note* NfTRC20Parameters::mutable_note() {
  ::protocol::Note* _msg = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:protocol.NfTRC20Parameters.note)
  return _msg;
}
inline void NfTRC20Parameters::set_allocated_note(::protocol::Note* note) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete note_;
  }
  if (note) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Note>::GetOwningArena(note);
    if (message_arena != submessage_arena) {
      note = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, note, submessage_arena);
    }
    
  } else {
    
  }
  note_ = note;
  // @@protoc_insertion_point(field_set_allocated:protocol.NfTRC20Parameters.note)
}

// bytes ak = 2;
inline void NfTRC20Parameters::clear_ak() {
  ak_.ClearToEmpty();
}
inline const std::string& NfTRC20Parameters::ak() const {
  // @@protoc_insertion_point(field_get:protocol.NfTRC20Parameters.ak)
  return _internal_ak();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NfTRC20Parameters::set_ak(ArgT0&& arg0, ArgT... args) {
 
 ak_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NfTRC20Parameters.ak)
}
inline std::string* NfTRC20Parameters::mutable_ak() {
  std::string* _s = _internal_mutable_ak();
  // @@protoc_insertion_point(field_mutable:protocol.NfTRC20Parameters.ak)
  return _s;
}
inline const std::string& NfTRC20Parameters::_internal_ak() const {
  return ak_.Get();
}
inline void NfTRC20Parameters::_internal_set_ak(const std::string& value) {
  
  ak_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NfTRC20Parameters::_internal_mutable_ak() {
  
  return ak_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NfTRC20Parameters::release_ak() {
  // @@protoc_insertion_point(field_release:protocol.NfTRC20Parameters.ak)
  return ak_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NfTRC20Parameters::set_allocated_ak(std::string* ak) {
  if (ak != nullptr) {
    
  } else {
    
  }
  ak_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ak,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.NfTRC20Parameters.ak)
}

// bytes nk = 3;
inline void NfTRC20Parameters::clear_nk() {
  nk_.ClearToEmpty();
}
inline const std::string& NfTRC20Parameters::nk() const {
  // @@protoc_insertion_point(field_get:protocol.NfTRC20Parameters.nk)
  return _internal_nk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NfTRC20Parameters::set_nk(ArgT0&& arg0, ArgT... args) {
 
 nk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NfTRC20Parameters.nk)
}
inline std::string* NfTRC20Parameters::mutable_nk() {
  std::string* _s = _internal_mutable_nk();
  // @@protoc_insertion_point(field_mutable:protocol.NfTRC20Parameters.nk)
  return _s;
}
inline const std::string& NfTRC20Parameters::_internal_nk() const {
  return nk_.Get();
}
inline void NfTRC20Parameters::_internal_set_nk(const std::string& value) {
  
  nk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NfTRC20Parameters::_internal_mutable_nk() {
  
  return nk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NfTRC20Parameters::release_nk() {
  // @@protoc_insertion_point(field_release:protocol.NfTRC20Parameters.nk)
  return nk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NfTRC20Parameters::set_allocated_nk(std::string* nk) {
  if (nk != nullptr) {
    
  } else {
    
  }
  nk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.NfTRC20Parameters.nk)
}

// int64 position = 4;
inline void NfTRC20Parameters::clear_position() {
  position_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NfTRC20Parameters::_internal_position() const {
  return position_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NfTRC20Parameters::position() const {
  // @@protoc_insertion_point(field_get:protocol.NfTRC20Parameters.position)
  return _internal_position();
}
inline void NfTRC20Parameters::_internal_set_position(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  position_ = value;
}
inline void NfTRC20Parameters::set_position(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:protocol.NfTRC20Parameters.position)
}

// bytes shielded_TRC20_contract_address = 5;
inline void NfTRC20Parameters::clear_shielded_trc20_contract_address() {
  shielded_trc20_contract_address_.ClearToEmpty();
}
inline const std::string& NfTRC20Parameters::shielded_trc20_contract_address() const {
  // @@protoc_insertion_point(field_get:protocol.NfTRC20Parameters.shielded_TRC20_contract_address)
  return _internal_shielded_trc20_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NfTRC20Parameters::set_shielded_trc20_contract_address(ArgT0&& arg0, ArgT... args) {
 
 shielded_trc20_contract_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NfTRC20Parameters.shielded_TRC20_contract_address)
}
inline std::string* NfTRC20Parameters::mutable_shielded_trc20_contract_address() {
  std::string* _s = _internal_mutable_shielded_trc20_contract_address();
  // @@protoc_insertion_point(field_mutable:protocol.NfTRC20Parameters.shielded_TRC20_contract_address)
  return _s;
}
inline const std::string& NfTRC20Parameters::_internal_shielded_trc20_contract_address() const {
  return shielded_trc20_contract_address_.Get();
}
inline void NfTRC20Parameters::_internal_set_shielded_trc20_contract_address(const std::string& value) {
  
  shielded_trc20_contract_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NfTRC20Parameters::_internal_mutable_shielded_trc20_contract_address() {
  
  return shielded_trc20_contract_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NfTRC20Parameters::release_shielded_trc20_contract_address() {
  // @@protoc_insertion_point(field_release:protocol.NfTRC20Parameters.shielded_TRC20_contract_address)
  return shielded_trc20_contract_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NfTRC20Parameters::set_allocated_shielded_trc20_contract_address(std::string* shielded_trc20_contract_address) {
  if (shielded_trc20_contract_address != nullptr) {
    
  } else {
    
  }
  shielded_trc20_contract_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shielded_trc20_contract_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.NfTRC20Parameters.shielded_TRC20_contract_address)
}

// -------------------------------------------------------------------

// NullifierResult

// bool is_spent = 1;
inline void NullifierResult::clear_is_spent() {
  is_spent_ = false;
}
inline bool NullifierResult::_internal_is_spent() const {
  return is_spent_;
}
inline bool NullifierResult::is_spent() const {
  // @@protoc_insertion_point(field_get:protocol.NullifierResult.is_spent)
  return _internal_is_spent();
}
inline void NullifierResult::_internal_set_is_spent(bool value) {
  
  is_spent_ = value;
}
inline void NullifierResult::set_is_spent(bool value) {
  _internal_set_is_spent(value);
  // @@protoc_insertion_point(field_set:protocol.NullifierResult.is_spent)
}

// -------------------------------------------------------------------

// ShieldedTRC20TriggerContractParameters

// .protocol.ShieldedTRC20Parameters shielded_TRC20_Parameters = 1;
inline bool ShieldedTRC20TriggerContractParameters::_internal_has_shielded_trc20_parameters() const {
  return this != internal_default_instance() && shielded_trc20_parameters_ != nullptr;
}
inline bool ShieldedTRC20TriggerContractParameters::has_shielded_trc20_parameters() const {
  return _internal_has_shielded_trc20_parameters();
}
inline void ShieldedTRC20TriggerContractParameters::clear_shielded_trc20_parameters() {
  if (GetArenaForAllocation() == nullptr && shielded_trc20_parameters_ != nullptr) {
    delete shielded_trc20_parameters_;
  }
  shielded_trc20_parameters_ = nullptr;
}
inline const ::protocol::ShieldedTRC20Parameters& ShieldedTRC20TriggerContractParameters::_internal_shielded_trc20_parameters() const {
  const ::protocol::ShieldedTRC20Parameters* p = shielded_trc20_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::ShieldedTRC20Parameters&>(
      ::protocol::_ShieldedTRC20Parameters_default_instance_);
}
inline const ::protocol::ShieldedTRC20Parameters& ShieldedTRC20TriggerContractParameters::shielded_trc20_parameters() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTRC20TriggerContractParameters.shielded_TRC20_Parameters)
  return _internal_shielded_trc20_parameters();
}
inline void ShieldedTRC20TriggerContractParameters::unsafe_arena_set_allocated_shielded_trc20_parameters(
    ::protocol::ShieldedTRC20Parameters* shielded_trc20_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shielded_trc20_parameters_);
  }
  shielded_trc20_parameters_ = shielded_trc20_parameters;
  if (shielded_trc20_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.ShieldedTRC20TriggerContractParameters.shielded_TRC20_Parameters)
}
inline ::protocol::ShieldedTRC20Parameters* ShieldedTRC20TriggerContractParameters::release_shielded_trc20_parameters() {
  
  ::protocol::ShieldedTRC20Parameters* temp = shielded_trc20_parameters_;
  shielded_trc20_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::ShieldedTRC20Parameters* ShieldedTRC20TriggerContractParameters::unsafe_arena_release_shielded_trc20_parameters() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedTRC20TriggerContractParameters.shielded_TRC20_Parameters)
  
  ::protocol::ShieldedTRC20Parameters* temp = shielded_trc20_parameters_;
  shielded_trc20_parameters_ = nullptr;
  return temp;
}
inline ::protocol::ShieldedTRC20Parameters* ShieldedTRC20TriggerContractParameters::_internal_mutable_shielded_trc20_parameters() {
  
  if (shielded_trc20_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::ShieldedTRC20Parameters>(GetArenaForAllocation());
    shielded_trc20_parameters_ = p;
  }
  return shielded_trc20_parameters_;
}
inline ::protocol::ShieldedTRC20Parameters* ShieldedTRC20TriggerContractParameters::mutable_shielded_trc20_parameters() {
  ::protocol::ShieldedTRC20Parameters* _msg = _internal_mutable_shielded_trc20_parameters();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTRC20TriggerContractParameters.shielded_TRC20_Parameters)
  return _msg;
}
inline void ShieldedTRC20TriggerContractParameters::set_allocated_shielded_trc20_parameters(::protocol::ShieldedTRC20Parameters* shielded_trc20_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete shielded_trc20_parameters_;
  }
  if (shielded_trc20_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::ShieldedTRC20Parameters>::GetOwningArena(shielded_trc20_parameters);
    if (message_arena != submessage_arena) {
      shielded_trc20_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shielded_trc20_parameters, submessage_arena);
    }
    
  } else {
    
  }
  shielded_trc20_parameters_ = shielded_trc20_parameters;
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedTRC20TriggerContractParameters.shielded_TRC20_Parameters)
}

// repeated .protocol.BytesMessage spend_authority_signature = 2;
inline int ShieldedTRC20TriggerContractParameters::_internal_spend_authority_signature_size() const {
  return spend_authority_signature_.size();
}
inline int ShieldedTRC20TriggerContractParameters::spend_authority_signature_size() const {
  return _internal_spend_authority_signature_size();
}
inline void ShieldedTRC20TriggerContractParameters::clear_spend_authority_signature() {
  spend_authority_signature_.Clear();
}
inline ::protocol::BytesMessage* ShieldedTRC20TriggerContractParameters::mutable_spend_authority_signature(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTRC20TriggerContractParameters.spend_authority_signature)
  return spend_authority_signature_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BytesMessage >*
ShieldedTRC20TriggerContractParameters::mutable_spend_authority_signature() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ShieldedTRC20TriggerContractParameters.spend_authority_signature)
  return &spend_authority_signature_;
}
inline const ::protocol::BytesMessage& ShieldedTRC20TriggerContractParameters::_internal_spend_authority_signature(int index) const {
  return spend_authority_signature_.Get(index);
}
inline const ::protocol::BytesMessage& ShieldedTRC20TriggerContractParameters::spend_authority_signature(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTRC20TriggerContractParameters.spend_authority_signature)
  return _internal_spend_authority_signature(index);
}
inline ::protocol::BytesMessage* ShieldedTRC20TriggerContractParameters::_internal_add_spend_authority_signature() {
  return spend_authority_signature_.Add();
}
inline ::protocol::BytesMessage* ShieldedTRC20TriggerContractParameters::add_spend_authority_signature() {
  ::protocol::BytesMessage* _add = _internal_add_spend_authority_signature();
  // @@protoc_insertion_point(field_add:protocol.ShieldedTRC20TriggerContractParameters.spend_authority_signature)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BytesMessage >&
ShieldedTRC20TriggerContractParameters::spend_authority_signature() const {
  // @@protoc_insertion_point(field_list:protocol.ShieldedTRC20TriggerContractParameters.spend_authority_signature)
  return spend_authority_signature_;
}

// string amount = 3;
inline void ShieldedTRC20TriggerContractParameters::clear_amount() {
  amount_.ClearToEmpty();
}
inline const std::string& ShieldedTRC20TriggerContractParameters::amount() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTRC20TriggerContractParameters.amount)
  return _internal_amount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedTRC20TriggerContractParameters::set_amount(ArgT0&& arg0, ArgT... args) {
 
 amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedTRC20TriggerContractParameters.amount)
}
inline std::string* ShieldedTRC20TriggerContractParameters::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTRC20TriggerContractParameters.amount)
  return _s;
}
inline const std::string& ShieldedTRC20TriggerContractParameters::_internal_amount() const {
  return amount_.Get();
}
inline void ShieldedTRC20TriggerContractParameters::_internal_set_amount(const std::string& value) {
  
  amount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedTRC20TriggerContractParameters::_internal_mutable_amount() {
  
  return amount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedTRC20TriggerContractParameters::release_amount() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedTRC20TriggerContractParameters.amount)
  return amount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedTRC20TriggerContractParameters::set_allocated_amount(std::string* amount) {
  if (amount != nullptr) {
    
  } else {
    
  }
  amount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amount,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedTRC20TriggerContractParameters.amount)
}

// bytes transparent_to_address = 4;
inline void ShieldedTRC20TriggerContractParameters::clear_transparent_to_address() {
  transparent_to_address_.ClearToEmpty();
}
inline const std::string& ShieldedTRC20TriggerContractParameters::transparent_to_address() const {
  // @@protoc_insertion_point(field_get:protocol.ShieldedTRC20TriggerContractParameters.transparent_to_address)
  return _internal_transparent_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShieldedTRC20TriggerContractParameters::set_transparent_to_address(ArgT0&& arg0, ArgT... args) {
 
 transparent_to_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ShieldedTRC20TriggerContractParameters.transparent_to_address)
}
inline std::string* ShieldedTRC20TriggerContractParameters::mutable_transparent_to_address() {
  std::string* _s = _internal_mutable_transparent_to_address();
  // @@protoc_insertion_point(field_mutable:protocol.ShieldedTRC20TriggerContractParameters.transparent_to_address)
  return _s;
}
inline const std::string& ShieldedTRC20TriggerContractParameters::_internal_transparent_to_address() const {
  return transparent_to_address_.Get();
}
inline void ShieldedTRC20TriggerContractParameters::_internal_set_transparent_to_address(const std::string& value) {
  
  transparent_to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShieldedTRC20TriggerContractParameters::_internal_mutable_transparent_to_address() {
  
  return transparent_to_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShieldedTRC20TriggerContractParameters::release_transparent_to_address() {
  // @@protoc_insertion_point(field_release:protocol.ShieldedTRC20TriggerContractParameters.transparent_to_address)
  return transparent_to_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShieldedTRC20TriggerContractParameters::set_allocated_transparent_to_address(std::string* transparent_to_address) {
  if (transparent_to_address != nullptr) {
    
  } else {
    
  }
  transparent_to_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transparent_to_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:protocol.ShieldedTRC20TriggerContractParameters.transparent_to_address)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::protocol::Return_response_code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Return_response_code>() {
  return ::protocol::Return_response_code_descriptor();
}
template <> struct is_proto_enum< ::protocol::TransactionSignWeight_Result_response_code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TransactionSignWeight_Result_response_code>() {
  return ::protocol::TransactionSignWeight_Result_response_code_descriptor();
}
template <> struct is_proto_enum< ::protocol::TransactionApprovedList_Result_response_code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TransactionApprovedList_Result_response_code>() {
  return ::protocol::TransactionApprovedList_Result_response_code_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_api_2fapi_2eproto
