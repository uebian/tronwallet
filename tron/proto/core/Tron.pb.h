// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core/Tron.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_core_2fTron_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_core_2fTron_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "core/Discover.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_core_2fTron_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_core_2fTron_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[92]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_core_2fTron_2eproto;
namespace protocol {
class Account;
struct AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class AccountAsset;
struct AccountAssetDefaultTypeInternal;
extern AccountAssetDefaultTypeInternal _AccountAsset_default_instance_;
class AccountAsset_AssetEntry_DoNotUse;
struct AccountAsset_AssetEntry_DoNotUseDefaultTypeInternal;
extern AccountAsset_AssetEntry_DoNotUseDefaultTypeInternal _AccountAsset_AssetEntry_DoNotUse_default_instance_;
class AccountAsset_AssetV2Entry_DoNotUse;
struct AccountAsset_AssetV2Entry_DoNotUseDefaultTypeInternal;
extern AccountAsset_AssetV2Entry_DoNotUseDefaultTypeInternal _AccountAsset_AssetV2Entry_DoNotUse_default_instance_;
class AccountAsset_FreeAssetNetUsageEntry_DoNotUse;
struct AccountAsset_FreeAssetNetUsageEntry_DoNotUseDefaultTypeInternal;
extern AccountAsset_FreeAssetNetUsageEntry_DoNotUseDefaultTypeInternal _AccountAsset_FreeAssetNetUsageEntry_DoNotUse_default_instance_;
class AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse;
struct AccountAsset_FreeAssetNetUsageV2Entry_DoNotUseDefaultTypeInternal;
extern AccountAsset_FreeAssetNetUsageV2Entry_DoNotUseDefaultTypeInternal _AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse_default_instance_;
class AccountAsset_Frozen;
struct AccountAsset_FrozenDefaultTypeInternal;
extern AccountAsset_FrozenDefaultTypeInternal _AccountAsset_Frozen_default_instance_;
class AccountAsset_LatestAssetOperationTimeEntry_DoNotUse;
struct AccountAsset_LatestAssetOperationTimeEntry_DoNotUseDefaultTypeInternal;
extern AccountAsset_LatestAssetOperationTimeEntry_DoNotUseDefaultTypeInternal _AccountAsset_LatestAssetOperationTimeEntry_DoNotUse_default_instance_;
class AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse;
struct AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUseDefaultTypeInternal;
extern AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUseDefaultTypeInternal _AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse_default_instance_;
class AccountId;
struct AccountIdDefaultTypeInternal;
extern AccountIdDefaultTypeInternal _AccountId_default_instance_;
class Account_AccountResource;
struct Account_AccountResourceDefaultTypeInternal;
extern Account_AccountResourceDefaultTypeInternal _Account_AccountResource_default_instance_;
class Account_AssetEntry_DoNotUse;
struct Account_AssetEntry_DoNotUseDefaultTypeInternal;
extern Account_AssetEntry_DoNotUseDefaultTypeInternal _Account_AssetEntry_DoNotUse_default_instance_;
class Account_AssetV2Entry_DoNotUse;
struct Account_AssetV2Entry_DoNotUseDefaultTypeInternal;
extern Account_AssetV2Entry_DoNotUseDefaultTypeInternal _Account_AssetV2Entry_DoNotUse_default_instance_;
class Account_FreeAssetNetUsageEntry_DoNotUse;
struct Account_FreeAssetNetUsageEntry_DoNotUseDefaultTypeInternal;
extern Account_FreeAssetNetUsageEntry_DoNotUseDefaultTypeInternal _Account_FreeAssetNetUsageEntry_DoNotUse_default_instance_;
class Account_FreeAssetNetUsageV2Entry_DoNotUse;
struct Account_FreeAssetNetUsageV2Entry_DoNotUseDefaultTypeInternal;
extern Account_FreeAssetNetUsageV2Entry_DoNotUseDefaultTypeInternal _Account_FreeAssetNetUsageV2Entry_DoNotUse_default_instance_;
class Account_Frozen;
struct Account_FrozenDefaultTypeInternal;
extern Account_FrozenDefaultTypeInternal _Account_Frozen_default_instance_;
class Account_LatestAssetOperationTimeEntry_DoNotUse;
struct Account_LatestAssetOperationTimeEntry_DoNotUseDefaultTypeInternal;
extern Account_LatestAssetOperationTimeEntry_DoNotUseDefaultTypeInternal _Account_LatestAssetOperationTimeEntry_DoNotUse_default_instance_;
class Account_LatestAssetOperationTimeV2Entry_DoNotUse;
struct Account_LatestAssetOperationTimeV2Entry_DoNotUseDefaultTypeInternal;
extern Account_LatestAssetOperationTimeV2Entry_DoNotUseDefaultTypeInternal _Account_LatestAssetOperationTimeV2Entry_DoNotUse_default_instance_;
class Block;
struct BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class BlockHeader;
struct BlockHeaderDefaultTypeInternal;
extern BlockHeaderDefaultTypeInternal _BlockHeader_default_instance_;
class BlockHeader_raw;
struct BlockHeader_rawDefaultTypeInternal;
extern BlockHeader_rawDefaultTypeInternal _BlockHeader_raw_default_instance_;
class BlockInventory;
struct BlockInventoryDefaultTypeInternal;
extern BlockInventoryDefaultTypeInternal _BlockInventory_default_instance_;
class BlockInventory_BlockId;
struct BlockInventory_BlockIdDefaultTypeInternal;
extern BlockInventory_BlockIdDefaultTypeInternal _BlockInventory_BlockId_default_instance_;
class ChainInventory;
struct ChainInventoryDefaultTypeInternal;
extern ChainInventoryDefaultTypeInternal _ChainInventory_default_instance_;
class ChainInventory_BlockId;
struct ChainInventory_BlockIdDefaultTypeInternal;
extern ChainInventory_BlockIdDefaultTypeInternal _ChainInventory_BlockId_default_instance_;
class ChainParameters;
struct ChainParametersDefaultTypeInternal;
extern ChainParametersDefaultTypeInternal _ChainParameters_default_instance_;
class ChainParameters_ChainParameter;
struct ChainParameters_ChainParameterDefaultTypeInternal;
extern ChainParameters_ChainParameterDefaultTypeInternal _ChainParameters_ChainParameter_default_instance_;
class DelegatedResource;
struct DelegatedResourceDefaultTypeInternal;
extern DelegatedResourceDefaultTypeInternal _DelegatedResource_default_instance_;
class DelegatedResourceAccountIndex;
struct DelegatedResourceAccountIndexDefaultTypeInternal;
extern DelegatedResourceAccountIndexDefaultTypeInternal _DelegatedResourceAccountIndex_default_instance_;
class DisconnectMessage;
struct DisconnectMessageDefaultTypeInternal;
extern DisconnectMessageDefaultTypeInternal _DisconnectMessage_default_instance_;
class DynamicProperties;
struct DynamicPropertiesDefaultTypeInternal;
extern DynamicPropertiesDefaultTypeInternal _DynamicProperties_default_instance_;
class Exchange;
struct ExchangeDefaultTypeInternal;
extern ExchangeDefaultTypeInternal _Exchange_default_instance_;
class HelloMessage;
struct HelloMessageDefaultTypeInternal;
extern HelloMessageDefaultTypeInternal _HelloMessage_default_instance_;
class HelloMessage_BlockId;
struct HelloMessage_BlockIdDefaultTypeInternal;
extern HelloMessage_BlockIdDefaultTypeInternal _HelloMessage_BlockId_default_instance_;
class InternalTransaction;
struct InternalTransactionDefaultTypeInternal;
extern InternalTransactionDefaultTypeInternal _InternalTransaction_default_instance_;
class InternalTransaction_CallValueInfo;
struct InternalTransaction_CallValueInfoDefaultTypeInternal;
extern InternalTransaction_CallValueInfoDefaultTypeInternal _InternalTransaction_CallValueInfo_default_instance_;
class Inventory;
struct InventoryDefaultTypeInternal;
extern InventoryDefaultTypeInternal _Inventory_default_instance_;
class Items;
struct ItemsDefaultTypeInternal;
extern ItemsDefaultTypeInternal _Items_default_instance_;
class Key;
struct KeyDefaultTypeInternal;
extern KeyDefaultTypeInternal _Key_default_instance_;
class MarketAccountOrder;
struct MarketAccountOrderDefaultTypeInternal;
extern MarketAccountOrderDefaultTypeInternal _MarketAccountOrder_default_instance_;
class MarketOrder;
struct MarketOrderDefaultTypeInternal;
extern MarketOrderDefaultTypeInternal _MarketOrder_default_instance_;
class MarketOrderDetail;
struct MarketOrderDetailDefaultTypeInternal;
extern MarketOrderDetailDefaultTypeInternal _MarketOrderDetail_default_instance_;
class MarketOrderIdList;
struct MarketOrderIdListDefaultTypeInternal;
extern MarketOrderIdListDefaultTypeInternal _MarketOrderIdList_default_instance_;
class MarketOrderList;
struct MarketOrderListDefaultTypeInternal;
extern MarketOrderListDefaultTypeInternal _MarketOrderList_default_instance_;
class MarketOrderPair;
struct MarketOrderPairDefaultTypeInternal;
extern MarketOrderPairDefaultTypeInternal _MarketOrderPair_default_instance_;
class MarketOrderPairList;
struct MarketOrderPairListDefaultTypeInternal;
extern MarketOrderPairListDefaultTypeInternal _MarketOrderPairList_default_instance_;
class MarketPrice;
struct MarketPriceDefaultTypeInternal;
extern MarketPriceDefaultTypeInternal _MarketPrice_default_instance_;
class MarketPriceList;
struct MarketPriceListDefaultTypeInternal;
extern MarketPriceListDefaultTypeInternal _MarketPriceList_default_instance_;
class MetricsInfo;
struct MetricsInfoDefaultTypeInternal;
extern MetricsInfoDefaultTypeInternal _MetricsInfo_default_instance_;
class MetricsInfo_BlockChainInfo;
struct MetricsInfo_BlockChainInfoDefaultTypeInternal;
extern MetricsInfo_BlockChainInfoDefaultTypeInternal _MetricsInfo_BlockChainInfo_default_instance_;
class MetricsInfo_BlockChainInfo_DupWitness;
struct MetricsInfo_BlockChainInfo_DupWitnessDefaultTypeInternal;
extern MetricsInfo_BlockChainInfo_DupWitnessDefaultTypeInternal _MetricsInfo_BlockChainInfo_DupWitness_default_instance_;
class MetricsInfo_BlockChainInfo_Witness;
struct MetricsInfo_BlockChainInfo_WitnessDefaultTypeInternal;
extern MetricsInfo_BlockChainInfo_WitnessDefaultTypeInternal _MetricsInfo_BlockChainInfo_Witness_default_instance_;
class MetricsInfo_NetInfo;
struct MetricsInfo_NetInfoDefaultTypeInternal;
extern MetricsInfo_NetInfoDefaultTypeInternal _MetricsInfo_NetInfo_default_instance_;
class MetricsInfo_NetInfo_ApiInfo;
struct MetricsInfo_NetInfo_ApiInfoDefaultTypeInternal;
extern MetricsInfo_NetInfo_ApiInfoDefaultTypeInternal _MetricsInfo_NetInfo_ApiInfo_default_instance_;
class MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo;
struct MetricsInfo_NetInfo_ApiInfo_ApiDetailInfoDefaultTypeInternal;
extern MetricsInfo_NetInfo_ApiInfo_ApiDetailInfoDefaultTypeInternal _MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo_default_instance_;
class MetricsInfo_NetInfo_DisconnectionDetailInfo;
struct MetricsInfo_NetInfo_DisconnectionDetailInfoDefaultTypeInternal;
extern MetricsInfo_NetInfo_DisconnectionDetailInfoDefaultTypeInternal _MetricsInfo_NetInfo_DisconnectionDetailInfo_default_instance_;
class MetricsInfo_NetInfo_LatencyInfo;
struct MetricsInfo_NetInfo_LatencyInfoDefaultTypeInternal;
extern MetricsInfo_NetInfo_LatencyInfoDefaultTypeInternal _MetricsInfo_NetInfo_LatencyInfo_default_instance_;
class MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo;
struct MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfoDefaultTypeInternal;
extern MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfoDefaultTypeInternal _MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo_default_instance_;
class MetricsInfo_NodeInfo;
struct MetricsInfo_NodeInfoDefaultTypeInternal;
extern MetricsInfo_NodeInfoDefaultTypeInternal _MetricsInfo_NodeInfo_default_instance_;
class MetricsInfo_RateInfo;
struct MetricsInfo_RateInfoDefaultTypeInternal;
extern MetricsInfo_RateInfoDefaultTypeInternal _MetricsInfo_RateInfo_default_instance_;
class NodeInfo;
struct NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class NodeInfo_CheatWitnessInfoMapEntry_DoNotUse;
struct NodeInfo_CheatWitnessInfoMapEntry_DoNotUseDefaultTypeInternal;
extern NodeInfo_CheatWitnessInfoMapEntry_DoNotUseDefaultTypeInternal _NodeInfo_CheatWitnessInfoMapEntry_DoNotUse_default_instance_;
class NodeInfo_ConfigNodeInfo;
struct NodeInfo_ConfigNodeInfoDefaultTypeInternal;
extern NodeInfo_ConfigNodeInfoDefaultTypeInternal _NodeInfo_ConfigNodeInfo_default_instance_;
class NodeInfo_MachineInfo;
struct NodeInfo_MachineInfoDefaultTypeInternal;
extern NodeInfo_MachineInfoDefaultTypeInternal _NodeInfo_MachineInfo_default_instance_;
class NodeInfo_MachineInfo_DeadLockThreadInfo;
struct NodeInfo_MachineInfo_DeadLockThreadInfoDefaultTypeInternal;
extern NodeInfo_MachineInfo_DeadLockThreadInfoDefaultTypeInternal _NodeInfo_MachineInfo_DeadLockThreadInfo_default_instance_;
class NodeInfo_MachineInfo_MemoryDescInfo;
struct NodeInfo_MachineInfo_MemoryDescInfoDefaultTypeInternal;
extern NodeInfo_MachineInfo_MemoryDescInfoDefaultTypeInternal _NodeInfo_MachineInfo_MemoryDescInfo_default_instance_;
class NodeInfo_PeerInfo;
struct NodeInfo_PeerInfoDefaultTypeInternal;
extern NodeInfo_PeerInfoDefaultTypeInternal _NodeInfo_PeerInfo_default_instance_;
class PBFTCommitResult;
struct PBFTCommitResultDefaultTypeInternal;
extern PBFTCommitResultDefaultTypeInternal _PBFTCommitResult_default_instance_;
class PBFTMessage;
struct PBFTMessageDefaultTypeInternal;
extern PBFTMessageDefaultTypeInternal _PBFTMessage_default_instance_;
class PBFTMessage_Raw;
struct PBFTMessage_RawDefaultTypeInternal;
extern PBFTMessage_RawDefaultTypeInternal _PBFTMessage_Raw_default_instance_;
class Permission;
struct PermissionDefaultTypeInternal;
extern PermissionDefaultTypeInternal _Permission_default_instance_;
class Proposal;
struct ProposalDefaultTypeInternal;
extern ProposalDefaultTypeInternal _Proposal_default_instance_;
class Proposal_ParametersEntry_DoNotUse;
struct Proposal_ParametersEntry_DoNotUseDefaultTypeInternal;
extern Proposal_ParametersEntry_DoNotUseDefaultTypeInternal _Proposal_ParametersEntry_DoNotUse_default_instance_;
class ResourceReceipt;
struct ResourceReceiptDefaultTypeInternal;
extern ResourceReceiptDefaultTypeInternal _ResourceReceipt_default_instance_;
class SRL;
struct SRLDefaultTypeInternal;
extern SRLDefaultTypeInternal _SRL_default_instance_;
class TXInput;
struct TXInputDefaultTypeInternal;
extern TXInputDefaultTypeInternal _TXInput_default_instance_;
class TXInput_raw;
struct TXInput_rawDefaultTypeInternal;
extern TXInput_rawDefaultTypeInternal _TXInput_raw_default_instance_;
class TXOutput;
struct TXOutputDefaultTypeInternal;
extern TXOutputDefaultTypeInternal _TXOutput_default_instance_;
class TXOutputs;
struct TXOutputsDefaultTypeInternal;
extern TXOutputsDefaultTypeInternal _TXOutputs_default_instance_;
class Transaction;
struct TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransactionInfo;
struct TransactionInfoDefaultTypeInternal;
extern TransactionInfoDefaultTypeInternal _TransactionInfo_default_instance_;
class TransactionInfo_Log;
struct TransactionInfo_LogDefaultTypeInternal;
extern TransactionInfo_LogDefaultTypeInternal _TransactionInfo_Log_default_instance_;
class TransactionRet;
struct TransactionRetDefaultTypeInternal;
extern TransactionRetDefaultTypeInternal _TransactionRet_default_instance_;
class TransactionSign;
struct TransactionSignDefaultTypeInternal;
extern TransactionSignDefaultTypeInternal _TransactionSign_default_instance_;
class Transaction_Contract;
struct Transaction_ContractDefaultTypeInternal;
extern Transaction_ContractDefaultTypeInternal _Transaction_Contract_default_instance_;
class Transaction_Result;
struct Transaction_ResultDefaultTypeInternal;
extern Transaction_ResultDefaultTypeInternal _Transaction_Result_default_instance_;
class Transaction_raw;
struct Transaction_rawDefaultTypeInternal;
extern Transaction_rawDefaultTypeInternal _Transaction_raw_default_instance_;
class Transactions;
struct TransactionsDefaultTypeInternal;
extern TransactionsDefaultTypeInternal _Transactions_default_instance_;
class Vote;
struct VoteDefaultTypeInternal;
extern VoteDefaultTypeInternal _Vote_default_instance_;
class Votes;
struct VotesDefaultTypeInternal;
extern VotesDefaultTypeInternal _Votes_default_instance_;
class Witness;
struct WitnessDefaultTypeInternal;
extern WitnessDefaultTypeInternal _Witness_default_instance_;
class authority;
struct authorityDefaultTypeInternal;
extern authorityDefaultTypeInternal _authority_default_instance_;
}  // namespace protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::protocol::Account* Arena::CreateMaybeMessage<::protocol::Account>(Arena*);
template<> ::protocol::AccountAsset* Arena::CreateMaybeMessage<::protocol::AccountAsset>(Arena*);
template<> ::protocol::AccountAsset_AssetEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::AccountAsset_AssetEntry_DoNotUse>(Arena*);
template<> ::protocol::AccountAsset_AssetV2Entry_DoNotUse* Arena::CreateMaybeMessage<::protocol::AccountAsset_AssetV2Entry_DoNotUse>(Arena*);
template<> ::protocol::AccountAsset_FreeAssetNetUsageEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::AccountAsset_FreeAssetNetUsageEntry_DoNotUse>(Arena*);
template<> ::protocol::AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse* Arena::CreateMaybeMessage<::protocol::AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse>(Arena*);
template<> ::protocol::AccountAsset_Frozen* Arena::CreateMaybeMessage<::protocol::AccountAsset_Frozen>(Arena*);
template<> ::protocol::AccountAsset_LatestAssetOperationTimeEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::AccountAsset_LatestAssetOperationTimeEntry_DoNotUse>(Arena*);
template<> ::protocol::AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse* Arena::CreateMaybeMessage<::protocol::AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse>(Arena*);
template<> ::protocol::AccountId* Arena::CreateMaybeMessage<::protocol::AccountId>(Arena*);
template<> ::protocol::Account_AccountResource* Arena::CreateMaybeMessage<::protocol::Account_AccountResource>(Arena*);
template<> ::protocol::Account_AssetEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::Account_AssetEntry_DoNotUse>(Arena*);
template<> ::protocol::Account_AssetV2Entry_DoNotUse* Arena::CreateMaybeMessage<::protocol::Account_AssetV2Entry_DoNotUse>(Arena*);
template<> ::protocol::Account_FreeAssetNetUsageEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::Account_FreeAssetNetUsageEntry_DoNotUse>(Arena*);
template<> ::protocol::Account_FreeAssetNetUsageV2Entry_DoNotUse* Arena::CreateMaybeMessage<::protocol::Account_FreeAssetNetUsageV2Entry_DoNotUse>(Arena*);
template<> ::protocol::Account_Frozen* Arena::CreateMaybeMessage<::protocol::Account_Frozen>(Arena*);
template<> ::protocol::Account_LatestAssetOperationTimeEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::Account_LatestAssetOperationTimeEntry_DoNotUse>(Arena*);
template<> ::protocol::Account_LatestAssetOperationTimeV2Entry_DoNotUse* Arena::CreateMaybeMessage<::protocol::Account_LatestAssetOperationTimeV2Entry_DoNotUse>(Arena*);
template<> ::protocol::Block* Arena::CreateMaybeMessage<::protocol::Block>(Arena*);
template<> ::protocol::BlockHeader* Arena::CreateMaybeMessage<::protocol::BlockHeader>(Arena*);
template<> ::protocol::BlockHeader_raw* Arena::CreateMaybeMessage<::protocol::BlockHeader_raw>(Arena*);
template<> ::protocol::BlockInventory* Arena::CreateMaybeMessage<::protocol::BlockInventory>(Arena*);
template<> ::protocol::BlockInventory_BlockId* Arena::CreateMaybeMessage<::protocol::BlockInventory_BlockId>(Arena*);
template<> ::protocol::ChainInventory* Arena::CreateMaybeMessage<::protocol::ChainInventory>(Arena*);
template<> ::protocol::ChainInventory_BlockId* Arena::CreateMaybeMessage<::protocol::ChainInventory_BlockId>(Arena*);
template<> ::protocol::ChainParameters* Arena::CreateMaybeMessage<::protocol::ChainParameters>(Arena*);
template<> ::protocol::ChainParameters_ChainParameter* Arena::CreateMaybeMessage<::protocol::ChainParameters_ChainParameter>(Arena*);
template<> ::protocol::DelegatedResource* Arena::CreateMaybeMessage<::protocol::DelegatedResource>(Arena*);
template<> ::protocol::DelegatedResourceAccountIndex* Arena::CreateMaybeMessage<::protocol::DelegatedResourceAccountIndex>(Arena*);
template<> ::protocol::DisconnectMessage* Arena::CreateMaybeMessage<::protocol::DisconnectMessage>(Arena*);
template<> ::protocol::DynamicProperties* Arena::CreateMaybeMessage<::protocol::DynamicProperties>(Arena*);
template<> ::protocol::Exchange* Arena::CreateMaybeMessage<::protocol::Exchange>(Arena*);
template<> ::protocol::HelloMessage* Arena::CreateMaybeMessage<::protocol::HelloMessage>(Arena*);
template<> ::protocol::HelloMessage_BlockId* Arena::CreateMaybeMessage<::protocol::HelloMessage_BlockId>(Arena*);
template<> ::protocol::InternalTransaction* Arena::CreateMaybeMessage<::protocol::InternalTransaction>(Arena*);
template<> ::protocol::InternalTransaction_CallValueInfo* Arena::CreateMaybeMessage<::protocol::InternalTransaction_CallValueInfo>(Arena*);
template<> ::protocol::Inventory* Arena::CreateMaybeMessage<::protocol::Inventory>(Arena*);
template<> ::protocol::Items* Arena::CreateMaybeMessage<::protocol::Items>(Arena*);
template<> ::protocol::Key* Arena::CreateMaybeMessage<::protocol::Key>(Arena*);
template<> ::protocol::MarketAccountOrder* Arena::CreateMaybeMessage<::protocol::MarketAccountOrder>(Arena*);
template<> ::protocol::MarketOrder* Arena::CreateMaybeMessage<::protocol::MarketOrder>(Arena*);
template<> ::protocol::MarketOrderDetail* Arena::CreateMaybeMessage<::protocol::MarketOrderDetail>(Arena*);
template<> ::protocol::MarketOrderIdList* Arena::CreateMaybeMessage<::protocol::MarketOrderIdList>(Arena*);
template<> ::protocol::MarketOrderList* Arena::CreateMaybeMessage<::protocol::MarketOrderList>(Arena*);
template<> ::protocol::MarketOrderPair* Arena::CreateMaybeMessage<::protocol::MarketOrderPair>(Arena*);
template<> ::protocol::MarketOrderPairList* Arena::CreateMaybeMessage<::protocol::MarketOrderPairList>(Arena*);
template<> ::protocol::MarketPrice* Arena::CreateMaybeMessage<::protocol::MarketPrice>(Arena*);
template<> ::protocol::MarketPriceList* Arena::CreateMaybeMessage<::protocol::MarketPriceList>(Arena*);
template<> ::protocol::MetricsInfo* Arena::CreateMaybeMessage<::protocol::MetricsInfo>(Arena*);
template<> ::protocol::MetricsInfo_BlockChainInfo* Arena::CreateMaybeMessage<::protocol::MetricsInfo_BlockChainInfo>(Arena*);
template<> ::protocol::MetricsInfo_BlockChainInfo_DupWitness* Arena::CreateMaybeMessage<::protocol::MetricsInfo_BlockChainInfo_DupWitness>(Arena*);
template<> ::protocol::MetricsInfo_BlockChainInfo_Witness* Arena::CreateMaybeMessage<::protocol::MetricsInfo_BlockChainInfo_Witness>(Arena*);
template<> ::protocol::MetricsInfo_NetInfo* Arena::CreateMaybeMessage<::protocol::MetricsInfo_NetInfo>(Arena*);
template<> ::protocol::MetricsInfo_NetInfo_ApiInfo* Arena::CreateMaybeMessage<::protocol::MetricsInfo_NetInfo_ApiInfo>(Arena*);
template<> ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo* Arena::CreateMaybeMessage<::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo>(Arena*);
template<> ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo* Arena::CreateMaybeMessage<::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo>(Arena*);
template<> ::protocol::MetricsInfo_NetInfo_LatencyInfo* Arena::CreateMaybeMessage<::protocol::MetricsInfo_NetInfo_LatencyInfo>(Arena*);
template<> ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo* Arena::CreateMaybeMessage<::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo>(Arena*);
template<> ::protocol::MetricsInfo_NodeInfo* Arena::CreateMaybeMessage<::protocol::MetricsInfo_NodeInfo>(Arena*);
template<> ::protocol::MetricsInfo_RateInfo* Arena::CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(Arena*);
template<> ::protocol::NodeInfo* Arena::CreateMaybeMessage<::protocol::NodeInfo>(Arena*);
template<> ::protocol::NodeInfo_CheatWitnessInfoMapEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::NodeInfo_CheatWitnessInfoMapEntry_DoNotUse>(Arena*);
template<> ::protocol::NodeInfo_ConfigNodeInfo* Arena::CreateMaybeMessage<::protocol::NodeInfo_ConfigNodeInfo>(Arena*);
template<> ::protocol::NodeInfo_MachineInfo* Arena::CreateMaybeMessage<::protocol::NodeInfo_MachineInfo>(Arena*);
template<> ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo* Arena::CreateMaybeMessage<::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo>(Arena*);
template<> ::protocol::NodeInfo_MachineInfo_MemoryDescInfo* Arena::CreateMaybeMessage<::protocol::NodeInfo_MachineInfo_MemoryDescInfo>(Arena*);
template<> ::protocol::NodeInfo_PeerInfo* Arena::CreateMaybeMessage<::protocol::NodeInfo_PeerInfo>(Arena*);
template<> ::protocol::PBFTCommitResult* Arena::CreateMaybeMessage<::protocol::PBFTCommitResult>(Arena*);
template<> ::protocol::PBFTMessage* Arena::CreateMaybeMessage<::protocol::PBFTMessage>(Arena*);
template<> ::protocol::PBFTMessage_Raw* Arena::CreateMaybeMessage<::protocol::PBFTMessage_Raw>(Arena*);
template<> ::protocol::Permission* Arena::CreateMaybeMessage<::protocol::Permission>(Arena*);
template<> ::protocol::Proposal* Arena::CreateMaybeMessage<::protocol::Proposal>(Arena*);
template<> ::protocol::Proposal_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::protocol::Proposal_ParametersEntry_DoNotUse>(Arena*);
template<> ::protocol::ResourceReceipt* Arena::CreateMaybeMessage<::protocol::ResourceReceipt>(Arena*);
template<> ::protocol::SRL* Arena::CreateMaybeMessage<::protocol::SRL>(Arena*);
template<> ::protocol::TXInput* Arena::CreateMaybeMessage<::protocol::TXInput>(Arena*);
template<> ::protocol::TXInput_raw* Arena::CreateMaybeMessage<::protocol::TXInput_raw>(Arena*);
template<> ::protocol::TXOutput* Arena::CreateMaybeMessage<::protocol::TXOutput>(Arena*);
template<> ::protocol::TXOutputs* Arena::CreateMaybeMessage<::protocol::TXOutputs>(Arena*);
template<> ::protocol::Transaction* Arena::CreateMaybeMessage<::protocol::Transaction>(Arena*);
template<> ::protocol::TransactionInfo* Arena::CreateMaybeMessage<::protocol::TransactionInfo>(Arena*);
template<> ::protocol::TransactionInfo_Log* Arena::CreateMaybeMessage<::protocol::TransactionInfo_Log>(Arena*);
template<> ::protocol::TransactionRet* Arena::CreateMaybeMessage<::protocol::TransactionRet>(Arena*);
template<> ::protocol::TransactionSign* Arena::CreateMaybeMessage<::protocol::TransactionSign>(Arena*);
template<> ::protocol::Transaction_Contract* Arena::CreateMaybeMessage<::protocol::Transaction_Contract>(Arena*);
template<> ::protocol::Transaction_Result* Arena::CreateMaybeMessage<::protocol::Transaction_Result>(Arena*);
template<> ::protocol::Transaction_raw* Arena::CreateMaybeMessage<::protocol::Transaction_raw>(Arena*);
template<> ::protocol::Transactions* Arena::CreateMaybeMessage<::protocol::Transactions>(Arena*);
template<> ::protocol::Vote* Arena::CreateMaybeMessage<::protocol::Vote>(Arena*);
template<> ::protocol::Votes* Arena::CreateMaybeMessage<::protocol::Votes>(Arena*);
template<> ::protocol::Witness* Arena::CreateMaybeMessage<::protocol::Witness>(Arena*);
template<> ::protocol::authority* Arena::CreateMaybeMessage<::protocol::authority>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace protocol {

enum Proposal_State : int {
  Proposal_State_PENDING = 0,
  Proposal_State_DISAPPROVED = 1,
  Proposal_State_APPROVED = 2,
  Proposal_State_CANCELED = 3,
  Proposal_State_Proposal_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Proposal_State_Proposal_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Proposal_State_IsValid(int value);
constexpr Proposal_State Proposal_State_State_MIN = Proposal_State_PENDING;
constexpr Proposal_State Proposal_State_State_MAX = Proposal_State_CANCELED;
constexpr int Proposal_State_State_ARRAYSIZE = Proposal_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Proposal_State_descriptor();
template<typename T>
inline const std::string& Proposal_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Proposal_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Proposal_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Proposal_State_descriptor(), enum_t_value);
}
inline bool Proposal_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Proposal_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Proposal_State>(
    Proposal_State_descriptor(), name, value);
}
enum MarketOrder_State : int {
  MarketOrder_State_ACTIVE = 0,
  MarketOrder_State_INACTIVE = 1,
  MarketOrder_State_CANCELED = 2,
  MarketOrder_State_MarketOrder_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MarketOrder_State_MarketOrder_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MarketOrder_State_IsValid(int value);
constexpr MarketOrder_State MarketOrder_State_State_MIN = MarketOrder_State_ACTIVE;
constexpr MarketOrder_State MarketOrder_State_State_MAX = MarketOrder_State_CANCELED;
constexpr int MarketOrder_State_State_ARRAYSIZE = MarketOrder_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarketOrder_State_descriptor();
template<typename T>
inline const std::string& MarketOrder_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MarketOrder_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MarketOrder_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MarketOrder_State_descriptor(), enum_t_value);
}
inline bool MarketOrder_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MarketOrder_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarketOrder_State>(
    MarketOrder_State_descriptor(), name, value);
}
enum Permission_PermissionType : int {
  Permission_PermissionType_Owner = 0,
  Permission_PermissionType_Witness = 1,
  Permission_PermissionType_Active = 2,
  Permission_PermissionType_Permission_PermissionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Permission_PermissionType_Permission_PermissionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Permission_PermissionType_IsValid(int value);
constexpr Permission_PermissionType Permission_PermissionType_PermissionType_MIN = Permission_PermissionType_Owner;
constexpr Permission_PermissionType Permission_PermissionType_PermissionType_MAX = Permission_PermissionType_Active;
constexpr int Permission_PermissionType_PermissionType_ARRAYSIZE = Permission_PermissionType_PermissionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Permission_PermissionType_descriptor();
template<typename T>
inline const std::string& Permission_PermissionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Permission_PermissionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Permission_PermissionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Permission_PermissionType_descriptor(), enum_t_value);
}
inline bool Permission_PermissionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Permission_PermissionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Permission_PermissionType>(
    Permission_PermissionType_descriptor(), name, value);
}
enum Transaction_Contract_ContractType : int {
  Transaction_Contract_ContractType_AccountCreateContract = 0,
  Transaction_Contract_ContractType_TransferContract = 1,
  Transaction_Contract_ContractType_TransferAssetContract = 2,
  Transaction_Contract_ContractType_VoteAssetContract = 3,
  Transaction_Contract_ContractType_VoteWitnessContract = 4,
  Transaction_Contract_ContractType_WitnessCreateContract = 5,
  Transaction_Contract_ContractType_AssetIssueContract = 6,
  Transaction_Contract_ContractType_WitnessUpdateContract = 8,
  Transaction_Contract_ContractType_ParticipateAssetIssueContract = 9,
  Transaction_Contract_ContractType_AccountUpdateContract = 10,
  Transaction_Contract_ContractType_FreezeBalanceContract = 11,
  Transaction_Contract_ContractType_UnfreezeBalanceContract = 12,
  Transaction_Contract_ContractType_WithdrawBalanceContract = 13,
  Transaction_Contract_ContractType_UnfreezeAssetContract = 14,
  Transaction_Contract_ContractType_UpdateAssetContract = 15,
  Transaction_Contract_ContractType_ProposalCreateContract = 16,
  Transaction_Contract_ContractType_ProposalApproveContract = 17,
  Transaction_Contract_ContractType_ProposalDeleteContract = 18,
  Transaction_Contract_ContractType_SetAccountIdContract = 19,
  Transaction_Contract_ContractType_CustomContract = 20,
  Transaction_Contract_ContractType_CreateSmartContract = 30,
  Transaction_Contract_ContractType_TriggerSmartContract = 31,
  Transaction_Contract_ContractType_GetContract = 32,
  Transaction_Contract_ContractType_UpdateSettingContract = 33,
  Transaction_Contract_ContractType_ExchangeCreateContract = 41,
  Transaction_Contract_ContractType_ExchangeInjectContract = 42,
  Transaction_Contract_ContractType_ExchangeWithdrawContract = 43,
  Transaction_Contract_ContractType_ExchangeTransactionContract = 44,
  Transaction_Contract_ContractType_UpdateEnergyLimitContract = 45,
  Transaction_Contract_ContractType_AccountPermissionUpdateContract = 46,
  Transaction_Contract_ContractType_ClearABIContract = 48,
  Transaction_Contract_ContractType_UpdateBrokerageContract = 49,
  Transaction_Contract_ContractType_ShieldedTransferContract = 51,
  Transaction_Contract_ContractType_MarketSellAssetContract = 52,
  Transaction_Contract_ContractType_MarketCancelOrderContract = 53,
  Transaction_Contract_ContractType_Transaction_Contract_ContractType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Transaction_Contract_ContractType_Transaction_Contract_ContractType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Transaction_Contract_ContractType_IsValid(int value);
constexpr Transaction_Contract_ContractType Transaction_Contract_ContractType_ContractType_MIN = Transaction_Contract_ContractType_AccountCreateContract;
constexpr Transaction_Contract_ContractType Transaction_Contract_ContractType_ContractType_MAX = Transaction_Contract_ContractType_MarketCancelOrderContract;
constexpr int Transaction_Contract_ContractType_ContractType_ARRAYSIZE = Transaction_Contract_ContractType_ContractType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Transaction_Contract_ContractType_descriptor();
template<typename T>
inline const std::string& Transaction_Contract_ContractType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Transaction_Contract_ContractType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Transaction_Contract_ContractType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Transaction_Contract_ContractType_descriptor(), enum_t_value);
}
inline bool Transaction_Contract_ContractType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Transaction_Contract_ContractType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Transaction_Contract_ContractType>(
    Transaction_Contract_ContractType_descriptor(), name, value);
}
enum Transaction_Result_code : int {
  Transaction_Result_code_SUCESS = 0,
  Transaction_Result_code_FAILED = 1,
  Transaction_Result_code_Transaction_Result_code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Transaction_Result_code_Transaction_Result_code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Transaction_Result_code_IsValid(int value);
constexpr Transaction_Result_code Transaction_Result_code_code_MIN = Transaction_Result_code_SUCESS;
constexpr Transaction_Result_code Transaction_Result_code_code_MAX = Transaction_Result_code_FAILED;
constexpr int Transaction_Result_code_code_ARRAYSIZE = Transaction_Result_code_code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Transaction_Result_code_descriptor();
template<typename T>
inline const std::string& Transaction_Result_code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Transaction_Result_code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Transaction_Result_code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Transaction_Result_code_descriptor(), enum_t_value);
}
inline bool Transaction_Result_code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Transaction_Result_code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Transaction_Result_code>(
    Transaction_Result_code_descriptor(), name, value);
}
enum Transaction_Result_contractResult : int {
  Transaction_Result_contractResult_DEFAULT = 0,
  Transaction_Result_contractResult_SUCCESS = 1,
  Transaction_Result_contractResult_REVERT = 2,
  Transaction_Result_contractResult_BAD_JUMP_DESTINATION = 3,
  Transaction_Result_contractResult_OUT_OF_MEMORY = 4,
  Transaction_Result_contractResult_PRECOMPILED_CONTRACT = 5,
  Transaction_Result_contractResult_STACK_TOO_SMALL = 6,
  Transaction_Result_contractResult_STACK_TOO_LARGE = 7,
  Transaction_Result_contractResult_ILLEGAL_OPERATION = 8,
  Transaction_Result_contractResult_STACK_OVERFLOW = 9,
  Transaction_Result_contractResult_OUT_OF_ENERGY = 10,
  Transaction_Result_contractResult_OUT_OF_TIME = 11,
  Transaction_Result_contractResult_JVM_STACK_OVER_FLOW = 12,
  Transaction_Result_contractResult_UNKNOWN = 13,
  Transaction_Result_contractResult_TRANSFER_FAILED = 14,
  Transaction_Result_contractResult_INVALID_CODE = 15,
  Transaction_Result_contractResult_Transaction_Result_contractResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Transaction_Result_contractResult_Transaction_Result_contractResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Transaction_Result_contractResult_IsValid(int value);
constexpr Transaction_Result_contractResult Transaction_Result_contractResult_contractResult_MIN = Transaction_Result_contractResult_DEFAULT;
constexpr Transaction_Result_contractResult Transaction_Result_contractResult_contractResult_MAX = Transaction_Result_contractResult_INVALID_CODE;
constexpr int Transaction_Result_contractResult_contractResult_ARRAYSIZE = Transaction_Result_contractResult_contractResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Transaction_Result_contractResult_descriptor();
template<typename T>
inline const std::string& Transaction_Result_contractResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Transaction_Result_contractResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Transaction_Result_contractResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Transaction_Result_contractResult_descriptor(), enum_t_value);
}
inline bool Transaction_Result_contractResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Transaction_Result_contractResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Transaction_Result_contractResult>(
    Transaction_Result_contractResult_descriptor(), name, value);
}
enum TransactionInfo_code : int {
  TransactionInfo_code_SUCESS = 0,
  TransactionInfo_code_FAILED = 1,
  TransactionInfo_code_TransactionInfo_code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransactionInfo_code_TransactionInfo_code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransactionInfo_code_IsValid(int value);
constexpr TransactionInfo_code TransactionInfo_code_code_MIN = TransactionInfo_code_SUCESS;
constexpr TransactionInfo_code TransactionInfo_code_code_MAX = TransactionInfo_code_FAILED;
constexpr int TransactionInfo_code_code_ARRAYSIZE = TransactionInfo_code_code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionInfo_code_descriptor();
template<typename T>
inline const std::string& TransactionInfo_code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionInfo_code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionInfo_code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionInfo_code_descriptor(), enum_t_value);
}
inline bool TransactionInfo_code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionInfo_code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionInfo_code>(
    TransactionInfo_code_descriptor(), name, value);
}
enum BlockInventory_Type : int {
  BlockInventory_Type_SYNC = 0,
  BlockInventory_Type_ADVTISE = 1,
  BlockInventory_Type_FETCH = 2,
  BlockInventory_Type_BlockInventory_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BlockInventory_Type_BlockInventory_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BlockInventory_Type_IsValid(int value);
constexpr BlockInventory_Type BlockInventory_Type_Type_MIN = BlockInventory_Type_SYNC;
constexpr BlockInventory_Type BlockInventory_Type_Type_MAX = BlockInventory_Type_FETCH;
constexpr int BlockInventory_Type_Type_ARRAYSIZE = BlockInventory_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BlockInventory_Type_descriptor();
template<typename T>
inline const std::string& BlockInventory_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BlockInventory_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BlockInventory_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BlockInventory_Type_descriptor(), enum_t_value);
}
inline bool BlockInventory_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BlockInventory_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BlockInventory_Type>(
    BlockInventory_Type_descriptor(), name, value);
}
enum Inventory_InventoryType : int {
  Inventory_InventoryType_TRX = 0,
  Inventory_InventoryType_BLOCK = 1,
  Inventory_InventoryType_Inventory_InventoryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Inventory_InventoryType_Inventory_InventoryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Inventory_InventoryType_IsValid(int value);
constexpr Inventory_InventoryType Inventory_InventoryType_InventoryType_MIN = Inventory_InventoryType_TRX;
constexpr Inventory_InventoryType Inventory_InventoryType_InventoryType_MAX = Inventory_InventoryType_BLOCK;
constexpr int Inventory_InventoryType_InventoryType_ARRAYSIZE = Inventory_InventoryType_InventoryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Inventory_InventoryType_descriptor();
template<typename T>
inline const std::string& Inventory_InventoryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Inventory_InventoryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Inventory_InventoryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Inventory_InventoryType_descriptor(), enum_t_value);
}
inline bool Inventory_InventoryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Inventory_InventoryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Inventory_InventoryType>(
    Inventory_InventoryType_descriptor(), name, value);
}
enum Items_ItemType : int {
  Items_ItemType_ERR = 0,
  Items_ItemType_TRX = 1,
  Items_ItemType_BLOCK = 2,
  Items_ItemType_BLOCKHEADER = 3,
  Items_ItemType_Items_ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Items_ItemType_Items_ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Items_ItemType_IsValid(int value);
constexpr Items_ItemType Items_ItemType_ItemType_MIN = Items_ItemType_ERR;
constexpr Items_ItemType Items_ItemType_ItemType_MAX = Items_ItemType_BLOCKHEADER;
constexpr int Items_ItemType_ItemType_ARRAYSIZE = Items_ItemType_ItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Items_ItemType_descriptor();
template<typename T>
inline const std::string& Items_ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Items_ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Items_ItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Items_ItemType_descriptor(), enum_t_value);
}
inline bool Items_ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Items_ItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Items_ItemType>(
    Items_ItemType_descriptor(), name, value);
}
enum PBFTMessage_MsgType : int {
  PBFTMessage_MsgType_VIEW_CHANGE = 0,
  PBFTMessage_MsgType_REQUEST = 1,
  PBFTMessage_MsgType_PREPREPARE = 2,
  PBFTMessage_MsgType_PREPARE = 3,
  PBFTMessage_MsgType_COMMIT = 4,
  PBFTMessage_MsgType_PBFTMessage_MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PBFTMessage_MsgType_PBFTMessage_MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PBFTMessage_MsgType_IsValid(int value);
constexpr PBFTMessage_MsgType PBFTMessage_MsgType_MsgType_MIN = PBFTMessage_MsgType_VIEW_CHANGE;
constexpr PBFTMessage_MsgType PBFTMessage_MsgType_MsgType_MAX = PBFTMessage_MsgType_COMMIT;
constexpr int PBFTMessage_MsgType_MsgType_ARRAYSIZE = PBFTMessage_MsgType_MsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PBFTMessage_MsgType_descriptor();
template<typename T>
inline const std::string& PBFTMessage_MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PBFTMessage_MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PBFTMessage_MsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PBFTMessage_MsgType_descriptor(), enum_t_value);
}
inline bool PBFTMessage_MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PBFTMessage_MsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PBFTMessage_MsgType>(
    PBFTMessage_MsgType_descriptor(), name, value);
}
enum PBFTMessage_DataType : int {
  PBFTMessage_DataType_BLOCK = 0,
  PBFTMessage_DataType_SRL = 1,
  PBFTMessage_DataType_PBFTMessage_DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PBFTMessage_DataType_PBFTMessage_DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PBFTMessage_DataType_IsValid(int value);
constexpr PBFTMessage_DataType PBFTMessage_DataType_DataType_MIN = PBFTMessage_DataType_BLOCK;
constexpr PBFTMessage_DataType PBFTMessage_DataType_DataType_MAX = PBFTMessage_DataType_SRL;
constexpr int PBFTMessage_DataType_DataType_ARRAYSIZE = PBFTMessage_DataType_DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PBFTMessage_DataType_descriptor();
template<typename T>
inline const std::string& PBFTMessage_DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PBFTMessage_DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PBFTMessage_DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PBFTMessage_DataType_descriptor(), enum_t_value);
}
inline bool PBFTMessage_DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PBFTMessage_DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PBFTMessage_DataType>(
    PBFTMessage_DataType_descriptor(), name, value);
}
enum AccountType : int {
  Normal = 0,
  AssetIssue = 1,
  Contract = 2,
  AccountType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AccountType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AccountType_IsValid(int value);
constexpr AccountType AccountType_MIN = Normal;
constexpr AccountType AccountType_MAX = Contract;
constexpr int AccountType_ARRAYSIZE = AccountType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AccountType_descriptor();
template<typename T>
inline const std::string& AccountType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AccountType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AccountType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AccountType_descriptor(), enum_t_value);
}
inline bool AccountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AccountType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccountType>(
    AccountType_descriptor(), name, value);
}
enum ReasonCode : int {
  REQUESTED = 0,
  BAD_PROTOCOL = 2,
  TOO_MANY_PEERS = 4,
  DUPLICATE_PEER = 5,
  INCOMPATIBLE_PROTOCOL = 6,
  NULL_IDENTITY = 7,
  PEER_QUITING = 8,
  UNEXPECTED_IDENTITY = 9,
  LOCAL_IDENTITY = 10,
  PING_TIMEOUT = 11,
  USER_REASON = 16,
  RESET = 17,
  SYNC_FAIL = 18,
  FETCH_FAIL = 19,
  BAD_TX = 20,
  BAD_BLOCK = 21,
  FORKED = 22,
  UNLINKABLE = 23,
  INCOMPATIBLE_VERSION = 24,
  INCOMPATIBLE_CHAIN = 25,
  TIME_OUT = 32,
  CONNECT_FAIL = 33,
  TOO_MANY_PEERS_WITH_SAME_IP = 34,
  UNKNOWN = 255,
  ReasonCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ReasonCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ReasonCode_IsValid(int value);
constexpr ReasonCode ReasonCode_MIN = REQUESTED;
constexpr ReasonCode ReasonCode_MAX = UNKNOWN;
constexpr int ReasonCode_ARRAYSIZE = ReasonCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReasonCode_descriptor();
template<typename T>
inline const std::string& ReasonCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReasonCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReasonCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReasonCode_descriptor(), enum_t_value);
}
inline bool ReasonCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReasonCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReasonCode>(
    ReasonCode_descriptor(), name, value);
}
// ===================================================================

class AccountId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountId) */ {
 public:
  inline AccountId() : AccountId(nullptr) {}
  ~AccountId() override;
  explicit constexpr AccountId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountId(const AccountId& from);
  AccountId(AccountId&& from) noexcept
    : AccountId() {
    *this = ::std::move(from);
  }

  inline AccountId& operator=(const AccountId& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountId& operator=(AccountId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountId& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountId* internal_default_instance() {
    return reinterpret_cast<const AccountId*>(
               &_AccountId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AccountId& a, AccountId& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountId";
  }
  protected:
  explicit AccountId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.AccountId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Vote final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Vote) */ {
 public:
  inline Vote() : Vote(nullptr) {}
  ~Vote() override;
  explicit constexpr Vote(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vote(const Vote& from);
  Vote(Vote&& from) noexcept
    : Vote() {
    *this = ::std::move(from);
  }

  inline Vote& operator=(const Vote& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vote& operator=(Vote&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vote& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vote* internal_default_instance() {
    return reinterpret_cast<const Vote*>(
               &_Vote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vote& a, Vote& b) {
    a.Swap(&b);
  }
  inline void Swap(Vote* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vote>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vote& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vote& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vote* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Vote";
  }
  protected:
  explicit Vote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoteAddressFieldNumber = 1,
    kVoteCountFieldNumber = 2,
  };
  // bytes vote_address = 1;
  void clear_vote_address();
  const std::string& vote_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vote_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vote_address();
  PROTOBUF_NODISCARD std::string* release_vote_address();
  void set_allocated_vote_address(std::string* vote_address);
  private:
  const std::string& _internal_vote_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vote_address(const std::string& value);
  std::string* _internal_mutable_vote_address();
  public:

  // int64 vote_count = 2;
  void clear_vote_count();
  int64_t vote_count() const;
  void set_vote_count(int64_t value);
  private:
  int64_t _internal_vote_count() const;
  void _internal_set_vote_count(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Vote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vote_address_;
  int64_t vote_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Proposal_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Proposal_ParametersEntry_DoNotUse, 
    int64_t, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Proposal_ParametersEntry_DoNotUse, 
    int64_t, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  Proposal_ParametersEntry_DoNotUse();
  explicit constexpr Proposal_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Proposal_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Proposal_ParametersEntry_DoNotUse& other);
  static const Proposal_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Proposal_ParametersEntry_DoNotUse*>(&_Proposal_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Proposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Proposal) */ {
 public:
  inline Proposal() : Proposal(nullptr) {}
  ~Proposal() override;
  explicit constexpr Proposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Proposal(const Proposal& from);
  Proposal(Proposal&& from) noexcept
    : Proposal() {
    *this = ::std::move(from);
  }

  inline Proposal& operator=(const Proposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Proposal& operator=(Proposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Proposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Proposal* internal_default_instance() {
    return reinterpret_cast<const Proposal*>(
               &_Proposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Proposal& a, Proposal& b) {
    a.Swap(&b);
  }
  inline void Swap(Proposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Proposal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Proposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Proposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Proposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Proposal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Proposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Proposal";
  }
  protected:
  explicit Proposal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef Proposal_State State;
  static constexpr State PENDING =
    Proposal_State_PENDING;
  static constexpr State DISAPPROVED =
    Proposal_State_DISAPPROVED;
  static constexpr State APPROVED =
    Proposal_State_APPROVED;
  static constexpr State CANCELED =
    Proposal_State_CANCELED;
  static inline bool State_IsValid(int value) {
    return Proposal_State_IsValid(value);
  }
  static constexpr State State_MIN =
    Proposal_State_State_MIN;
  static constexpr State State_MAX =
    Proposal_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    Proposal_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return Proposal_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return Proposal_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return Proposal_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kApprovalsFieldNumber = 6,
    kProposerAddressFieldNumber = 2,
    kProposalIdFieldNumber = 1,
    kExpirationTimeFieldNumber = 4,
    kCreateTimeFieldNumber = 5,
    kStateFieldNumber = 7,
  };
  // map<int64, int64> parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >*
      mutable_parameters();

  // repeated bytes approvals = 6;
  int approvals_size() const;
  private:
  int _internal_approvals_size() const;
  public:
  void clear_approvals();
  const std::string& approvals(int index) const;
  std::string* mutable_approvals(int index);
  void set_approvals(int index, const std::string& value);
  void set_approvals(int index, std::string&& value);
  void set_approvals(int index, const char* value);
  void set_approvals(int index, const void* value, size_t size);
  std::string* add_approvals();
  void add_approvals(const std::string& value);
  void add_approvals(std::string&& value);
  void add_approvals(const char* value);
  void add_approvals(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& approvals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_approvals();
  private:
  const std::string& _internal_approvals(int index) const;
  std::string* _internal_add_approvals();
  public:

  // bytes proposer_address = 2;
  void clear_proposer_address();
  const std::string& proposer_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proposer_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proposer_address();
  PROTOBUF_NODISCARD std::string* release_proposer_address();
  void set_allocated_proposer_address(std::string* proposer_address);
  private:
  const std::string& _internal_proposer_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proposer_address(const std::string& value);
  std::string* _internal_mutable_proposer_address();
  public:

  // int64 proposal_id = 1;
  void clear_proposal_id();
  int64_t proposal_id() const;
  void set_proposal_id(int64_t value);
  private:
  int64_t _internal_proposal_id() const;
  void _internal_set_proposal_id(int64_t value);
  public:

  // int64 expiration_time = 4;
  void clear_expiration_time();
  int64_t expiration_time() const;
  void set_expiration_time(int64_t value);
  private:
  int64_t _internal_expiration_time() const;
  void _internal_set_expiration_time(int64_t value);
  public:

  // int64 create_time = 5;
  void clear_create_time();
  int64_t create_time() const;
  void set_create_time(int64_t value);
  private:
  int64_t _internal_create_time() const;
  void _internal_set_create_time(int64_t value);
  public:

  // .protocol.Proposal.State state = 7;
  void clear_state();
  ::protocol::Proposal_State state() const;
  void set_state(::protocol::Proposal_State value);
  private:
  ::protocol::Proposal_State _internal_state() const;
  void _internal_set_state(::protocol::Proposal_State value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Proposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Proposal_ParametersEntry_DoNotUse,
      int64_t, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> parameters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> approvals_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposer_address_;
  int64_t proposal_id_;
  int64_t expiration_time_;
  int64_t create_time_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Exchange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Exchange) */ {
 public:
  inline Exchange() : Exchange(nullptr) {}
  ~Exchange() override;
  explicit constexpr Exchange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Exchange(const Exchange& from);
  Exchange(Exchange&& from) noexcept
    : Exchange() {
    *this = ::std::move(from);
  }

  inline Exchange& operator=(const Exchange& from) {
    CopyFrom(from);
    return *this;
  }
  inline Exchange& operator=(Exchange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Exchange& default_instance() {
    return *internal_default_instance();
  }
  static inline const Exchange* internal_default_instance() {
    return reinterpret_cast<const Exchange*>(
               &_Exchange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Exchange& a, Exchange& b) {
    a.Swap(&b);
  }
  inline void Swap(Exchange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Exchange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Exchange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Exchange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Exchange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Exchange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Exchange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Exchange";
  }
  protected:
  explicit Exchange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatorAddressFieldNumber = 2,
    kFirstTokenIdFieldNumber = 6,
    kSecondTokenIdFieldNumber = 8,
    kExchangeIdFieldNumber = 1,
    kCreateTimeFieldNumber = 3,
    kFirstTokenBalanceFieldNumber = 7,
    kSecondTokenBalanceFieldNumber = 9,
  };
  // bytes creator_address = 2;
  void clear_creator_address();
  const std::string& creator_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator_address();
  PROTOBUF_NODISCARD std::string* release_creator_address();
  void set_allocated_creator_address(std::string* creator_address);
  private:
  const std::string& _internal_creator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator_address(const std::string& value);
  std::string* _internal_mutable_creator_address();
  public:

  // bytes first_token_id = 6;
  void clear_first_token_id();
  const std::string& first_token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_token_id();
  PROTOBUF_NODISCARD std::string* release_first_token_id();
  void set_allocated_first_token_id(std::string* first_token_id);
  private:
  const std::string& _internal_first_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_token_id(const std::string& value);
  std::string* _internal_mutable_first_token_id();
  public:

  // bytes second_token_id = 8;
  void clear_second_token_id();
  const std::string& second_token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_second_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_second_token_id();
  PROTOBUF_NODISCARD std::string* release_second_token_id();
  void set_allocated_second_token_id(std::string* second_token_id);
  private:
  const std::string& _internal_second_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_second_token_id(const std::string& value);
  std::string* _internal_mutable_second_token_id();
  public:

  // int64 exchange_id = 1;
  void clear_exchange_id();
  int64_t exchange_id() const;
  void set_exchange_id(int64_t value);
  private:
  int64_t _internal_exchange_id() const;
  void _internal_set_exchange_id(int64_t value);
  public:

  // int64 create_time = 3;
  void clear_create_time();
  int64_t create_time() const;
  void set_create_time(int64_t value);
  private:
  int64_t _internal_create_time() const;
  void _internal_set_create_time(int64_t value);
  public:

  // int64 first_token_balance = 7;
  void clear_first_token_balance();
  int64_t first_token_balance() const;
  void set_first_token_balance(int64_t value);
  private:
  int64_t _internal_first_token_balance() const;
  void _internal_set_first_token_balance(int64_t value);
  public:

  // int64 second_token_balance = 9;
  void clear_second_token_balance();
  int64_t second_token_balance() const;
  void set_second_token_balance(int64_t value);
  private:
  int64_t _internal_second_token_balance() const;
  void _internal_set_second_token_balance(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Exchange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_token_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr second_token_id_;
  int64_t exchange_id_;
  int64_t create_time_;
  int64_t first_token_balance_;
  int64_t second_token_balance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MarketOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MarketOrder) */ {
 public:
  inline MarketOrder() : MarketOrder(nullptr) {}
  ~MarketOrder() override;
  explicit constexpr MarketOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketOrder(const MarketOrder& from);
  MarketOrder(MarketOrder&& from) noexcept
    : MarketOrder() {
    *this = ::std::move(from);
  }

  inline MarketOrder& operator=(const MarketOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketOrder& operator=(MarketOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketOrder* internal_default_instance() {
    return reinterpret_cast<const MarketOrder*>(
               &_MarketOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MarketOrder& a, MarketOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarketOrder& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MarketOrder";
  }
  protected:
  explicit MarketOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MarketOrder_State State;
  static constexpr State ACTIVE =
    MarketOrder_State_ACTIVE;
  static constexpr State INACTIVE =
    MarketOrder_State_INACTIVE;
  static constexpr State CANCELED =
    MarketOrder_State_CANCELED;
  static inline bool State_IsValid(int value) {
    return MarketOrder_State_IsValid(value);
  }
  static constexpr State State_MIN =
    MarketOrder_State_State_MIN;
  static constexpr State State_MAX =
    MarketOrder_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    MarketOrder_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return MarketOrder_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return MarketOrder_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return MarketOrder_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOrderIdFieldNumber = 1,
    kOwnerAddressFieldNumber = 2,
    kSellTokenIdFieldNumber = 4,
    kBuyTokenIdFieldNumber = 6,
    kPrevFieldNumber = 12,
    kNextFieldNumber = 13,
    kCreateTimeFieldNumber = 3,
    kSellTokenQuantityFieldNumber = 5,
    kBuyTokenQuantityFieldNumber = 7,
    kSellTokenQuantityRemainFieldNumber = 9,
    kSellTokenQuantityReturnFieldNumber = 10,
    kStateFieldNumber = 11,
  };
  // bytes order_id = 1;
  void clear_order_id();
  const std::string& order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id();
  PROTOBUF_NODISCARD std::string* release_order_id();
  void set_allocated_order_id(std::string* order_id);
  private:
  const std::string& _internal_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const std::string& value);
  std::string* _internal_mutable_order_id();
  public:

  // bytes owner_address = 2;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // bytes sell_token_id = 4;
  void clear_sell_token_id();
  const std::string& sell_token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sell_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sell_token_id();
  PROTOBUF_NODISCARD std::string* release_sell_token_id();
  void set_allocated_sell_token_id(std::string* sell_token_id);
  private:
  const std::string& _internal_sell_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sell_token_id(const std::string& value);
  std::string* _internal_mutable_sell_token_id();
  public:

  // bytes buy_token_id = 6;
  void clear_buy_token_id();
  const std::string& buy_token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buy_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buy_token_id();
  PROTOBUF_NODISCARD std::string* release_buy_token_id();
  void set_allocated_buy_token_id(std::string* buy_token_id);
  private:
  const std::string& _internal_buy_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buy_token_id(const std::string& value);
  std::string* _internal_mutable_buy_token_id();
  public:

  // bytes prev = 12;
  void clear_prev();
  const std::string& prev() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prev(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prev();
  PROTOBUF_NODISCARD std::string* release_prev();
  void set_allocated_prev(std::string* prev);
  private:
  const std::string& _internal_prev() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prev(const std::string& value);
  std::string* _internal_mutable_prev();
  public:

  // bytes next = 13;
  void clear_next();
  const std::string& next() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next();
  PROTOBUF_NODISCARD std::string* release_next();
  void set_allocated_next(std::string* next);
  private:
  const std::string& _internal_next() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next(const std::string& value);
  std::string* _internal_mutable_next();
  public:

  // int64 create_time = 3;
  void clear_create_time();
  int64_t create_time() const;
  void set_create_time(int64_t value);
  private:
  int64_t _internal_create_time() const;
  void _internal_set_create_time(int64_t value);
  public:

  // int64 sell_token_quantity = 5;
  void clear_sell_token_quantity();
  int64_t sell_token_quantity() const;
  void set_sell_token_quantity(int64_t value);
  private:
  int64_t _internal_sell_token_quantity() const;
  void _internal_set_sell_token_quantity(int64_t value);
  public:

  // int64 buy_token_quantity = 7;
  void clear_buy_token_quantity();
  int64_t buy_token_quantity() const;
  void set_buy_token_quantity(int64_t value);
  private:
  int64_t _internal_buy_token_quantity() const;
  void _internal_set_buy_token_quantity(int64_t value);
  public:

  // int64 sell_token_quantity_remain = 9;
  void clear_sell_token_quantity_remain();
  int64_t sell_token_quantity_remain() const;
  void set_sell_token_quantity_remain(int64_t value);
  private:
  int64_t _internal_sell_token_quantity_remain() const;
  void _internal_set_sell_token_quantity_remain(int64_t value);
  public:

  // int64 sell_token_quantity_return = 10;
  void clear_sell_token_quantity_return();
  int64_t sell_token_quantity_return() const;
  void set_sell_token_quantity_return(int64_t value);
  private:
  int64_t _internal_sell_token_quantity_return() const;
  void _internal_set_sell_token_quantity_return(int64_t value);
  public:

  // .protocol.MarketOrder.State state = 11;
  void clear_state();
  ::protocol::MarketOrder_State state() const;
  void set_state(::protocol::MarketOrder_State value);
  private:
  ::protocol::MarketOrder_State _internal_state() const;
  void _internal_set_state(::protocol::MarketOrder_State value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MarketOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sell_token_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buy_token_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prev_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_;
  int64_t create_time_;
  int64_t sell_token_quantity_;
  int64_t buy_token_quantity_;
  int64_t sell_token_quantity_remain_;
  int64_t sell_token_quantity_return_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MarketOrderList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MarketOrderList) */ {
 public:
  inline MarketOrderList() : MarketOrderList(nullptr) {}
  ~MarketOrderList() override;
  explicit constexpr MarketOrderList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketOrderList(const MarketOrderList& from);
  MarketOrderList(MarketOrderList&& from) noexcept
    : MarketOrderList() {
    *this = ::std::move(from);
  }

  inline MarketOrderList& operator=(const MarketOrderList& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketOrderList& operator=(MarketOrderList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketOrderList& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketOrderList* internal_default_instance() {
    return reinterpret_cast<const MarketOrderList*>(
               &_MarketOrderList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MarketOrderList& a, MarketOrderList& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketOrderList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketOrderList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketOrderList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketOrderList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketOrderList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarketOrderList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketOrderList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MarketOrderList";
  }
  protected:
  explicit MarketOrderList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
  };
  // repeated .protocol.MarketOrder orders = 1;
  int orders_size() const;
  private:
  int _internal_orders_size() const;
  public:
  void clear_orders();
  ::protocol::MarketOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrder >*
      mutable_orders();
  private:
  const ::protocol::MarketOrder& _internal_orders(int index) const;
  ::protocol::MarketOrder* _internal_add_orders();
  public:
  const ::protocol::MarketOrder& orders(int index) const;
  ::protocol::MarketOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrder >&
      orders() const;

  // @@protoc_insertion_point(class_scope:protocol.MarketOrderList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrder > orders_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MarketOrderPairList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MarketOrderPairList) */ {
 public:
  inline MarketOrderPairList() : MarketOrderPairList(nullptr) {}
  ~MarketOrderPairList() override;
  explicit constexpr MarketOrderPairList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketOrderPairList(const MarketOrderPairList& from);
  MarketOrderPairList(MarketOrderPairList&& from) noexcept
    : MarketOrderPairList() {
    *this = ::std::move(from);
  }

  inline MarketOrderPairList& operator=(const MarketOrderPairList& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketOrderPairList& operator=(MarketOrderPairList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketOrderPairList& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketOrderPairList* internal_default_instance() {
    return reinterpret_cast<const MarketOrderPairList*>(
               &_MarketOrderPairList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MarketOrderPairList& a, MarketOrderPairList& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketOrderPairList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketOrderPairList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketOrderPairList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketOrderPairList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketOrderPairList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarketOrderPairList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketOrderPairList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MarketOrderPairList";
  }
  protected:
  explicit MarketOrderPairList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderPairFieldNumber = 1,
  };
  // repeated .protocol.MarketOrderPair orderPair = 1;
  int orderpair_size() const;
  private:
  int _internal_orderpair_size() const;
  public:
  void clear_orderpair();
  ::protocol::MarketOrderPair* mutable_orderpair(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderPair >*
      mutable_orderpair();
  private:
  const ::protocol::MarketOrderPair& _internal_orderpair(int index) const;
  ::protocol::MarketOrderPair* _internal_add_orderpair();
  public:
  const ::protocol::MarketOrderPair& orderpair(int index) const;
  ::protocol::MarketOrderPair* add_orderpair();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderPair >&
      orderpair() const;

  // @@protoc_insertion_point(class_scope:protocol.MarketOrderPairList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderPair > orderpair_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MarketOrderPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MarketOrderPair) */ {
 public:
  inline MarketOrderPair() : MarketOrderPair(nullptr) {}
  ~MarketOrderPair() override;
  explicit constexpr MarketOrderPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketOrderPair(const MarketOrderPair& from);
  MarketOrderPair(MarketOrderPair&& from) noexcept
    : MarketOrderPair() {
    *this = ::std::move(from);
  }

  inline MarketOrderPair& operator=(const MarketOrderPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketOrderPair& operator=(MarketOrderPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketOrderPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketOrderPair* internal_default_instance() {
    return reinterpret_cast<const MarketOrderPair*>(
               &_MarketOrderPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MarketOrderPair& a, MarketOrderPair& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketOrderPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketOrderPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketOrderPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketOrderPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketOrderPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarketOrderPair& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketOrderPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MarketOrderPair";
  }
  protected:
  explicit MarketOrderPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSellTokenIdFieldNumber = 1,
    kBuyTokenIdFieldNumber = 2,
  };
  // bytes sell_token_id = 1;
  void clear_sell_token_id();
  const std::string& sell_token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sell_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sell_token_id();
  PROTOBUF_NODISCARD std::string* release_sell_token_id();
  void set_allocated_sell_token_id(std::string* sell_token_id);
  private:
  const std::string& _internal_sell_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sell_token_id(const std::string& value);
  std::string* _internal_mutable_sell_token_id();
  public:

  // bytes buy_token_id = 2;
  void clear_buy_token_id();
  const std::string& buy_token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buy_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buy_token_id();
  PROTOBUF_NODISCARD std::string* release_buy_token_id();
  void set_allocated_buy_token_id(std::string* buy_token_id);
  private:
  const std::string& _internal_buy_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buy_token_id(const std::string& value);
  std::string* _internal_mutable_buy_token_id();
  public:

  // @@protoc_insertion_point(class_scope:protocol.MarketOrderPair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sell_token_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buy_token_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MarketAccountOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MarketAccountOrder) */ {
 public:
  inline MarketAccountOrder() : MarketAccountOrder(nullptr) {}
  ~MarketAccountOrder() override;
  explicit constexpr MarketAccountOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketAccountOrder(const MarketAccountOrder& from);
  MarketAccountOrder(MarketAccountOrder&& from) noexcept
    : MarketAccountOrder() {
    *this = ::std::move(from);
  }

  inline MarketAccountOrder& operator=(const MarketAccountOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketAccountOrder& operator=(MarketAccountOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketAccountOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketAccountOrder* internal_default_instance() {
    return reinterpret_cast<const MarketAccountOrder*>(
               &_MarketAccountOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MarketAccountOrder& a, MarketAccountOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketAccountOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketAccountOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketAccountOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketAccountOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketAccountOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarketAccountOrder& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketAccountOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MarketAccountOrder";
  }
  protected:
  explicit MarketAccountOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 2,
    kOwnerAddressFieldNumber = 1,
    kCountFieldNumber = 3,
    kTotalCountFieldNumber = 4,
  };
  // repeated bytes orders = 2;
  int orders_size() const;
  private:
  int _internal_orders_size() const;
  public:
  void clear_orders();
  const std::string& orders(int index) const;
  std::string* mutable_orders(int index);
  void set_orders(int index, const std::string& value);
  void set_orders(int index, std::string&& value);
  void set_orders(int index, const char* value);
  void set_orders(int index, const void* value, size_t size);
  std::string* add_orders();
  void add_orders(const std::string& value);
  void add_orders(std::string&& value);
  void add_orders(const char* value);
  void add_orders(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_orders();
  private:
  const std::string& _internal_orders(int index) const;
  std::string* _internal_add_orders();
  public:

  // bytes owner_address = 1;
  void clear_owner_address();
  const std::string& owner_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner_address();
  PROTOBUF_NODISCARD std::string* release_owner_address();
  void set_allocated_owner_address(std::string* owner_address);
  private:
  const std::string& _internal_owner_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_address(const std::string& value);
  std::string* _internal_mutable_owner_address();
  public:

  // int64 count = 3;
  void clear_count();
  int64_t count() const;
  void set_count(int64_t value);
  private:
  int64_t _internal_count() const;
  void _internal_set_count(int64_t value);
  public:

  // int64 total_count = 4;
  void clear_total_count();
  int64_t total_count() const;
  void set_total_count(int64_t value);
  private:
  int64_t _internal_total_count() const;
  void _internal_set_total_count(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MarketAccountOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> orders_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_address_;
  int64_t count_;
  int64_t total_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MarketPrice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MarketPrice) */ {
 public:
  inline MarketPrice() : MarketPrice(nullptr) {}
  ~MarketPrice() override;
  explicit constexpr MarketPrice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketPrice(const MarketPrice& from);
  MarketPrice(MarketPrice&& from) noexcept
    : MarketPrice() {
    *this = ::std::move(from);
  }

  inline MarketPrice& operator=(const MarketPrice& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketPrice& operator=(MarketPrice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketPrice& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketPrice* internal_default_instance() {
    return reinterpret_cast<const MarketPrice*>(
               &_MarketPrice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MarketPrice& a, MarketPrice& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketPrice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketPrice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketPrice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketPrice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketPrice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarketPrice& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketPrice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MarketPrice";
  }
  protected:
  explicit MarketPrice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSellTokenQuantityFieldNumber = 1,
    kBuyTokenQuantityFieldNumber = 2,
  };
  // int64 sell_token_quantity = 1;
  void clear_sell_token_quantity();
  int64_t sell_token_quantity() const;
  void set_sell_token_quantity(int64_t value);
  private:
  int64_t _internal_sell_token_quantity() const;
  void _internal_set_sell_token_quantity(int64_t value);
  public:

  // int64 buy_token_quantity = 2;
  void clear_buy_token_quantity();
  int64_t buy_token_quantity() const;
  void set_buy_token_quantity(int64_t value);
  private:
  int64_t _internal_buy_token_quantity() const;
  void _internal_set_buy_token_quantity(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MarketPrice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t sell_token_quantity_;
  int64_t buy_token_quantity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MarketPriceList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MarketPriceList) */ {
 public:
  inline MarketPriceList() : MarketPriceList(nullptr) {}
  ~MarketPriceList() override;
  explicit constexpr MarketPriceList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketPriceList(const MarketPriceList& from);
  MarketPriceList(MarketPriceList&& from) noexcept
    : MarketPriceList() {
    *this = ::std::move(from);
  }

  inline MarketPriceList& operator=(const MarketPriceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketPriceList& operator=(MarketPriceList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketPriceList& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketPriceList* internal_default_instance() {
    return reinterpret_cast<const MarketPriceList*>(
               &_MarketPriceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MarketPriceList& a, MarketPriceList& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketPriceList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketPriceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketPriceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketPriceList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketPriceList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarketPriceList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketPriceList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MarketPriceList";
  }
  protected:
  explicit MarketPriceList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPricesFieldNumber = 3,
    kSellTokenIdFieldNumber = 1,
    kBuyTokenIdFieldNumber = 2,
  };
  // repeated .protocol.MarketPrice prices = 3;
  int prices_size() const;
  private:
  int _internal_prices_size() const;
  public:
  void clear_prices();
  ::protocol::MarketPrice* mutable_prices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketPrice >*
      mutable_prices();
  private:
  const ::protocol::MarketPrice& _internal_prices(int index) const;
  ::protocol::MarketPrice* _internal_add_prices();
  public:
  const ::protocol::MarketPrice& prices(int index) const;
  ::protocol::MarketPrice* add_prices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketPrice >&
      prices() const;

  // bytes sell_token_id = 1;
  void clear_sell_token_id();
  const std::string& sell_token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sell_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sell_token_id();
  PROTOBUF_NODISCARD std::string* release_sell_token_id();
  void set_allocated_sell_token_id(std::string* sell_token_id);
  private:
  const std::string& _internal_sell_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sell_token_id(const std::string& value);
  std::string* _internal_mutable_sell_token_id();
  public:

  // bytes buy_token_id = 2;
  void clear_buy_token_id();
  const std::string& buy_token_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buy_token_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buy_token_id();
  PROTOBUF_NODISCARD std::string* release_buy_token_id();
  void set_allocated_buy_token_id(std::string* buy_token_id);
  private:
  const std::string& _internal_buy_token_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buy_token_id(const std::string& value);
  std::string* _internal_mutable_buy_token_id();
  public:

  // @@protoc_insertion_point(class_scope:protocol.MarketPriceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketPrice > prices_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sell_token_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buy_token_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MarketOrderIdList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MarketOrderIdList) */ {
 public:
  inline MarketOrderIdList() : MarketOrderIdList(nullptr) {}
  ~MarketOrderIdList() override;
  explicit constexpr MarketOrderIdList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketOrderIdList(const MarketOrderIdList& from);
  MarketOrderIdList(MarketOrderIdList&& from) noexcept
    : MarketOrderIdList() {
    *this = ::std::move(from);
  }

  inline MarketOrderIdList& operator=(const MarketOrderIdList& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketOrderIdList& operator=(MarketOrderIdList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketOrderIdList& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketOrderIdList* internal_default_instance() {
    return reinterpret_cast<const MarketOrderIdList*>(
               &_MarketOrderIdList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MarketOrderIdList& a, MarketOrderIdList& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketOrderIdList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketOrderIdList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketOrderIdList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketOrderIdList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketOrderIdList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarketOrderIdList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketOrderIdList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MarketOrderIdList";
  }
  protected:
  explicit MarketOrderIdList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
    kTailFieldNumber = 2,
  };
  // bytes head = 1;
  void clear_head();
  const std::string& head() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_head(ArgT0&& arg0, ArgT... args);
  std::string* mutable_head();
  PROTOBUF_NODISCARD std::string* release_head();
  void set_allocated_head(std::string* head);
  private:
  const std::string& _internal_head() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_head(const std::string& value);
  std::string* _internal_mutable_head();
  public:

  // bytes tail = 2;
  void clear_tail();
  const std::string& tail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tail();
  PROTOBUF_NODISCARD std::string* release_tail();
  void set_allocated_tail(std::string* tail);
  private:
  const std::string& _internal_tail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tail(const std::string& value);
  std::string* _internal_mutable_tail();
  public:

  // @@protoc_insertion_point(class_scope:protocol.MarketOrderIdList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr head_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tail_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class ChainParameters_ChainParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ChainParameters.ChainParameter) */ {
 public:
  inline ChainParameters_ChainParameter() : ChainParameters_ChainParameter(nullptr) {}
  ~ChainParameters_ChainParameter() override;
  explicit constexpr ChainParameters_ChainParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChainParameters_ChainParameter(const ChainParameters_ChainParameter& from);
  ChainParameters_ChainParameter(ChainParameters_ChainParameter&& from) noexcept
    : ChainParameters_ChainParameter() {
    *this = ::std::move(from);
  }

  inline ChainParameters_ChainParameter& operator=(const ChainParameters_ChainParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChainParameters_ChainParameter& operator=(ChainParameters_ChainParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChainParameters_ChainParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChainParameters_ChainParameter* internal_default_instance() {
    return reinterpret_cast<const ChainParameters_ChainParameter*>(
               &_ChainParameters_ChainParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ChainParameters_ChainParameter& a, ChainParameters_ChainParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(ChainParameters_ChainParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChainParameters_ChainParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChainParameters_ChainParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChainParameters_ChainParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChainParameters_ChainParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChainParameters_ChainParameter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChainParameters_ChainParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ChainParameters.ChainParameter";
  }
  protected:
  explicit ChainParameters_ChainParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // int64 value = 2;
  void clear_value();
  int64_t value() const;
  void set_value(int64_t value);
  private:
  int64_t _internal_value() const;
  void _internal_set_value(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ChainParameters.ChainParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int64_t value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class ChainParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ChainParameters) */ {
 public:
  inline ChainParameters() : ChainParameters(nullptr) {}
  ~ChainParameters() override;
  explicit constexpr ChainParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChainParameters(const ChainParameters& from);
  ChainParameters(ChainParameters&& from) noexcept
    : ChainParameters() {
    *this = ::std::move(from);
  }

  inline ChainParameters& operator=(const ChainParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChainParameters& operator=(ChainParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChainParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChainParameters* internal_default_instance() {
    return reinterpret_cast<const ChainParameters*>(
               &_ChainParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ChainParameters& a, ChainParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(ChainParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChainParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChainParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChainParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChainParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChainParameters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChainParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ChainParameters";
  }
  protected:
  explicit ChainParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChainParameters_ChainParameter ChainParameter;

  // accessors -------------------------------------------------------

  enum : int {
    kChainParameterFieldNumber = 1,
  };
  // repeated .protocol.ChainParameters.ChainParameter chainParameter = 1;
  int chainparameter_size() const;
  private:
  int _internal_chainparameter_size() const;
  public:
  void clear_chainparameter();
  ::protocol::ChainParameters_ChainParameter* mutable_chainparameter(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ChainParameters_ChainParameter >*
      mutable_chainparameter();
  private:
  const ::protocol::ChainParameters_ChainParameter& _internal_chainparameter(int index) const;
  ::protocol::ChainParameters_ChainParameter* _internal_add_chainparameter();
  public:
  const ::protocol::ChainParameters_ChainParameter& chainparameter(int index) const;
  ::protocol::ChainParameters_ChainParameter* add_chainparameter();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ChainParameters_ChainParameter >&
      chainparameter() const;

  // @@protoc_insertion_point(class_scope:protocol.ChainParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ChainParameters_ChainParameter > chainparameter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Account_Frozen final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Account.Frozen) */ {
 public:
  inline Account_Frozen() : Account_Frozen(nullptr) {}
  ~Account_Frozen() override;
  explicit constexpr Account_Frozen(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Account_Frozen(const Account_Frozen& from);
  Account_Frozen(Account_Frozen&& from) noexcept
    : Account_Frozen() {
    *this = ::std::move(from);
  }

  inline Account_Frozen& operator=(const Account_Frozen& from) {
    CopyFrom(from);
    return *this;
  }
  inline Account_Frozen& operator=(Account_Frozen&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Account_Frozen& default_instance() {
    return *internal_default_instance();
  }
  static inline const Account_Frozen* internal_default_instance() {
    return reinterpret_cast<const Account_Frozen*>(
               &_Account_Frozen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Account_Frozen& a, Account_Frozen& b) {
    a.Swap(&b);
  }
  inline void Swap(Account_Frozen* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Account_Frozen* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Account_Frozen* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Account_Frozen>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Account_Frozen& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Account_Frozen& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Account_Frozen* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Account.Frozen";
  }
  protected:
  explicit Account_Frozen(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrozenBalanceFieldNumber = 1,
    kExpireTimeFieldNumber = 2,
  };
  // int64 frozen_balance = 1;
  void clear_frozen_balance();
  int64_t frozen_balance() const;
  void set_frozen_balance(int64_t value);
  private:
  int64_t _internal_frozen_balance() const;
  void _internal_set_frozen_balance(int64_t value);
  public:

  // int64 expire_time = 2;
  void clear_expire_time();
  int64_t expire_time() const;
  void set_expire_time(int64_t value);
  private:
  int64_t _internal_expire_time() const;
  void _internal_set_expire_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Account.Frozen)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t frozen_balance_;
  int64_t expire_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Account_AssetEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_AssetEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_AssetEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  Account_AssetEntry_DoNotUse();
  explicit constexpr Account_AssetEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Account_AssetEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Account_AssetEntry_DoNotUse& other);
  static const Account_AssetEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Account_AssetEntry_DoNotUse*>(&_Account_AssetEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.Account.AssetEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Account_AssetV2Entry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_AssetV2Entry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_AssetV2Entry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  Account_AssetV2Entry_DoNotUse();
  explicit constexpr Account_AssetV2Entry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Account_AssetV2Entry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Account_AssetV2Entry_DoNotUse& other);
  static const Account_AssetV2Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Account_AssetV2Entry_DoNotUse*>(&_Account_AssetV2Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.Account.AssetV2Entry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Account_LatestAssetOperationTimeEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_LatestAssetOperationTimeEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_LatestAssetOperationTimeEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  Account_LatestAssetOperationTimeEntry_DoNotUse();
  explicit constexpr Account_LatestAssetOperationTimeEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Account_LatestAssetOperationTimeEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Account_LatestAssetOperationTimeEntry_DoNotUse& other);
  static const Account_LatestAssetOperationTimeEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Account_LatestAssetOperationTimeEntry_DoNotUse*>(&_Account_LatestAssetOperationTimeEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.Account.LatestAssetOperationTimeEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Account_LatestAssetOperationTimeV2Entry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_LatestAssetOperationTimeV2Entry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_LatestAssetOperationTimeV2Entry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  Account_LatestAssetOperationTimeV2Entry_DoNotUse();
  explicit constexpr Account_LatestAssetOperationTimeV2Entry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Account_LatestAssetOperationTimeV2Entry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Account_LatestAssetOperationTimeV2Entry_DoNotUse& other);
  static const Account_LatestAssetOperationTimeV2Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Account_LatestAssetOperationTimeV2Entry_DoNotUse*>(&_Account_LatestAssetOperationTimeV2Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.Account.LatestAssetOperationTimeV2Entry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Account_FreeAssetNetUsageEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_FreeAssetNetUsageEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_FreeAssetNetUsageEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  Account_FreeAssetNetUsageEntry_DoNotUse();
  explicit constexpr Account_FreeAssetNetUsageEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Account_FreeAssetNetUsageEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Account_FreeAssetNetUsageEntry_DoNotUse& other);
  static const Account_FreeAssetNetUsageEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Account_FreeAssetNetUsageEntry_DoNotUse*>(&_Account_FreeAssetNetUsageEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.Account.FreeAssetNetUsageEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Account_FreeAssetNetUsageV2Entry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_FreeAssetNetUsageV2Entry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_FreeAssetNetUsageV2Entry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  Account_FreeAssetNetUsageV2Entry_DoNotUse();
  explicit constexpr Account_FreeAssetNetUsageV2Entry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Account_FreeAssetNetUsageV2Entry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Account_FreeAssetNetUsageV2Entry_DoNotUse& other);
  static const Account_FreeAssetNetUsageV2Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Account_FreeAssetNetUsageV2Entry_DoNotUse*>(&_Account_FreeAssetNetUsageV2Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.Account.FreeAssetNetUsageV2Entry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Account_AccountResource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Account.AccountResource) */ {
 public:
  inline Account_AccountResource() : Account_AccountResource(nullptr) {}
  ~Account_AccountResource() override;
  explicit constexpr Account_AccountResource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Account_AccountResource(const Account_AccountResource& from);
  Account_AccountResource(Account_AccountResource&& from) noexcept
    : Account_AccountResource() {
    *this = ::std::move(from);
  }

  inline Account_AccountResource& operator=(const Account_AccountResource& from) {
    CopyFrom(from);
    return *this;
  }
  inline Account_AccountResource& operator=(Account_AccountResource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Account_AccountResource& default_instance() {
    return *internal_default_instance();
  }
  static inline const Account_AccountResource* internal_default_instance() {
    return reinterpret_cast<const Account_AccountResource*>(
               &_Account_AccountResource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Account_AccountResource& a, Account_AccountResource& b) {
    a.Swap(&b);
  }
  inline void Swap(Account_AccountResource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Account_AccountResource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Account_AccountResource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Account_AccountResource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Account_AccountResource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Account_AccountResource& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Account_AccountResource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Account.AccountResource";
  }
  protected:
  explicit Account_AccountResource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrozenBalanceForEnergyFieldNumber = 2,
    kEnergyUsageFieldNumber = 1,
    kLatestConsumeTimeForEnergyFieldNumber = 3,
    kAcquiredDelegatedFrozenBalanceForEnergyFieldNumber = 4,
    kDelegatedFrozenBalanceForEnergyFieldNumber = 5,
    kStorageLimitFieldNumber = 6,
    kStorageUsageFieldNumber = 7,
    kLatestExchangeStorageTimeFieldNumber = 8,
  };
  // .protocol.Account.Frozen frozen_balance_for_energy = 2;
  bool has_frozen_balance_for_energy() const;
  private:
  bool _internal_has_frozen_balance_for_energy() const;
  public:
  void clear_frozen_balance_for_energy();
  const ::protocol::Account_Frozen& frozen_balance_for_energy() const;
  PROTOBUF_NODISCARD ::protocol::Account_Frozen* release_frozen_balance_for_energy();
  ::protocol::Account_Frozen* mutable_frozen_balance_for_energy();
  void set_allocated_frozen_balance_for_energy(::protocol::Account_Frozen* frozen_balance_for_energy);
  private:
  const ::protocol::Account_Frozen& _internal_frozen_balance_for_energy() const;
  ::protocol::Account_Frozen* _internal_mutable_frozen_balance_for_energy();
  public:
  void unsafe_arena_set_allocated_frozen_balance_for_energy(
      ::protocol::Account_Frozen* frozen_balance_for_energy);
  ::protocol::Account_Frozen* unsafe_arena_release_frozen_balance_for_energy();

  // int64 energy_usage = 1;
  void clear_energy_usage();
  int64_t energy_usage() const;
  void set_energy_usage(int64_t value);
  private:
  int64_t _internal_energy_usage() const;
  void _internal_set_energy_usage(int64_t value);
  public:

  // int64 latest_consume_time_for_energy = 3;
  void clear_latest_consume_time_for_energy();
  int64_t latest_consume_time_for_energy() const;
  void set_latest_consume_time_for_energy(int64_t value);
  private:
  int64_t _internal_latest_consume_time_for_energy() const;
  void _internal_set_latest_consume_time_for_energy(int64_t value);
  public:

  // int64 acquired_delegated_frozen_balance_for_energy = 4;
  void clear_acquired_delegated_frozen_balance_for_energy();
  int64_t acquired_delegated_frozen_balance_for_energy() const;
  void set_acquired_delegated_frozen_balance_for_energy(int64_t value);
  private:
  int64_t _internal_acquired_delegated_frozen_balance_for_energy() const;
  void _internal_set_acquired_delegated_frozen_balance_for_energy(int64_t value);
  public:

  // int64 delegated_frozen_balance_for_energy = 5;
  void clear_delegated_frozen_balance_for_energy();
  int64_t delegated_frozen_balance_for_energy() const;
  void set_delegated_frozen_balance_for_energy(int64_t value);
  private:
  int64_t _internal_delegated_frozen_balance_for_energy() const;
  void _internal_set_delegated_frozen_balance_for_energy(int64_t value);
  public:

  // int64 storage_limit = 6;
  void clear_storage_limit();
  int64_t storage_limit() const;
  void set_storage_limit(int64_t value);
  private:
  int64_t _internal_storage_limit() const;
  void _internal_set_storage_limit(int64_t value);
  public:

  // int64 storage_usage = 7;
  void clear_storage_usage();
  int64_t storage_usage() const;
  void set_storage_usage(int64_t value);
  private:
  int64_t _internal_storage_usage() const;
  void _internal_set_storage_usage(int64_t value);
  public:

  // int64 latest_exchange_storage_time = 8;
  void clear_latest_exchange_storage_time();
  int64_t latest_exchange_storage_time() const;
  void set_latest_exchange_storage_time(int64_t value);
  private:
  int64_t _internal_latest_exchange_storage_time() const;
  void _internal_set_latest_exchange_storage_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Account.AccountResource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::Account_Frozen* frozen_balance_for_energy_;
  int64_t energy_usage_;
  int64_t latest_consume_time_for_energy_;
  int64_t acquired_delegated_frozen_balance_for_energy_;
  int64_t delegated_frozen_balance_for_energy_;
  int64_t storage_limit_;
  int64_t storage_usage_;
  int64_t latest_exchange_storage_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Account final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Account) */ {
 public:
  inline Account() : Account(nullptr) {}
  ~Account() override;
  explicit constexpr Account(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Account(const Account& from);
  Account(Account&& from) noexcept
    : Account() {
    *this = ::std::move(from);
  }

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  inline Account& operator=(Account&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Account& default_instance() {
    return *internal_default_instance();
  }
  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
               &_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Account& a, Account& b) {
    a.Swap(&b);
  }
  inline void Swap(Account* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Account* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Account* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Account>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Account& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Account& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Account* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Account";
  }
  protected:
  explicit Account(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Account_Frozen Frozen;
  typedef Account_AccountResource AccountResource;

  // accessors -------------------------------------------------------

  enum : int {
    kVotesFieldNumber = 5,
    kAssetFieldNumber = 6,
    kFrozenFieldNumber = 7,
    kFrozenSupplyFieldNumber = 16,
    kLatestAssetOperationTimeFieldNumber = 18,
    kFreeAssetNetUsageFieldNumber = 20,
    kActivePermissionFieldNumber = 33,
    kAssetV2FieldNumber = 56,
    kLatestAssetOperationTimeV2FieldNumber = 58,
    kFreeAssetNetUsageV2FieldNumber = 59,
    kAccountNameFieldNumber = 1,
    kAddressFieldNumber = 3,
    kCodeFieldNumber = 13,
    kAssetIssuedNameFieldNumber = 17,
    kAccountIdFieldNumber = 23,
    kCodeHashFieldNumber = 30,
    kAssetIssuedIDFieldNumber = 57,
    kAccountResourceFieldNumber = 26,
    kOwnerPermissionFieldNumber = 31,
    kWitnessPermissionFieldNumber = 32,
    kTronPowerFieldNumber = 47,
    kBalanceFieldNumber = 4,
    kNetUsageFieldNumber = 8,
    kCreateTimeFieldNumber = 9,
    kLatestOprationTimeFieldNumber = 10,
    kTypeFieldNumber = 2,
    kIsWitnessFieldNumber = 14,
    kIsCommitteeFieldNumber = 15,
    kAllowanceFieldNumber = 11,
    kLatestWithdrawTimeFieldNumber = 12,
    kFreeNetUsageFieldNumber = 19,
    kLatestConsumeTimeFieldNumber = 21,
    kLatestConsumeFreeTimeFieldNumber = 22,
    kAcquiredDelegatedFrozenBalanceForBandwidthFieldNumber = 41,
    kDelegatedFrozenBalanceForBandwidthFieldNumber = 42,
    kOldTronPowerFieldNumber = 46,
  };
  // repeated .protocol.Vote votes = 5;
  int votes_size() const;
  private:
  int _internal_votes_size() const;
  public:
  void clear_votes();
  ::protocol::Vote* mutable_votes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote >*
      mutable_votes();
  private:
  const ::protocol::Vote& _internal_votes(int index) const;
  ::protocol::Vote* _internal_add_votes();
  public:
  const ::protocol::Vote& votes(int index) const;
  ::protocol::Vote* add_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote >&
      votes() const;

  // map<string, int64> asset = 6;
  int asset_size() const;
  private:
  int _internal_asset_size() const;
  public:
  void clear_asset();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_asset() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_asset();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      asset() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_asset();

  // repeated .protocol.Account.Frozen frozen = 7;
  int frozen_size() const;
  private:
  int _internal_frozen_size() const;
  public:
  void clear_frozen();
  ::protocol::Account_Frozen* mutable_frozen(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Account_Frozen >*
      mutable_frozen();
  private:
  const ::protocol::Account_Frozen& _internal_frozen(int index) const;
  ::protocol::Account_Frozen* _internal_add_frozen();
  public:
  const ::protocol::Account_Frozen& frozen(int index) const;
  ::protocol::Account_Frozen* add_frozen();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Account_Frozen >&
      frozen() const;

  // repeated .protocol.Account.Frozen frozen_supply = 16;
  int frozen_supply_size() const;
  private:
  int _internal_frozen_supply_size() const;
  public:
  void clear_frozen_supply();
  ::protocol::Account_Frozen* mutable_frozen_supply(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Account_Frozen >*
      mutable_frozen_supply();
  private:
  const ::protocol::Account_Frozen& _internal_frozen_supply(int index) const;
  ::protocol::Account_Frozen* _internal_add_frozen_supply();
  public:
  const ::protocol::Account_Frozen& frozen_supply(int index) const;
  ::protocol::Account_Frozen* add_frozen_supply();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Account_Frozen >&
      frozen_supply() const;

  // map<string, int64> latest_asset_operation_time = 18;
  int latest_asset_operation_time_size() const;
  private:
  int _internal_latest_asset_operation_time_size() const;
  public:
  void clear_latest_asset_operation_time();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_latest_asset_operation_time() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_latest_asset_operation_time();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      latest_asset_operation_time() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_latest_asset_operation_time();

  // map<string, int64> free_asset_net_usage = 20;
  int free_asset_net_usage_size() const;
  private:
  int _internal_free_asset_net_usage_size() const;
  public:
  void clear_free_asset_net_usage();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_free_asset_net_usage() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_free_asset_net_usage();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      free_asset_net_usage() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_free_asset_net_usage();

  // repeated .protocol.Permission active_permission = 33;
  int active_permission_size() const;
  private:
  int _internal_active_permission_size() const;
  public:
  void clear_active_permission();
  ::protocol::Permission* mutable_active_permission(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Permission >*
      mutable_active_permission();
  private:
  const ::protocol::Permission& _internal_active_permission(int index) const;
  ::protocol::Permission* _internal_add_active_permission();
  public:
  const ::protocol::Permission& active_permission(int index) const;
  ::protocol::Permission* add_active_permission();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Permission >&
      active_permission() const;

  // map<string, int64> assetV2 = 56;
  int assetv2_size() const;
  private:
  int _internal_assetv2_size() const;
  public:
  void clear_assetv2();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_assetv2() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_assetv2();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      assetv2() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_assetv2();

  // map<string, int64> latest_asset_operation_timeV2 = 58;
  int latest_asset_operation_timev2_size() const;
  private:
  int _internal_latest_asset_operation_timev2_size() const;
  public:
  void clear_latest_asset_operation_timev2();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_latest_asset_operation_timev2() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_latest_asset_operation_timev2();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      latest_asset_operation_timev2() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_latest_asset_operation_timev2();

  // map<string, int64> free_asset_net_usageV2 = 59;
  int free_asset_net_usagev2_size() const;
  private:
  int _internal_free_asset_net_usagev2_size() const;
  public:
  void clear_free_asset_net_usagev2();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_free_asset_net_usagev2() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_free_asset_net_usagev2();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      free_asset_net_usagev2() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_free_asset_net_usagev2();

  // bytes account_name = 1;
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // bytes address = 3;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bytes code = 13;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // bytes asset_issued_name = 17;
  void clear_asset_issued_name();
  const std::string& asset_issued_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_issued_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_issued_name();
  PROTOBUF_NODISCARD std::string* release_asset_issued_name();
  void set_allocated_asset_issued_name(std::string* asset_issued_name);
  private:
  const std::string& _internal_asset_issued_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_issued_name(const std::string& value);
  std::string* _internal_mutable_asset_issued_name();
  public:

  // bytes account_id = 23;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // bytes codeHash = 30;
  void clear_codehash();
  const std::string& codehash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_codehash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_codehash();
  PROTOBUF_NODISCARD std::string* release_codehash();
  void set_allocated_codehash(std::string* codehash);
  private:
  const std::string& _internal_codehash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codehash(const std::string& value);
  std::string* _internal_mutable_codehash();
  public:

  // bytes asset_issued_ID = 57;
  void clear_asset_issued_id();
  const std::string& asset_issued_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_issued_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_issued_id();
  PROTOBUF_NODISCARD std::string* release_asset_issued_id();
  void set_allocated_asset_issued_id(std::string* asset_issued_id);
  private:
  const std::string& _internal_asset_issued_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_issued_id(const std::string& value);
  std::string* _internal_mutable_asset_issued_id();
  public:

  // .protocol.Account.AccountResource account_resource = 26;
  bool has_account_resource() const;
  private:
  bool _internal_has_account_resource() const;
  public:
  void clear_account_resource();
  const ::protocol::Account_AccountResource& account_resource() const;
  PROTOBUF_NODISCARD ::protocol::Account_AccountResource* release_account_resource();
  ::protocol::Account_AccountResource* mutable_account_resource();
  void set_allocated_account_resource(::protocol::Account_AccountResource* account_resource);
  private:
  const ::protocol::Account_AccountResource& _internal_account_resource() const;
  ::protocol::Account_AccountResource* _internal_mutable_account_resource();
  public:
  void unsafe_arena_set_allocated_account_resource(
      ::protocol::Account_AccountResource* account_resource);
  ::protocol::Account_AccountResource* unsafe_arena_release_account_resource();

  // .protocol.Permission owner_permission = 31;
  bool has_owner_permission() const;
  private:
  bool _internal_has_owner_permission() const;
  public:
  void clear_owner_permission();
  const ::protocol::Permission& owner_permission() const;
  PROTOBUF_NODISCARD ::protocol::Permission* release_owner_permission();
  ::protocol::Permission* mutable_owner_permission();
  void set_allocated_owner_permission(::protocol::Permission* owner_permission);
  private:
  const ::protocol::Permission& _internal_owner_permission() const;
  ::protocol::Permission* _internal_mutable_owner_permission();
  public:
  void unsafe_arena_set_allocated_owner_permission(
      ::protocol::Permission* owner_permission);
  ::protocol::Permission* unsafe_arena_release_owner_permission();

  // .protocol.Permission witness_permission = 32;
  bool has_witness_permission() const;
  private:
  bool _internal_has_witness_permission() const;
  public:
  void clear_witness_permission();
  const ::protocol::Permission& witness_permission() const;
  PROTOBUF_NODISCARD ::protocol::Permission* release_witness_permission();
  ::protocol::Permission* mutable_witness_permission();
  void set_allocated_witness_permission(::protocol::Permission* witness_permission);
  private:
  const ::protocol::Permission& _internal_witness_permission() const;
  ::protocol::Permission* _internal_mutable_witness_permission();
  public:
  void unsafe_arena_set_allocated_witness_permission(
      ::protocol::Permission* witness_permission);
  ::protocol::Permission* unsafe_arena_release_witness_permission();

  // .protocol.Account.Frozen tron_power = 47;
  bool has_tron_power() const;
  private:
  bool _internal_has_tron_power() const;
  public:
  void clear_tron_power();
  const ::protocol::Account_Frozen& tron_power() const;
  PROTOBUF_NODISCARD ::protocol::Account_Frozen* release_tron_power();
  ::protocol::Account_Frozen* mutable_tron_power();
  void set_allocated_tron_power(::protocol::Account_Frozen* tron_power);
  private:
  const ::protocol::Account_Frozen& _internal_tron_power() const;
  ::protocol::Account_Frozen* _internal_mutable_tron_power();
  public:
  void unsafe_arena_set_allocated_tron_power(
      ::protocol::Account_Frozen* tron_power);
  ::protocol::Account_Frozen* unsafe_arena_release_tron_power();

  // int64 balance = 4;
  void clear_balance();
  int64_t balance() const;
  void set_balance(int64_t value);
  private:
  int64_t _internal_balance() const;
  void _internal_set_balance(int64_t value);
  public:

  // int64 net_usage = 8;
  void clear_net_usage();
  int64_t net_usage() const;
  void set_net_usage(int64_t value);
  private:
  int64_t _internal_net_usage() const;
  void _internal_set_net_usage(int64_t value);
  public:

  // int64 create_time = 9;
  void clear_create_time();
  int64_t create_time() const;
  void set_create_time(int64_t value);
  private:
  int64_t _internal_create_time() const;
  void _internal_set_create_time(int64_t value);
  public:

  // int64 latest_opration_time = 10;
  void clear_latest_opration_time();
  int64_t latest_opration_time() const;
  void set_latest_opration_time(int64_t value);
  private:
  int64_t _internal_latest_opration_time() const;
  void _internal_set_latest_opration_time(int64_t value);
  public:

  // .protocol.AccountType type = 2;
  void clear_type();
  ::protocol::AccountType type() const;
  void set_type(::protocol::AccountType value);
  private:
  ::protocol::AccountType _internal_type() const;
  void _internal_set_type(::protocol::AccountType value);
  public:

  // bool is_witness = 14;
  void clear_is_witness();
  bool is_witness() const;
  void set_is_witness(bool value);
  private:
  bool _internal_is_witness() const;
  void _internal_set_is_witness(bool value);
  public:

  // bool is_committee = 15;
  void clear_is_committee();
  bool is_committee() const;
  void set_is_committee(bool value);
  private:
  bool _internal_is_committee() const;
  void _internal_set_is_committee(bool value);
  public:

  // int64 allowance = 11;
  void clear_allowance();
  int64_t allowance() const;
  void set_allowance(int64_t value);
  private:
  int64_t _internal_allowance() const;
  void _internal_set_allowance(int64_t value);
  public:

  // int64 latest_withdraw_time = 12;
  void clear_latest_withdraw_time();
  int64_t latest_withdraw_time() const;
  void set_latest_withdraw_time(int64_t value);
  private:
  int64_t _internal_latest_withdraw_time() const;
  void _internal_set_latest_withdraw_time(int64_t value);
  public:

  // int64 free_net_usage = 19;
  void clear_free_net_usage();
  int64_t free_net_usage() const;
  void set_free_net_usage(int64_t value);
  private:
  int64_t _internal_free_net_usage() const;
  void _internal_set_free_net_usage(int64_t value);
  public:

  // int64 latest_consume_time = 21;
  void clear_latest_consume_time();
  int64_t latest_consume_time() const;
  void set_latest_consume_time(int64_t value);
  private:
  int64_t _internal_latest_consume_time() const;
  void _internal_set_latest_consume_time(int64_t value);
  public:

  // int64 latest_consume_free_time = 22;
  void clear_latest_consume_free_time();
  int64_t latest_consume_free_time() const;
  void set_latest_consume_free_time(int64_t value);
  private:
  int64_t _internal_latest_consume_free_time() const;
  void _internal_set_latest_consume_free_time(int64_t value);
  public:

  // int64 acquired_delegated_frozen_balance_for_bandwidth = 41;
  void clear_acquired_delegated_frozen_balance_for_bandwidth();
  int64_t acquired_delegated_frozen_balance_for_bandwidth() const;
  void set_acquired_delegated_frozen_balance_for_bandwidth(int64_t value);
  private:
  int64_t _internal_acquired_delegated_frozen_balance_for_bandwidth() const;
  void _internal_set_acquired_delegated_frozen_balance_for_bandwidth(int64_t value);
  public:

  // int64 delegated_frozen_balance_for_bandwidth = 42;
  void clear_delegated_frozen_balance_for_bandwidth();
  int64_t delegated_frozen_balance_for_bandwidth() const;
  void set_delegated_frozen_balance_for_bandwidth(int64_t value);
  private:
  int64_t _internal_delegated_frozen_balance_for_bandwidth() const;
  void _internal_set_delegated_frozen_balance_for_bandwidth(int64_t value);
  public:

  // int64 old_tron_power = 46;
  void clear_old_tron_power();
  int64_t old_tron_power() const;
  void set_old_tron_power(int64_t value);
  private:
  int64_t _internal_old_tron_power() const;
  void _internal_set_old_tron_power(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Account)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote > votes_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Account_AssetEntry_DoNotUse,
      std::string, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> asset_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Account_Frozen > frozen_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Account_Frozen > frozen_supply_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Account_LatestAssetOperationTimeEntry_DoNotUse,
      std::string, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> latest_asset_operation_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Account_FreeAssetNetUsageEntry_DoNotUse,
      std::string, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> free_asset_net_usage_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Permission > active_permission_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Account_AssetV2Entry_DoNotUse,
      std::string, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> assetv2_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Account_LatestAssetOperationTimeV2Entry_DoNotUse,
      std::string, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> latest_asset_operation_timev2_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Account_FreeAssetNetUsageV2Entry_DoNotUse,
      std::string, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> free_asset_net_usagev2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_issued_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codehash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_issued_id_;
  ::protocol::Account_AccountResource* account_resource_;
  ::protocol::Permission* owner_permission_;
  ::protocol::Permission* witness_permission_;
  ::protocol::Account_Frozen* tron_power_;
  int64_t balance_;
  int64_t net_usage_;
  int64_t create_time_;
  int64_t latest_opration_time_;
  int type_;
  bool is_witness_;
  bool is_committee_;
  int64_t allowance_;
  int64_t latest_withdraw_time_;
  int64_t free_net_usage_;
  int64_t latest_consume_time_;
  int64_t latest_consume_free_time_;
  int64_t acquired_delegated_frozen_balance_for_bandwidth_;
  int64_t delegated_frozen_balance_for_bandwidth_;
  int64_t old_tron_power_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class AccountAsset_Frozen final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountAsset.Frozen) */ {
 public:
  inline AccountAsset_Frozen() : AccountAsset_Frozen(nullptr) {}
  ~AccountAsset_Frozen() override;
  explicit constexpr AccountAsset_Frozen(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountAsset_Frozen(const AccountAsset_Frozen& from);
  AccountAsset_Frozen(AccountAsset_Frozen&& from) noexcept
    : AccountAsset_Frozen() {
    *this = ::std::move(from);
  }

  inline AccountAsset_Frozen& operator=(const AccountAsset_Frozen& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountAsset_Frozen& operator=(AccountAsset_Frozen&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountAsset_Frozen& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountAsset_Frozen* internal_default_instance() {
    return reinterpret_cast<const AccountAsset_Frozen*>(
               &_AccountAsset_Frozen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AccountAsset_Frozen& a, AccountAsset_Frozen& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountAsset_Frozen* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountAsset_Frozen* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountAsset_Frozen* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountAsset_Frozen>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountAsset_Frozen& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountAsset_Frozen& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountAsset_Frozen* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountAsset.Frozen";
  }
  protected:
  explicit AccountAsset_Frozen(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrozenBalanceFieldNumber = 1,
    kExpireTimeFieldNumber = 2,
  };
  // int64 frozen_balance = 1;
  void clear_frozen_balance();
  int64_t frozen_balance() const;
  void set_frozen_balance(int64_t value);
  private:
  int64_t _internal_frozen_balance() const;
  void _internal_set_frozen_balance(int64_t value);
  public:

  // int64 expire_time = 2;
  void clear_expire_time();
  int64_t expire_time() const;
  void set_expire_time(int64_t value);
  private:
  int64_t _internal_expire_time() const;
  void _internal_set_expire_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.AccountAsset.Frozen)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t frozen_balance_;
  int64_t expire_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class AccountAsset_AssetEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountAsset_AssetEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountAsset_AssetEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  AccountAsset_AssetEntry_DoNotUse();
  explicit constexpr AccountAsset_AssetEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AccountAsset_AssetEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AccountAsset_AssetEntry_DoNotUse& other);
  static const AccountAsset_AssetEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AccountAsset_AssetEntry_DoNotUse*>(&_AccountAsset_AssetEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.AccountAsset.AssetEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AccountAsset_AssetV2Entry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountAsset_AssetV2Entry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountAsset_AssetV2Entry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  AccountAsset_AssetV2Entry_DoNotUse();
  explicit constexpr AccountAsset_AssetV2Entry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AccountAsset_AssetV2Entry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AccountAsset_AssetV2Entry_DoNotUse& other);
  static const AccountAsset_AssetV2Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AccountAsset_AssetV2Entry_DoNotUse*>(&_AccountAsset_AssetV2Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.AccountAsset.AssetV2Entry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AccountAsset_LatestAssetOperationTimeEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountAsset_LatestAssetOperationTimeEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountAsset_LatestAssetOperationTimeEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  AccountAsset_LatestAssetOperationTimeEntry_DoNotUse();
  explicit constexpr AccountAsset_LatestAssetOperationTimeEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AccountAsset_LatestAssetOperationTimeEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AccountAsset_LatestAssetOperationTimeEntry_DoNotUse& other);
  static const AccountAsset_LatestAssetOperationTimeEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AccountAsset_LatestAssetOperationTimeEntry_DoNotUse*>(&_AccountAsset_LatestAssetOperationTimeEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.AccountAsset.LatestAssetOperationTimeEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse();
  explicit constexpr AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse& other);
  static const AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse*>(&_AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.AccountAsset.LatestAssetOperationTimeV2Entry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AccountAsset_FreeAssetNetUsageEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountAsset_FreeAssetNetUsageEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountAsset_FreeAssetNetUsageEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  AccountAsset_FreeAssetNetUsageEntry_DoNotUse();
  explicit constexpr AccountAsset_FreeAssetNetUsageEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AccountAsset_FreeAssetNetUsageEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AccountAsset_FreeAssetNetUsageEntry_DoNotUse& other);
  static const AccountAsset_FreeAssetNetUsageEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AccountAsset_FreeAssetNetUsageEntry_DoNotUse*>(&_AccountAsset_FreeAssetNetUsageEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.AccountAsset.FreeAssetNetUsageEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse();
  explicit constexpr AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse& other);
  static const AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse*>(&_AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.AccountAsset.FreeAssetNetUsageV2Entry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AccountAsset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.AccountAsset) */ {
 public:
  inline AccountAsset() : AccountAsset(nullptr) {}
  ~AccountAsset() override;
  explicit constexpr AccountAsset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountAsset(const AccountAsset& from);
  AccountAsset(AccountAsset&& from) noexcept
    : AccountAsset() {
    *this = ::std::move(from);
  }

  inline AccountAsset& operator=(const AccountAsset& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountAsset& operator=(AccountAsset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountAsset& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountAsset* internal_default_instance() {
    return reinterpret_cast<const AccountAsset*>(
               &_AccountAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AccountAsset& a, AccountAsset& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountAsset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountAsset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountAsset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountAsset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountAsset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountAsset& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountAsset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.AccountAsset";
  }
  protected:
  explicit AccountAsset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AccountAsset_Frozen Frozen;

  // accessors -------------------------------------------------------

  enum : int {
    kAssetFieldNumber = 2,
    kAssetV2FieldNumber = 3,
    kLatestAssetOperationTimeFieldNumber = 6,
    kLatestAssetOperationTimeV2FieldNumber = 7,
    kFreeAssetNetUsageFieldNumber = 8,
    kFreeAssetNetUsageV2FieldNumber = 9,
    kFrozenSupplyFieldNumber = 10,
    kAddressFieldNumber = 1,
    kAssetIssuedNameFieldNumber = 4,
    kAssetIssuedIDFieldNumber = 5,
  };
  // map<string, int64> asset = 2;
  int asset_size() const;
  private:
  int _internal_asset_size() const;
  public:
  void clear_asset();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_asset() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_asset();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      asset() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_asset();

  // map<string, int64> assetV2 = 3;
  int assetv2_size() const;
  private:
  int _internal_assetv2_size() const;
  public:
  void clear_assetv2();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_assetv2() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_assetv2();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      assetv2() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_assetv2();

  // map<string, int64> latest_asset_operation_time = 6;
  int latest_asset_operation_time_size() const;
  private:
  int _internal_latest_asset_operation_time_size() const;
  public:
  void clear_latest_asset_operation_time();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_latest_asset_operation_time() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_latest_asset_operation_time();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      latest_asset_operation_time() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_latest_asset_operation_time();

  // map<string, int64> latest_asset_operation_timeV2 = 7;
  int latest_asset_operation_timev2_size() const;
  private:
  int _internal_latest_asset_operation_timev2_size() const;
  public:
  void clear_latest_asset_operation_timev2();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_latest_asset_operation_timev2() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_latest_asset_operation_timev2();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      latest_asset_operation_timev2() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_latest_asset_operation_timev2();

  // map<string, int64> free_asset_net_usage = 8;
  int free_asset_net_usage_size() const;
  private:
  int _internal_free_asset_net_usage_size() const;
  public:
  void clear_free_asset_net_usage();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_free_asset_net_usage() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_free_asset_net_usage();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      free_asset_net_usage() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_free_asset_net_usage();

  // map<string, int64> free_asset_net_usageV2 = 9;
  int free_asset_net_usagev2_size() const;
  private:
  int _internal_free_asset_net_usagev2_size() const;
  public:
  void clear_free_asset_net_usagev2();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_free_asset_net_usagev2() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_free_asset_net_usagev2();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      free_asset_net_usagev2() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_free_asset_net_usagev2();

  // repeated .protocol.AccountAsset.Frozen frozen_supply = 10;
  int frozen_supply_size() const;
  private:
  int _internal_frozen_supply_size() const;
  public:
  void clear_frozen_supply();
  ::protocol::AccountAsset_Frozen* mutable_frozen_supply(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AccountAsset_Frozen >*
      mutable_frozen_supply();
  private:
  const ::protocol::AccountAsset_Frozen& _internal_frozen_supply(int index) const;
  ::protocol::AccountAsset_Frozen* _internal_add_frozen_supply();
  public:
  const ::protocol::AccountAsset_Frozen& frozen_supply(int index) const;
  ::protocol::AccountAsset_Frozen* add_frozen_supply();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AccountAsset_Frozen >&
      frozen_supply() const;

  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bytes asset_issued_name = 4;
  void clear_asset_issued_name();
  const std::string& asset_issued_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_issued_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_issued_name();
  PROTOBUF_NODISCARD std::string* release_asset_issued_name();
  void set_allocated_asset_issued_name(std::string* asset_issued_name);
  private:
  const std::string& _internal_asset_issued_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_issued_name(const std::string& value);
  std::string* _internal_mutable_asset_issued_name();
  public:

  // bytes asset_issued_ID = 5;
  void clear_asset_issued_id();
  const std::string& asset_issued_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_issued_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_issued_id();
  PROTOBUF_NODISCARD std::string* release_asset_issued_id();
  void set_allocated_asset_issued_id(std::string* asset_issued_id);
  private:
  const std::string& _internal_asset_issued_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_issued_id(const std::string& value);
  std::string* _internal_mutable_asset_issued_id();
  public:

  // @@protoc_insertion_point(class_scope:protocol.AccountAsset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AccountAsset_AssetEntry_DoNotUse,
      std::string, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> asset_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AccountAsset_AssetV2Entry_DoNotUse,
      std::string, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> assetv2_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AccountAsset_LatestAssetOperationTimeEntry_DoNotUse,
      std::string, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> latest_asset_operation_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AccountAsset_LatestAssetOperationTimeV2Entry_DoNotUse,
      std::string, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> latest_asset_operation_timev2_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AccountAsset_FreeAssetNetUsageEntry_DoNotUse,
      std::string, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> free_asset_net_usage_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AccountAsset_FreeAssetNetUsageV2Entry_DoNotUse,
      std::string, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> free_asset_net_usagev2_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AccountAsset_Frozen > frozen_supply_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_issued_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_issued_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Key final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Key) */ {
 public:
  inline Key() : Key(nullptr) {}
  ~Key() override;
  explicit constexpr Key(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Key(const Key& from);
  Key(Key&& from) noexcept
    : Key() {
    *this = ::std::move(from);
  }

  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }
  inline Key& operator=(Key&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Key& default_instance() {
    return *internal_default_instance();
  }
  static inline const Key* internal_default_instance() {
    return reinterpret_cast<const Key*>(
               &_Key_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Key& a, Key& b) {
    a.Swap(&b);
  }
  inline void Swap(Key* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Key* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Key* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Key>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Key& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Key& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Key* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Key";
  }
  protected:
  explicit Key(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kWeightFieldNumber = 2,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // int64 weight = 2;
  void clear_weight();
  int64_t weight() const;
  void set_weight(int64_t value);
  private:
  int64_t _internal_weight() const;
  void _internal_set_weight(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Key)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  int64_t weight_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class DelegatedResource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DelegatedResource) */ {
 public:
  inline DelegatedResource() : DelegatedResource(nullptr) {}
  ~DelegatedResource() override;
  explicit constexpr DelegatedResource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegatedResource(const DelegatedResource& from);
  DelegatedResource(DelegatedResource&& from) noexcept
    : DelegatedResource() {
    *this = ::std::move(from);
  }

  inline DelegatedResource& operator=(const DelegatedResource& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegatedResource& operator=(DelegatedResource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegatedResource& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegatedResource* internal_default_instance() {
    return reinterpret_cast<const DelegatedResource*>(
               &_DelegatedResource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(DelegatedResource& a, DelegatedResource& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegatedResource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegatedResource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelegatedResource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelegatedResource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegatedResource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DelegatedResource& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegatedResource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DelegatedResource";
  }
  protected:
  explicit DelegatedResource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kFrozenBalanceForBandwidthFieldNumber = 3,
    kFrozenBalanceForEnergyFieldNumber = 4,
    kExpireTimeForBandwidthFieldNumber = 5,
    kExpireTimeForEnergyFieldNumber = 6,
  };
  // bytes from = 1;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // bytes to = 2;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // int64 frozen_balance_for_bandwidth = 3;
  void clear_frozen_balance_for_bandwidth();
  int64_t frozen_balance_for_bandwidth() const;
  void set_frozen_balance_for_bandwidth(int64_t value);
  private:
  int64_t _internal_frozen_balance_for_bandwidth() const;
  void _internal_set_frozen_balance_for_bandwidth(int64_t value);
  public:

  // int64 frozen_balance_for_energy = 4;
  void clear_frozen_balance_for_energy();
  int64_t frozen_balance_for_energy() const;
  void set_frozen_balance_for_energy(int64_t value);
  private:
  int64_t _internal_frozen_balance_for_energy() const;
  void _internal_set_frozen_balance_for_energy(int64_t value);
  public:

  // int64 expire_time_for_bandwidth = 5;
  void clear_expire_time_for_bandwidth();
  int64_t expire_time_for_bandwidth() const;
  void set_expire_time_for_bandwidth(int64_t value);
  private:
  int64_t _internal_expire_time_for_bandwidth() const;
  void _internal_set_expire_time_for_bandwidth(int64_t value);
  public:

  // int64 expire_time_for_energy = 6;
  void clear_expire_time_for_energy();
  int64_t expire_time_for_energy() const;
  void set_expire_time_for_energy(int64_t value);
  private:
  int64_t _internal_expire_time_for_energy() const;
  void _internal_set_expire_time_for_energy(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.DelegatedResource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  int64_t frozen_balance_for_bandwidth_;
  int64_t frozen_balance_for_energy_;
  int64_t expire_time_for_bandwidth_;
  int64_t expire_time_for_energy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class authority final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.authority) */ {
 public:
  inline authority() : authority(nullptr) {}
  ~authority() override;
  explicit constexpr authority(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  authority(const authority& from);
  authority(authority&& from) noexcept
    : authority() {
    *this = ::std::move(from);
  }

  inline authority& operator=(const authority& from) {
    CopyFrom(from);
    return *this;
  }
  inline authority& operator=(authority&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const authority& default_instance() {
    return *internal_default_instance();
  }
  static inline const authority* internal_default_instance() {
    return reinterpret_cast<const authority*>(
               &_authority_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(authority& a, authority& b) {
    a.Swap(&b);
  }
  inline void Swap(authority* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(authority* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  authority* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<authority>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const authority& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const authority& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(authority* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.authority";
  }
  protected:
  explicit authority(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionNameFieldNumber = 2,
    kAccountFieldNumber = 1,
  };
  // bytes permission_name = 2;
  void clear_permission_name();
  const std::string& permission_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission_name();
  PROTOBUF_NODISCARD std::string* release_permission_name();
  void set_allocated_permission_name(std::string* permission_name);
  private:
  const std::string& _internal_permission_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission_name(const std::string& value);
  std::string* _internal_mutable_permission_name();
  public:

  // .protocol.AccountId account = 1;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const ::protocol::AccountId& account() const;
  PROTOBUF_NODISCARD ::protocol::AccountId* release_account();
  ::protocol::AccountId* mutable_account();
  void set_allocated_account(::protocol::AccountId* account);
  private:
  const ::protocol::AccountId& _internal_account() const;
  ::protocol::AccountId* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      ::protocol::AccountId* account);
  ::protocol::AccountId* unsafe_arena_release_account();

  // @@protoc_insertion_point(class_scope:protocol.authority)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_name_;
  ::protocol::AccountId* account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Permission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Permission) */ {
 public:
  inline Permission() : Permission(nullptr) {}
  ~Permission() override;
  explicit constexpr Permission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Permission(const Permission& from);
  Permission(Permission&& from) noexcept
    : Permission() {
    *this = ::std::move(from);
  }

  inline Permission& operator=(const Permission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Permission& operator=(Permission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Permission& default_instance() {
    return *internal_default_instance();
  }
  static inline const Permission* internal_default_instance() {
    return reinterpret_cast<const Permission*>(
               &_Permission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(Permission& a, Permission& b) {
    a.Swap(&b);
  }
  inline void Swap(Permission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Permission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Permission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Permission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Permission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Permission& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Permission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Permission";
  }
  protected:
  explicit Permission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Permission_PermissionType PermissionType;
  static constexpr PermissionType Owner =
    Permission_PermissionType_Owner;
  static constexpr PermissionType Witness =
    Permission_PermissionType_Witness;
  static constexpr PermissionType Active =
    Permission_PermissionType_Active;
  static inline bool PermissionType_IsValid(int value) {
    return Permission_PermissionType_IsValid(value);
  }
  static constexpr PermissionType PermissionType_MIN =
    Permission_PermissionType_PermissionType_MIN;
  static constexpr PermissionType PermissionType_MAX =
    Permission_PermissionType_PermissionType_MAX;
  static constexpr int PermissionType_ARRAYSIZE =
    Permission_PermissionType_PermissionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PermissionType_descriptor() {
    return Permission_PermissionType_descriptor();
  }
  template<typename T>
  static inline const std::string& PermissionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PermissionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PermissionType_Name.");
    return Permission_PermissionType_Name(enum_t_value);
  }
  static inline bool PermissionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PermissionType* value) {
    return Permission_PermissionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 7,
    kPermissionNameFieldNumber = 3,
    kOperationsFieldNumber = 6,
    kTypeFieldNumber = 1,
    kIdFieldNumber = 2,
    kThresholdFieldNumber = 4,
    kParentIdFieldNumber = 5,
  };
  // repeated .protocol.Key keys = 7;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::protocol::Key* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Key >*
      mutable_keys();
  private:
  const ::protocol::Key& _internal_keys(int index) const;
  ::protocol::Key* _internal_add_keys();
  public:
  const ::protocol::Key& keys(int index) const;
  ::protocol::Key* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Key >&
      keys() const;

  // string permission_name = 3;
  void clear_permission_name();
  const std::string& permission_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission_name();
  PROTOBUF_NODISCARD std::string* release_permission_name();
  void set_allocated_permission_name(std::string* permission_name);
  private:
  const std::string& _internal_permission_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission_name(const std::string& value);
  std::string* _internal_mutable_permission_name();
  public:

  // bytes operations = 6;
  void clear_operations();
  const std::string& operations() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operations(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operations();
  PROTOBUF_NODISCARD std::string* release_operations();
  void set_allocated_operations(std::string* operations);
  private:
  const std::string& _internal_operations() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operations(const std::string& value);
  std::string* _internal_mutable_operations();
  public:

  // .protocol.Permission.PermissionType type = 1;
  void clear_type();
  ::protocol::Permission_PermissionType type() const;
  void set_type(::protocol::Permission_PermissionType value);
  private:
  ::protocol::Permission_PermissionType _internal_type() const;
  void _internal_set_type(::protocol::Permission_PermissionType value);
  public:

  // int32 id = 2;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int64 threshold = 4;
  void clear_threshold();
  int64_t threshold() const;
  void set_threshold(int64_t value);
  private:
  int64_t _internal_threshold() const;
  void _internal_set_threshold(int64_t value);
  public:

  // int32 parent_id = 5;
  void clear_parent_id();
  int32_t parent_id() const;
  void set_parent_id(int32_t value);
  private:
  int32_t _internal_parent_id() const;
  void _internal_set_parent_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Permission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Key > keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operations_;
  int type_;
  int32_t id_;
  int64_t threshold_;
  int32_t parent_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Witness final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Witness) */ {
 public:
  inline Witness() : Witness(nullptr) {}
  ~Witness() override;
  explicit constexpr Witness(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Witness(const Witness& from);
  Witness(Witness&& from) noexcept
    : Witness() {
    *this = ::std::move(from);
  }

  inline Witness& operator=(const Witness& from) {
    CopyFrom(from);
    return *this;
  }
  inline Witness& operator=(Witness&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Witness& default_instance() {
    return *internal_default_instance();
  }
  static inline const Witness* internal_default_instance() {
    return reinterpret_cast<const Witness*>(
               &_Witness_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Witness& a, Witness& b) {
    a.Swap(&b);
  }
  inline void Swap(Witness* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Witness* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Witness* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Witness>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Witness& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Witness& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Witness* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Witness";
  }
  protected:
  explicit Witness(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPubKeyFieldNumber = 3,
    kUrlFieldNumber = 4,
    kVoteCountFieldNumber = 2,
    kTotalProducedFieldNumber = 5,
    kTotalMissedFieldNumber = 6,
    kLatestBlockNumFieldNumber = 7,
    kLatestSlotNumFieldNumber = 8,
    kIsJobsFieldNumber = 9,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bytes pubKey = 3;
  void clear_pubkey();
  const std::string& pubkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pubkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pubkey();
  PROTOBUF_NODISCARD std::string* release_pubkey();
  void set_allocated_pubkey(std::string* pubkey);
  private:
  const std::string& _internal_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pubkey(const std::string& value);
  std::string* _internal_mutable_pubkey();
  public:

  // string url = 4;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // int64 voteCount = 2;
  void clear_votecount();
  int64_t votecount() const;
  void set_votecount(int64_t value);
  private:
  int64_t _internal_votecount() const;
  void _internal_set_votecount(int64_t value);
  public:

  // int64 totalProduced = 5;
  void clear_totalproduced();
  int64_t totalproduced() const;
  void set_totalproduced(int64_t value);
  private:
  int64_t _internal_totalproduced() const;
  void _internal_set_totalproduced(int64_t value);
  public:

  // int64 totalMissed = 6;
  void clear_totalmissed();
  int64_t totalmissed() const;
  void set_totalmissed(int64_t value);
  private:
  int64_t _internal_totalmissed() const;
  void _internal_set_totalmissed(int64_t value);
  public:

  // int64 latestBlockNum = 7;
  void clear_latestblocknum();
  int64_t latestblocknum() const;
  void set_latestblocknum(int64_t value);
  private:
  int64_t _internal_latestblocknum() const;
  void _internal_set_latestblocknum(int64_t value);
  public:

  // int64 latestSlotNum = 8;
  void clear_latestslotnum();
  int64_t latestslotnum() const;
  void set_latestslotnum(int64_t value);
  private:
  int64_t _internal_latestslotnum() const;
  void _internal_set_latestslotnum(int64_t value);
  public:

  // bool isJobs = 9;
  void clear_isjobs();
  bool isjobs() const;
  void set_isjobs(bool value);
  private:
  bool _internal_isjobs() const;
  void _internal_set_isjobs(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Witness)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pubkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  int64_t votecount_;
  int64_t totalproduced_;
  int64_t totalmissed_;
  int64_t latestblocknum_;
  int64_t latestslotnum_;
  bool isjobs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Votes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Votes) */ {
 public:
  inline Votes() : Votes(nullptr) {}
  ~Votes() override;
  explicit constexpr Votes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Votes(const Votes& from);
  Votes(Votes&& from) noexcept
    : Votes() {
    *this = ::std::move(from);
  }

  inline Votes& operator=(const Votes& from) {
    CopyFrom(from);
    return *this;
  }
  inline Votes& operator=(Votes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Votes& default_instance() {
    return *internal_default_instance();
  }
  static inline const Votes* internal_default_instance() {
    return reinterpret_cast<const Votes*>(
               &_Votes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Votes& a, Votes& b) {
    a.Swap(&b);
  }
  inline void Swap(Votes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Votes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Votes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Votes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Votes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Votes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Votes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Votes";
  }
  protected:
  explicit Votes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldVotesFieldNumber = 2,
    kNewVotesFieldNumber = 3,
    kAddressFieldNumber = 1,
  };
  // repeated .protocol.Vote old_votes = 2;
  int old_votes_size() const;
  private:
  int _internal_old_votes_size() const;
  public:
  void clear_old_votes();
  ::protocol::Vote* mutable_old_votes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote >*
      mutable_old_votes();
  private:
  const ::protocol::Vote& _internal_old_votes(int index) const;
  ::protocol::Vote* _internal_add_old_votes();
  public:
  const ::protocol::Vote& old_votes(int index) const;
  ::protocol::Vote* add_old_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote >&
      old_votes() const;

  // repeated .protocol.Vote new_votes = 3;
  int new_votes_size() const;
  private:
  int _internal_new_votes_size() const;
  public:
  void clear_new_votes();
  ::protocol::Vote* mutable_new_votes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote >*
      mutable_new_votes();
  private:
  const ::protocol::Vote& _internal_new_votes(int index) const;
  ::protocol::Vote* _internal_add_new_votes();
  public:
  const ::protocol::Vote& new_votes(int index) const;
  ::protocol::Vote* add_new_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote >&
      new_votes() const;

  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:protocol.Votes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote > old_votes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote > new_votes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class TXOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TXOutput) */ {
 public:
  inline TXOutput() : TXOutput(nullptr) {}
  ~TXOutput() override;
  explicit constexpr TXOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TXOutput(const TXOutput& from);
  TXOutput(TXOutput&& from) noexcept
    : TXOutput() {
    *this = ::std::move(from);
  }

  inline TXOutput& operator=(const TXOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline TXOutput& operator=(TXOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TXOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const TXOutput* internal_default_instance() {
    return reinterpret_cast<const TXOutput*>(
               &_TXOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(TXOutput& a, TXOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(TXOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TXOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TXOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TXOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TXOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TXOutput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TXOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TXOutput";
  }
  protected:
  explicit TXOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyHashFieldNumber = 2,
    kValueFieldNumber = 1,
  };
  // bytes pubKeyHash = 2;
  void clear_pubkeyhash();
  const std::string& pubkeyhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pubkeyhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pubkeyhash();
  PROTOBUF_NODISCARD std::string* release_pubkeyhash();
  void set_allocated_pubkeyhash(std::string* pubkeyhash);
  private:
  const std::string& _internal_pubkeyhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pubkeyhash(const std::string& value);
  std::string* _internal_mutable_pubkeyhash();
  public:

  // int64 value = 1;
  void clear_value();
  int64_t value() const;
  void set_value(int64_t value);
  private:
  int64_t _internal_value() const;
  void _internal_set_value(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TXOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pubkeyhash_;
  int64_t value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class TXInput_raw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TXInput.raw) */ {
 public:
  inline TXInput_raw() : TXInput_raw(nullptr) {}
  ~TXInput_raw() override;
  explicit constexpr TXInput_raw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TXInput_raw(const TXInput_raw& from);
  TXInput_raw(TXInput_raw&& from) noexcept
    : TXInput_raw() {
    *this = ::std::move(from);
  }

  inline TXInput_raw& operator=(const TXInput_raw& from) {
    CopyFrom(from);
    return *this;
  }
  inline TXInput_raw& operator=(TXInput_raw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TXInput_raw& default_instance() {
    return *internal_default_instance();
  }
  static inline const TXInput_raw* internal_default_instance() {
    return reinterpret_cast<const TXInput_raw*>(
               &_TXInput_raw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(TXInput_raw& a, TXInput_raw& b) {
    a.Swap(&b);
  }
  inline void Swap(TXInput_raw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TXInput_raw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TXInput_raw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TXInput_raw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TXInput_raw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TXInput_raw& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TXInput_raw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TXInput.raw";
  }
  protected:
  explicit TXInput_raw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxIDFieldNumber = 1,
    kPubKeyFieldNumber = 3,
    kVoutFieldNumber = 2,
  };
  // bytes txID = 1;
  void clear_txid();
  const std::string& txid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txid();
  PROTOBUF_NODISCARD std::string* release_txid();
  void set_allocated_txid(std::string* txid);
  private:
  const std::string& _internal_txid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txid(const std::string& value);
  std::string* _internal_mutable_txid();
  public:

  // bytes pubKey = 3;
  void clear_pubkey();
  const std::string& pubkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pubkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pubkey();
  PROTOBUF_NODISCARD std::string* release_pubkey();
  void set_allocated_pubkey(std::string* pubkey);
  private:
  const std::string& _internal_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pubkey(const std::string& value);
  std::string* _internal_mutable_pubkey();
  public:

  // int64 vout = 2;
  void clear_vout();
  int64_t vout() const;
  void set_vout(int64_t value);
  private:
  int64_t _internal_vout() const;
  void _internal_set_vout(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TXInput.raw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pubkey_;
  int64_t vout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class TXInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TXInput) */ {
 public:
  inline TXInput() : TXInput(nullptr) {}
  ~TXInput() override;
  explicit constexpr TXInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TXInput(const TXInput& from);
  TXInput(TXInput&& from) noexcept
    : TXInput() {
    *this = ::std::move(from);
  }

  inline TXInput& operator=(const TXInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline TXInput& operator=(TXInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TXInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const TXInput* internal_default_instance() {
    return reinterpret_cast<const TXInput*>(
               &_TXInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(TXInput& a, TXInput& b) {
    a.Swap(&b);
  }
  inline void Swap(TXInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TXInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TXInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TXInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TXInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TXInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TXInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TXInput";
  }
  protected:
  explicit TXInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TXInput_raw raw;

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 4,
    kRawDataFieldNumber = 1,
  };
  // bytes signature = 4;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .protocol.TXInput.raw raw_data = 1;
  bool has_raw_data() const;
  private:
  bool _internal_has_raw_data() const;
  public:
  void clear_raw_data();
  const ::protocol::TXInput_raw& raw_data() const;
  PROTOBUF_NODISCARD ::protocol::TXInput_raw* release_raw_data();
  ::protocol::TXInput_raw* mutable_raw_data();
  void set_allocated_raw_data(::protocol::TXInput_raw* raw_data);
  private:
  const ::protocol::TXInput_raw& _internal_raw_data() const;
  ::protocol::TXInput_raw* _internal_mutable_raw_data();
  public:
  void unsafe_arena_set_allocated_raw_data(
      ::protocol::TXInput_raw* raw_data);
  ::protocol::TXInput_raw* unsafe_arena_release_raw_data();

  // @@protoc_insertion_point(class_scope:protocol.TXInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::protocol::TXInput_raw* raw_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class TXOutputs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TXOutputs) */ {
 public:
  inline TXOutputs() : TXOutputs(nullptr) {}
  ~TXOutputs() override;
  explicit constexpr TXOutputs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TXOutputs(const TXOutputs& from);
  TXOutputs(TXOutputs&& from) noexcept
    : TXOutputs() {
    *this = ::std::move(from);
  }

  inline TXOutputs& operator=(const TXOutputs& from) {
    CopyFrom(from);
    return *this;
  }
  inline TXOutputs& operator=(TXOutputs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TXOutputs& default_instance() {
    return *internal_default_instance();
  }
  static inline const TXOutputs* internal_default_instance() {
    return reinterpret_cast<const TXOutputs*>(
               &_TXOutputs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(TXOutputs& a, TXOutputs& b) {
    a.Swap(&b);
  }
  inline void Swap(TXOutputs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TXOutputs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TXOutputs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TXOutputs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TXOutputs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TXOutputs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TXOutputs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TXOutputs";
  }
  protected:
  explicit TXOutputs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputsFieldNumber = 1,
  };
  // repeated .protocol.TXOutput outputs = 1;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::protocol::TXOutput* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TXOutput >*
      mutable_outputs();
  private:
  const ::protocol::TXOutput& _internal_outputs(int index) const;
  ::protocol::TXOutput* _internal_add_outputs();
  public:
  const ::protocol::TXOutput& outputs(int index) const;
  ::protocol::TXOutput* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TXOutput >&
      outputs() const;

  // @@protoc_insertion_point(class_scope:protocol.TXOutputs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TXOutput > outputs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class ResourceReceipt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ResourceReceipt) */ {
 public:
  inline ResourceReceipt() : ResourceReceipt(nullptr) {}
  ~ResourceReceipt() override;
  explicit constexpr ResourceReceipt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceReceipt(const ResourceReceipt& from);
  ResourceReceipt(ResourceReceipt&& from) noexcept
    : ResourceReceipt() {
    *this = ::std::move(from);
  }

  inline ResourceReceipt& operator=(const ResourceReceipt& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceReceipt& operator=(ResourceReceipt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceReceipt& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceReceipt* internal_default_instance() {
    return reinterpret_cast<const ResourceReceipt*>(
               &_ResourceReceipt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(ResourceReceipt& a, ResourceReceipt& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceReceipt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceReceipt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceReceipt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceReceipt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceReceipt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceReceipt& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceReceipt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ResourceReceipt";
  }
  protected:
  explicit ResourceReceipt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnergyUsageFieldNumber = 1,
    kEnergyFeeFieldNumber = 2,
    kOriginEnergyUsageFieldNumber = 3,
    kEnergyUsageTotalFieldNumber = 4,
    kNetUsageFieldNumber = 5,
    kNetFeeFieldNumber = 6,
    kResultFieldNumber = 7,
  };
  // int64 energy_usage = 1;
  void clear_energy_usage();
  int64_t energy_usage() const;
  void set_energy_usage(int64_t value);
  private:
  int64_t _internal_energy_usage() const;
  void _internal_set_energy_usage(int64_t value);
  public:

  // int64 energy_fee = 2;
  void clear_energy_fee();
  int64_t energy_fee() const;
  void set_energy_fee(int64_t value);
  private:
  int64_t _internal_energy_fee() const;
  void _internal_set_energy_fee(int64_t value);
  public:

  // int64 origin_energy_usage = 3;
  void clear_origin_energy_usage();
  int64_t origin_energy_usage() const;
  void set_origin_energy_usage(int64_t value);
  private:
  int64_t _internal_origin_energy_usage() const;
  void _internal_set_origin_energy_usage(int64_t value);
  public:

  // int64 energy_usage_total = 4;
  void clear_energy_usage_total();
  int64_t energy_usage_total() const;
  void set_energy_usage_total(int64_t value);
  private:
  int64_t _internal_energy_usage_total() const;
  void _internal_set_energy_usage_total(int64_t value);
  public:

  // int64 net_usage = 5;
  void clear_net_usage();
  int64_t net_usage() const;
  void set_net_usage(int64_t value);
  private:
  int64_t _internal_net_usage() const;
  void _internal_set_net_usage(int64_t value);
  public:

  // int64 net_fee = 6;
  void clear_net_fee();
  int64_t net_fee() const;
  void set_net_fee(int64_t value);
  private:
  int64_t _internal_net_fee() const;
  void _internal_set_net_fee(int64_t value);
  public:

  // .protocol.Transaction.Result.contractResult result = 7;
  void clear_result();
  ::protocol::Transaction_Result_contractResult result() const;
  void set_result(::protocol::Transaction_Result_contractResult value);
  private:
  ::protocol::Transaction_Result_contractResult _internal_result() const;
  void _internal_set_result(::protocol::Transaction_Result_contractResult value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ResourceReceipt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t energy_usage_;
  int64_t energy_fee_;
  int64_t origin_energy_usage_;
  int64_t energy_usage_total_;
  int64_t net_usage_;
  int64_t net_fee_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MarketOrderDetail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MarketOrderDetail) */ {
 public:
  inline MarketOrderDetail() : MarketOrderDetail(nullptr) {}
  ~MarketOrderDetail() override;
  explicit constexpr MarketOrderDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketOrderDetail(const MarketOrderDetail& from);
  MarketOrderDetail(MarketOrderDetail&& from) noexcept
    : MarketOrderDetail() {
    *this = ::std::move(from);
  }

  inline MarketOrderDetail& operator=(const MarketOrderDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketOrderDetail& operator=(MarketOrderDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketOrderDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketOrderDetail* internal_default_instance() {
    return reinterpret_cast<const MarketOrderDetail*>(
               &_MarketOrderDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(MarketOrderDetail& a, MarketOrderDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketOrderDetail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketOrderDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketOrderDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketOrderDetail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketOrderDetail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MarketOrderDetail& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketOrderDetail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MarketOrderDetail";
  }
  protected:
  explicit MarketOrderDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMakerOrderIdFieldNumber = 1,
    kTakerOrderIdFieldNumber = 2,
    kFillSellQuantityFieldNumber = 3,
    kFillBuyQuantityFieldNumber = 4,
  };
  // bytes makerOrderId = 1;
  void clear_makerorderid();
  const std::string& makerorderid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_makerorderid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_makerorderid();
  PROTOBUF_NODISCARD std::string* release_makerorderid();
  void set_allocated_makerorderid(std::string* makerorderid);
  private:
  const std::string& _internal_makerorderid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_makerorderid(const std::string& value);
  std::string* _internal_mutable_makerorderid();
  public:

  // bytes takerOrderId = 2;
  void clear_takerorderid();
  const std::string& takerorderid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_takerorderid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_takerorderid();
  PROTOBUF_NODISCARD std::string* release_takerorderid();
  void set_allocated_takerorderid(std::string* takerorderid);
  private:
  const std::string& _internal_takerorderid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_takerorderid(const std::string& value);
  std::string* _internal_mutable_takerorderid();
  public:

  // int64 fillSellQuantity = 3;
  void clear_fillsellquantity();
  int64_t fillsellquantity() const;
  void set_fillsellquantity(int64_t value);
  private:
  int64_t _internal_fillsellquantity() const;
  void _internal_set_fillsellquantity(int64_t value);
  public:

  // int64 fillBuyQuantity = 4;
  void clear_fillbuyquantity();
  int64_t fillbuyquantity() const;
  void set_fillbuyquantity(int64_t value);
  private:
  int64_t _internal_fillbuyquantity() const;
  void _internal_set_fillbuyquantity(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MarketOrderDetail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr makerorderid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr takerorderid_;
  int64_t fillsellquantity_;
  int64_t fillbuyquantity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Transaction_Contract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction.Contract) */ {
 public:
  inline Transaction_Contract() : Transaction_Contract(nullptr) {}
  ~Transaction_Contract() override;
  explicit constexpr Transaction_Contract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction_Contract(const Transaction_Contract& from);
  Transaction_Contract(Transaction_Contract&& from) noexcept
    : Transaction_Contract() {
    *this = ::std::move(from);
  }

  inline Transaction_Contract& operator=(const Transaction_Contract& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction_Contract& operator=(Transaction_Contract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction_Contract& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transaction_Contract* internal_default_instance() {
    return reinterpret_cast<const Transaction_Contract*>(
               &_Transaction_Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(Transaction_Contract& a, Transaction_Contract& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction_Contract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction_Contract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transaction_Contract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transaction_Contract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transaction_Contract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Transaction_Contract& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction_Contract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Transaction.Contract";
  }
  protected:
  explicit Transaction_Contract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Transaction_Contract_ContractType ContractType;
  static constexpr ContractType AccountCreateContract =
    Transaction_Contract_ContractType_AccountCreateContract;
  static constexpr ContractType TransferContract =
    Transaction_Contract_ContractType_TransferContract;
  static constexpr ContractType TransferAssetContract =
    Transaction_Contract_ContractType_TransferAssetContract;
  static constexpr ContractType VoteAssetContract =
    Transaction_Contract_ContractType_VoteAssetContract;
  static constexpr ContractType VoteWitnessContract =
    Transaction_Contract_ContractType_VoteWitnessContract;
  static constexpr ContractType WitnessCreateContract =
    Transaction_Contract_ContractType_WitnessCreateContract;
  static constexpr ContractType AssetIssueContract =
    Transaction_Contract_ContractType_AssetIssueContract;
  static constexpr ContractType WitnessUpdateContract =
    Transaction_Contract_ContractType_WitnessUpdateContract;
  static constexpr ContractType ParticipateAssetIssueContract =
    Transaction_Contract_ContractType_ParticipateAssetIssueContract;
  static constexpr ContractType AccountUpdateContract =
    Transaction_Contract_ContractType_AccountUpdateContract;
  static constexpr ContractType FreezeBalanceContract =
    Transaction_Contract_ContractType_FreezeBalanceContract;
  static constexpr ContractType UnfreezeBalanceContract =
    Transaction_Contract_ContractType_UnfreezeBalanceContract;
  static constexpr ContractType WithdrawBalanceContract =
    Transaction_Contract_ContractType_WithdrawBalanceContract;
  static constexpr ContractType UnfreezeAssetContract =
    Transaction_Contract_ContractType_UnfreezeAssetContract;
  static constexpr ContractType UpdateAssetContract =
    Transaction_Contract_ContractType_UpdateAssetContract;
  static constexpr ContractType ProposalCreateContract =
    Transaction_Contract_ContractType_ProposalCreateContract;
  static constexpr ContractType ProposalApproveContract =
    Transaction_Contract_ContractType_ProposalApproveContract;
  static constexpr ContractType ProposalDeleteContract =
    Transaction_Contract_ContractType_ProposalDeleteContract;
  static constexpr ContractType SetAccountIdContract =
    Transaction_Contract_ContractType_SetAccountIdContract;
  static constexpr ContractType CustomContract =
    Transaction_Contract_ContractType_CustomContract;
  static constexpr ContractType CreateSmartContract =
    Transaction_Contract_ContractType_CreateSmartContract;
  static constexpr ContractType TriggerSmartContract =
    Transaction_Contract_ContractType_TriggerSmartContract;
  static constexpr ContractType GetContract =
    Transaction_Contract_ContractType_GetContract;
  static constexpr ContractType UpdateSettingContract =
    Transaction_Contract_ContractType_UpdateSettingContract;
  static constexpr ContractType ExchangeCreateContract =
    Transaction_Contract_ContractType_ExchangeCreateContract;
  static constexpr ContractType ExchangeInjectContract =
    Transaction_Contract_ContractType_ExchangeInjectContract;
  static constexpr ContractType ExchangeWithdrawContract =
    Transaction_Contract_ContractType_ExchangeWithdrawContract;
  static constexpr ContractType ExchangeTransactionContract =
    Transaction_Contract_ContractType_ExchangeTransactionContract;
  static constexpr ContractType UpdateEnergyLimitContract =
    Transaction_Contract_ContractType_UpdateEnergyLimitContract;
  static constexpr ContractType AccountPermissionUpdateContract =
    Transaction_Contract_ContractType_AccountPermissionUpdateContract;
  static constexpr ContractType ClearABIContract =
    Transaction_Contract_ContractType_ClearABIContract;
  static constexpr ContractType UpdateBrokerageContract =
    Transaction_Contract_ContractType_UpdateBrokerageContract;
  static constexpr ContractType ShieldedTransferContract =
    Transaction_Contract_ContractType_ShieldedTransferContract;
  static constexpr ContractType MarketSellAssetContract =
    Transaction_Contract_ContractType_MarketSellAssetContract;
  static constexpr ContractType MarketCancelOrderContract =
    Transaction_Contract_ContractType_MarketCancelOrderContract;
  static inline bool ContractType_IsValid(int value) {
    return Transaction_Contract_ContractType_IsValid(value);
  }
  static constexpr ContractType ContractType_MIN =
    Transaction_Contract_ContractType_ContractType_MIN;
  static constexpr ContractType ContractType_MAX =
    Transaction_Contract_ContractType_ContractType_MAX;
  static constexpr int ContractType_ARRAYSIZE =
    Transaction_Contract_ContractType_ContractType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ContractType_descriptor() {
    return Transaction_Contract_ContractType_descriptor();
  }
  template<typename T>
  static inline const std::string& ContractType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ContractType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ContractType_Name.");
    return Transaction_Contract_ContractType_Name(enum_t_value);
  }
  static inline bool ContractType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ContractType* value) {
    return Transaction_Contract_ContractType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kProviderFieldNumber = 3,
    kContractNameFieldNumber = 4,
    kParameterFieldNumber = 2,
    kTypeFieldNumber = 1,
    kPermissionIdFieldNumber = 5,
  };
  // bytes provider = 3;
  void clear_provider();
  const std::string& provider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provider();
  PROTOBUF_NODISCARD std::string* release_provider();
  void set_allocated_provider(std::string* provider);
  private:
  const std::string& _internal_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider(const std::string& value);
  std::string* _internal_mutable_provider();
  public:

  // bytes ContractName = 4;
  void clear_contractname();
  const std::string& contractname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contractname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contractname();
  PROTOBUF_NODISCARD std::string* release_contractname();
  void set_allocated_contractname(std::string* contractname);
  private:
  const std::string& _internal_contractname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contractname(const std::string& value);
  std::string* _internal_mutable_contractname();
  public:

  // .google.protobuf.Any parameter = 2;
  bool has_parameter() const;
  private:
  bool _internal_has_parameter() const;
  public:
  void clear_parameter();
  const ::PROTOBUF_NAMESPACE_ID::Any& parameter() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_parameter();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_parameter();
  void set_allocated_parameter(::PROTOBUF_NAMESPACE_ID::Any* parameter);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_parameter() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_parameter();
  public:
  void unsafe_arena_set_allocated_parameter(
      ::PROTOBUF_NAMESPACE_ID::Any* parameter);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_parameter();

  // .protocol.Transaction.Contract.ContractType type = 1;
  void clear_type();
  ::protocol::Transaction_Contract_ContractType type() const;
  void set_type(::protocol::Transaction_Contract_ContractType value);
  private:
  ::protocol::Transaction_Contract_ContractType _internal_type() const;
  void _internal_set_type(::protocol::Transaction_Contract_ContractType value);
  public:

  // int32 Permission_id = 5;
  void clear_permission_id();
  int32_t permission_id() const;
  void set_permission_id(int32_t value);
  private:
  int32_t _internal_permission_id() const;
  void _internal_set_permission_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Transaction.Contract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contractname_;
  ::PROTOBUF_NAMESPACE_ID::Any* parameter_;
  int type_;
  int32_t permission_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Transaction_Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction.Result) */ {
 public:
  inline Transaction_Result() : Transaction_Result(nullptr) {}
  ~Transaction_Result() override;
  explicit constexpr Transaction_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction_Result(const Transaction_Result& from);
  Transaction_Result(Transaction_Result&& from) noexcept
    : Transaction_Result() {
    *this = ::std::move(from);
  }

  inline Transaction_Result& operator=(const Transaction_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction_Result& operator=(Transaction_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transaction_Result* internal_default_instance() {
    return reinterpret_cast<const Transaction_Result*>(
               &_Transaction_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(Transaction_Result& a, Transaction_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transaction_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transaction_Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transaction_Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Transaction_Result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Transaction.Result";
  }
  protected:
  explicit Transaction_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Transaction_Result_code code;
  static constexpr code SUCESS =
    Transaction_Result_code_SUCESS;
  static constexpr code FAILED =
    Transaction_Result_code_FAILED;
  static inline bool code_IsValid(int value) {
    return Transaction_Result_code_IsValid(value);
  }
  static constexpr code code_MIN =
    Transaction_Result_code_code_MIN;
  static constexpr code code_MAX =
    Transaction_Result_code_code_MAX;
  static constexpr int code_ARRAYSIZE =
    Transaction_Result_code_code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  code_descriptor() {
    return Transaction_Result_code_descriptor();
  }
  template<typename T>
  static inline const std::string& code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function code_Name.");
    return Transaction_Result_code_Name(enum_t_value);
  }
  static inline bool code_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      code* value) {
    return Transaction_Result_code_Parse(name, value);
  }

  typedef Transaction_Result_contractResult contractResult;
  static constexpr contractResult DEFAULT =
    Transaction_Result_contractResult_DEFAULT;
  static constexpr contractResult SUCCESS =
    Transaction_Result_contractResult_SUCCESS;
  static constexpr contractResult REVERT =
    Transaction_Result_contractResult_REVERT;
  static constexpr contractResult BAD_JUMP_DESTINATION =
    Transaction_Result_contractResult_BAD_JUMP_DESTINATION;
  static constexpr contractResult OUT_OF_MEMORY =
    Transaction_Result_contractResult_OUT_OF_MEMORY;
  static constexpr contractResult PRECOMPILED_CONTRACT =
    Transaction_Result_contractResult_PRECOMPILED_CONTRACT;
  static constexpr contractResult STACK_TOO_SMALL =
    Transaction_Result_contractResult_STACK_TOO_SMALL;
  static constexpr contractResult STACK_TOO_LARGE =
    Transaction_Result_contractResult_STACK_TOO_LARGE;
  static constexpr contractResult ILLEGAL_OPERATION =
    Transaction_Result_contractResult_ILLEGAL_OPERATION;
  static constexpr contractResult STACK_OVERFLOW =
    Transaction_Result_contractResult_STACK_OVERFLOW;
  static constexpr contractResult OUT_OF_ENERGY =
    Transaction_Result_contractResult_OUT_OF_ENERGY;
  static constexpr contractResult OUT_OF_TIME =
    Transaction_Result_contractResult_OUT_OF_TIME;
  static constexpr contractResult JVM_STACK_OVER_FLOW =
    Transaction_Result_contractResult_JVM_STACK_OVER_FLOW;
  static constexpr contractResult UNKNOWN =
    Transaction_Result_contractResult_UNKNOWN;
  static constexpr contractResult TRANSFER_FAILED =
    Transaction_Result_contractResult_TRANSFER_FAILED;
  static constexpr contractResult INVALID_CODE =
    Transaction_Result_contractResult_INVALID_CODE;
  static inline bool contractResult_IsValid(int value) {
    return Transaction_Result_contractResult_IsValid(value);
  }
  static constexpr contractResult contractResult_MIN =
    Transaction_Result_contractResult_contractResult_MIN;
  static constexpr contractResult contractResult_MAX =
    Transaction_Result_contractResult_contractResult_MAX;
  static constexpr int contractResult_ARRAYSIZE =
    Transaction_Result_contractResult_contractResult_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  contractResult_descriptor() {
    return Transaction_Result_contractResult_descriptor();
  }
  template<typename T>
  static inline const std::string& contractResult_Name(T enum_t_value) {
    static_assert(::std::is_same<T, contractResult>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function contractResult_Name.");
    return Transaction_Result_contractResult_Name(enum_t_value);
  }
  static inline bool contractResult_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      contractResult* value) {
    return Transaction_Result_contractResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOrderDetailsFieldNumber = 26,
    kAssetIssueIDFieldNumber = 14,
    kOrderIdFieldNumber = 25,
    kFeeFieldNumber = 1,
    kRetFieldNumber = 2,
    kContractRetFieldNumber = 3,
    kWithdrawAmountFieldNumber = 15,
    kUnfreezeAmountFieldNumber = 16,
    kExchangeReceivedAmountFieldNumber = 18,
    kExchangeInjectAnotherAmountFieldNumber = 19,
    kExchangeWithdrawAnotherAmountFieldNumber = 20,
    kExchangeIdFieldNumber = 21,
    kShieldedTransactionFeeFieldNumber = 22,
  };
  // repeated .protocol.MarketOrderDetail orderDetails = 26;
  int orderdetails_size() const;
  private:
  int _internal_orderdetails_size() const;
  public:
  void clear_orderdetails();
  ::protocol::MarketOrderDetail* mutable_orderdetails(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail >*
      mutable_orderdetails();
  private:
  const ::protocol::MarketOrderDetail& _internal_orderdetails(int index) const;
  ::protocol::MarketOrderDetail* _internal_add_orderdetails();
  public:
  const ::protocol::MarketOrderDetail& orderdetails(int index) const;
  ::protocol::MarketOrderDetail* add_orderdetails();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail >&
      orderdetails() const;

  // string assetIssueID = 14;
  void clear_assetissueid();
  const std::string& assetissueid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assetissueid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assetissueid();
  PROTOBUF_NODISCARD std::string* release_assetissueid();
  void set_allocated_assetissueid(std::string* assetissueid);
  private:
  const std::string& _internal_assetissueid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assetissueid(const std::string& value);
  std::string* _internal_mutable_assetissueid();
  public:

  // bytes orderId = 25;
  void clear_orderid();
  const std::string& orderid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_orderid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_orderid();
  PROTOBUF_NODISCARD std::string* release_orderid();
  void set_allocated_orderid(std::string* orderid);
  private:
  const std::string& _internal_orderid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orderid(const std::string& value);
  std::string* _internal_mutable_orderid();
  public:

  // int64 fee = 1;
  void clear_fee();
  int64_t fee() const;
  void set_fee(int64_t value);
  private:
  int64_t _internal_fee() const;
  void _internal_set_fee(int64_t value);
  public:

  // .protocol.Transaction.Result.code ret = 2;
  void clear_ret();
  ::protocol::Transaction_Result_code ret() const;
  void set_ret(::protocol::Transaction_Result_code value);
  private:
  ::protocol::Transaction_Result_code _internal_ret() const;
  void _internal_set_ret(::protocol::Transaction_Result_code value);
  public:

  // .protocol.Transaction.Result.contractResult contractRet = 3;
  void clear_contractret();
  ::protocol::Transaction_Result_contractResult contractret() const;
  void set_contractret(::protocol::Transaction_Result_contractResult value);
  private:
  ::protocol::Transaction_Result_contractResult _internal_contractret() const;
  void _internal_set_contractret(::protocol::Transaction_Result_contractResult value);
  public:

  // int64 withdraw_amount = 15;
  void clear_withdraw_amount();
  int64_t withdraw_amount() const;
  void set_withdraw_amount(int64_t value);
  private:
  int64_t _internal_withdraw_amount() const;
  void _internal_set_withdraw_amount(int64_t value);
  public:

  // int64 unfreeze_amount = 16;
  void clear_unfreeze_amount();
  int64_t unfreeze_amount() const;
  void set_unfreeze_amount(int64_t value);
  private:
  int64_t _internal_unfreeze_amount() const;
  void _internal_set_unfreeze_amount(int64_t value);
  public:

  // int64 exchange_received_amount = 18;
  void clear_exchange_received_amount();
  int64_t exchange_received_amount() const;
  void set_exchange_received_amount(int64_t value);
  private:
  int64_t _internal_exchange_received_amount() const;
  void _internal_set_exchange_received_amount(int64_t value);
  public:

  // int64 exchange_inject_another_amount = 19;
  void clear_exchange_inject_another_amount();
  int64_t exchange_inject_another_amount() const;
  void set_exchange_inject_another_amount(int64_t value);
  private:
  int64_t _internal_exchange_inject_another_amount() const;
  void _internal_set_exchange_inject_another_amount(int64_t value);
  public:

  // int64 exchange_withdraw_another_amount = 20;
  void clear_exchange_withdraw_another_amount();
  int64_t exchange_withdraw_another_amount() const;
  void set_exchange_withdraw_another_amount(int64_t value);
  private:
  int64_t _internal_exchange_withdraw_another_amount() const;
  void _internal_set_exchange_withdraw_another_amount(int64_t value);
  public:

  // int64 exchange_id = 21;
  void clear_exchange_id();
  int64_t exchange_id() const;
  void set_exchange_id(int64_t value);
  private:
  int64_t _internal_exchange_id() const;
  void _internal_set_exchange_id(int64_t value);
  public:

  // int64 shielded_transaction_fee = 22;
  void clear_shielded_transaction_fee();
  int64_t shielded_transaction_fee() const;
  void set_shielded_transaction_fee(int64_t value);
  private:
  int64_t _internal_shielded_transaction_fee() const;
  void _internal_set_shielded_transaction_fee(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Transaction.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail > orderdetails_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assetissueid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orderid_;
  int64_t fee_;
  int ret_;
  int contractret_;
  int64_t withdraw_amount_;
  int64_t unfreeze_amount_;
  int64_t exchange_received_amount_;
  int64_t exchange_inject_another_amount_;
  int64_t exchange_withdraw_another_amount_;
  int64_t exchange_id_;
  int64_t shielded_transaction_fee_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Transaction_raw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction.raw) */ {
 public:
  inline Transaction_raw() : Transaction_raw(nullptr) {}
  ~Transaction_raw() override;
  explicit constexpr Transaction_raw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction_raw(const Transaction_raw& from);
  Transaction_raw(Transaction_raw&& from) noexcept
    : Transaction_raw() {
    *this = ::std::move(from);
  }

  inline Transaction_raw& operator=(const Transaction_raw& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction_raw& operator=(Transaction_raw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction_raw& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transaction_raw* internal_default_instance() {
    return reinterpret_cast<const Transaction_raw*>(
               &_Transaction_raw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(Transaction_raw& a, Transaction_raw& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction_raw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction_raw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transaction_raw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transaction_raw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transaction_raw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Transaction_raw& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction_raw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Transaction.raw";
  }
  protected:
  explicit Transaction_raw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthsFieldNumber = 9,
    kContractFieldNumber = 11,
    kRefBlockBytesFieldNumber = 1,
    kRefBlockHashFieldNumber = 4,
    kDataFieldNumber = 10,
    kScriptsFieldNumber = 12,
    kRefBlockNumFieldNumber = 3,
    kExpirationFieldNumber = 8,
    kTimestampFieldNumber = 14,
    kFeeLimitFieldNumber = 18,
  };
  // repeated .protocol.authority auths = 9;
  int auths_size() const;
  private:
  int _internal_auths_size() const;
  public:
  void clear_auths();
  ::protocol::authority* mutable_auths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::authority >*
      mutable_auths();
  private:
  const ::protocol::authority& _internal_auths(int index) const;
  ::protocol::authority* _internal_add_auths();
  public:
  const ::protocol::authority& auths(int index) const;
  ::protocol::authority* add_auths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::authority >&
      auths() const;

  // repeated .protocol.Transaction.Contract contract = 11;
  int contract_size() const;
  private:
  int _internal_contract_size() const;
  public:
  void clear_contract();
  ::protocol::Transaction_Contract* mutable_contract(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Contract >*
      mutable_contract();
  private:
  const ::protocol::Transaction_Contract& _internal_contract(int index) const;
  ::protocol::Transaction_Contract* _internal_add_contract();
  public:
  const ::protocol::Transaction_Contract& contract(int index) const;
  ::protocol::Transaction_Contract* add_contract();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Contract >&
      contract() const;

  // bytes ref_block_bytes = 1;
  void clear_ref_block_bytes();
  const std::string& ref_block_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ref_block_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ref_block_bytes();
  PROTOBUF_NODISCARD std::string* release_ref_block_bytes();
  void set_allocated_ref_block_bytes(std::string* ref_block_bytes);
  private:
  const std::string& _internal_ref_block_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref_block_bytes(const std::string& value);
  std::string* _internal_mutable_ref_block_bytes();
  public:

  // bytes ref_block_hash = 4;
  void clear_ref_block_hash();
  const std::string& ref_block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ref_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ref_block_hash();
  PROTOBUF_NODISCARD std::string* release_ref_block_hash();
  void set_allocated_ref_block_hash(std::string* ref_block_hash);
  private:
  const std::string& _internal_ref_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref_block_hash(const std::string& value);
  std::string* _internal_mutable_ref_block_hash();
  public:

  // bytes data = 10;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bytes scripts = 12;
  void clear_scripts();
  const std::string& scripts() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scripts(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scripts();
  PROTOBUF_NODISCARD std::string* release_scripts();
  void set_allocated_scripts(std::string* scripts);
  private:
  const std::string& _internal_scripts() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scripts(const std::string& value);
  std::string* _internal_mutable_scripts();
  public:

  // int64 ref_block_num = 3;
  void clear_ref_block_num();
  int64_t ref_block_num() const;
  void set_ref_block_num(int64_t value);
  private:
  int64_t _internal_ref_block_num() const;
  void _internal_set_ref_block_num(int64_t value);
  public:

  // int64 expiration = 8;
  void clear_expiration();
  int64_t expiration() const;
  void set_expiration(int64_t value);
  private:
  int64_t _internal_expiration() const;
  void _internal_set_expiration(int64_t value);
  public:

  // int64 timestamp = 14;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int64 fee_limit = 18;
  void clear_fee_limit();
  int64_t fee_limit() const;
  void set_fee_limit(int64_t value);
  private:
  int64_t _internal_fee_limit() const;
  void _internal_set_fee_limit(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Transaction.raw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::authority > auths_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Contract > contract_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ref_block_bytes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ref_block_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scripts_;
  int64_t ref_block_num_;
  int64_t expiration_;
  int64_t timestamp_;
  int64_t fee_limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Transaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction) */ {
 public:
  inline Transaction() : Transaction(nullptr) {}
  ~Transaction() override;
  explicit constexpr Transaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction(const Transaction& from);
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction& operator=(Transaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Transaction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Transaction";
  }
  protected:
  explicit Transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Transaction_Contract Contract;
  typedef Transaction_Result Result;
  typedef Transaction_raw raw;

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 2,
    kRetFieldNumber = 5,
    kRawDataFieldNumber = 1,
  };
  // repeated bytes signature = 2;
  int signature_size() const;
  private:
  int _internal_signature_size() const;
  public:
  void clear_signature();
  const std::string& signature(int index) const;
  std::string* mutable_signature(int index);
  void set_signature(int index, const std::string& value);
  void set_signature(int index, std::string&& value);
  void set_signature(int index, const char* value);
  void set_signature(int index, const void* value, size_t size);
  std::string* add_signature();
  void add_signature(const std::string& value);
  void add_signature(std::string&& value);
  void add_signature(const char* value);
  void add_signature(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signature() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signature();
  private:
  const std::string& _internal_signature(int index) const;
  std::string* _internal_add_signature();
  public:

  // repeated .protocol.Transaction.Result ret = 5;
  int ret_size() const;
  private:
  int _internal_ret_size() const;
  public:
  void clear_ret();
  ::protocol::Transaction_Result* mutable_ret(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Result >*
      mutable_ret();
  private:
  const ::protocol::Transaction_Result& _internal_ret(int index) const;
  ::protocol::Transaction_Result* _internal_add_ret();
  public:
  const ::protocol::Transaction_Result& ret(int index) const;
  ::protocol::Transaction_Result* add_ret();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Result >&
      ret() const;

  // .protocol.Transaction.raw raw_data = 1;
  bool has_raw_data() const;
  private:
  bool _internal_has_raw_data() const;
  public:
  void clear_raw_data();
  const ::protocol::Transaction_raw& raw_data() const;
  PROTOBUF_NODISCARD ::protocol::Transaction_raw* release_raw_data();
  ::protocol::Transaction_raw* mutable_raw_data();
  void set_allocated_raw_data(::protocol::Transaction_raw* raw_data);
  private:
  const ::protocol::Transaction_raw& _internal_raw_data() const;
  ::protocol::Transaction_raw* _internal_mutable_raw_data();
  public:
  void unsafe_arena_set_allocated_raw_data(
      ::protocol::Transaction_raw* raw_data);
  ::protocol::Transaction_raw* unsafe_arena_release_raw_data();

  // @@protoc_insertion_point(class_scope:protocol.Transaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signature_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Result > ret_;
  ::protocol::Transaction_raw* raw_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class TransactionInfo_Log final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionInfo.Log) */ {
 public:
  inline TransactionInfo_Log() : TransactionInfo_Log(nullptr) {}
  ~TransactionInfo_Log() override;
  explicit constexpr TransactionInfo_Log(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionInfo_Log(const TransactionInfo_Log& from);
  TransactionInfo_Log(TransactionInfo_Log&& from) noexcept
    : TransactionInfo_Log() {
    *this = ::std::move(from);
  }

  inline TransactionInfo_Log& operator=(const TransactionInfo_Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionInfo_Log& operator=(TransactionInfo_Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionInfo_Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionInfo_Log* internal_default_instance() {
    return reinterpret_cast<const TransactionInfo_Log*>(
               &_TransactionInfo_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(TransactionInfo_Log& a, TransactionInfo_Log& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionInfo_Log* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionInfo_Log* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionInfo_Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionInfo_Log>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionInfo_Log& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionInfo_Log& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionInfo_Log* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionInfo.Log";
  }
  protected:
  explicit TransactionInfo_Log(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicsFieldNumber = 2,
    kAddressFieldNumber = 1,
    kDataFieldNumber = 3,
  };
  // repeated bytes topics = 2;
  int topics_size() const;
  private:
  int _internal_topics_size() const;
  public:
  void clear_topics();
  const std::string& topics(int index) const;
  std::string* mutable_topics(int index);
  void set_topics(int index, const std::string& value);
  void set_topics(int index, std::string&& value);
  void set_topics(int index, const char* value);
  void set_topics(int index, const void* value, size_t size);
  std::string* add_topics();
  void add_topics(const std::string& value);
  void add_topics(std::string&& value);
  void add_topics(const char* value);
  void add_topics(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& topics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_topics();
  private:
  const std::string& _internal_topics(int index) const;
  std::string* _internal_add_topics();
  public:

  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:protocol.TransactionInfo.Log)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> topics_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class TransactionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionInfo) */ {
 public:
  inline TransactionInfo() : TransactionInfo(nullptr) {}
  ~TransactionInfo() override;
  explicit constexpr TransactionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionInfo(const TransactionInfo& from);
  TransactionInfo(TransactionInfo&& from) noexcept
    : TransactionInfo() {
    *this = ::std::move(from);
  }

  inline TransactionInfo& operator=(const TransactionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionInfo& operator=(TransactionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionInfo* internal_default_instance() {
    return reinterpret_cast<const TransactionInfo*>(
               &_TransactionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(TransactionInfo& a, TransactionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionInfo";
  }
  protected:
  explicit TransactionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionInfo_Log Log;

  typedef TransactionInfo_code code;
  static constexpr code SUCESS =
    TransactionInfo_code_SUCESS;
  static constexpr code FAILED =
    TransactionInfo_code_FAILED;
  static inline bool code_IsValid(int value) {
    return TransactionInfo_code_IsValid(value);
  }
  static constexpr code code_MIN =
    TransactionInfo_code_code_MIN;
  static constexpr code code_MAX =
    TransactionInfo_code_code_MAX;
  static constexpr int code_ARRAYSIZE =
    TransactionInfo_code_code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  code_descriptor() {
    return TransactionInfo_code_descriptor();
  }
  template<typename T>
  static inline const std::string& code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function code_Name.");
    return TransactionInfo_code_Name(enum_t_value);
  }
  static inline bool code_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      code* value) {
    return TransactionInfo_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContractResultFieldNumber = 5,
    kLogFieldNumber = 8,
    kInternalTransactionsFieldNumber = 17,
    kOrderDetailsFieldNumber = 26,
    kIdFieldNumber = 1,
    kContractAddressFieldNumber = 6,
    kResMessageFieldNumber = 10,
    kAssetIssueIDFieldNumber = 14,
    kOrderIdFieldNumber = 25,
    kReceiptFieldNumber = 7,
    kFeeFieldNumber = 2,
    kBlockNumberFieldNumber = 3,
    kBlockTimeStampFieldNumber = 4,
    kWithdrawAmountFieldNumber = 15,
    kUnfreezeAmountFieldNumber = 16,
    kExchangeReceivedAmountFieldNumber = 18,
    kExchangeInjectAnotherAmountFieldNumber = 19,
    kExchangeWithdrawAnotherAmountFieldNumber = 20,
    kExchangeIdFieldNumber = 21,
    kShieldedTransactionFeeFieldNumber = 22,
    kResultFieldNumber = 9,
    kPackingFeeFieldNumber = 27,
  };
  // repeated bytes contractResult = 5;
  int contractresult_size() const;
  private:
  int _internal_contractresult_size() const;
  public:
  void clear_contractresult();
  const std::string& contractresult(int index) const;
  std::string* mutable_contractresult(int index);
  void set_contractresult(int index, const std::string& value);
  void set_contractresult(int index, std::string&& value);
  void set_contractresult(int index, const char* value);
  void set_contractresult(int index, const void* value, size_t size);
  std::string* add_contractresult();
  void add_contractresult(const std::string& value);
  void add_contractresult(std::string&& value);
  void add_contractresult(const char* value);
  void add_contractresult(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& contractresult() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_contractresult();
  private:
  const std::string& _internal_contractresult(int index) const;
  std::string* _internal_add_contractresult();
  public:

  // repeated .protocol.TransactionInfo.Log log = 8;
  int log_size() const;
  private:
  int _internal_log_size() const;
  public:
  void clear_log();
  ::protocol::TransactionInfo_Log* mutable_log(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo_Log >*
      mutable_log();
  private:
  const ::protocol::TransactionInfo_Log& _internal_log(int index) const;
  ::protocol::TransactionInfo_Log* _internal_add_log();
  public:
  const ::protocol::TransactionInfo_Log& log(int index) const;
  ::protocol::TransactionInfo_Log* add_log();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo_Log >&
      log() const;

  // repeated .protocol.InternalTransaction internal_transactions = 17;
  int internal_transactions_size() const;
  private:
  int _internal_internal_transactions_size() const;
  public:
  void clear_internal_transactions();
  ::protocol::InternalTransaction* mutable_internal_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::InternalTransaction >*
      mutable_internal_transactions();
  private:
  const ::protocol::InternalTransaction& _internal_internal_transactions(int index) const;
  ::protocol::InternalTransaction* _internal_add_internal_transactions();
  public:
  const ::protocol::InternalTransaction& internal_transactions(int index) const;
  ::protocol::InternalTransaction* add_internal_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::InternalTransaction >&
      internal_transactions() const;

  // repeated .protocol.MarketOrderDetail orderDetails = 26;
  int orderdetails_size() const;
  private:
  int _internal_orderdetails_size() const;
  public:
  void clear_orderdetails();
  ::protocol::MarketOrderDetail* mutable_orderdetails(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail >*
      mutable_orderdetails();
  private:
  const ::protocol::MarketOrderDetail& _internal_orderdetails(int index) const;
  ::protocol::MarketOrderDetail* _internal_add_orderdetails();
  public:
  const ::protocol::MarketOrderDetail& orderdetails(int index) const;
  ::protocol::MarketOrderDetail* add_orderdetails();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail >&
      orderdetails() const;

  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes contract_address = 6;
  void clear_contract_address();
  const std::string& contract_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contract_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* contract_address);
  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(const std::string& value);
  std::string* _internal_mutable_contract_address();
  public:

  // bytes resMessage = 10;
  void clear_resmessage();
  const std::string& resmessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resmessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resmessage();
  PROTOBUF_NODISCARD std::string* release_resmessage();
  void set_allocated_resmessage(std::string* resmessage);
  private:
  const std::string& _internal_resmessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resmessage(const std::string& value);
  std::string* _internal_mutable_resmessage();
  public:

  // string assetIssueID = 14;
  void clear_assetissueid();
  const std::string& assetissueid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assetissueid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assetissueid();
  PROTOBUF_NODISCARD std::string* release_assetissueid();
  void set_allocated_assetissueid(std::string* assetissueid);
  private:
  const std::string& _internal_assetissueid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assetissueid(const std::string& value);
  std::string* _internal_mutable_assetissueid();
  public:

  // bytes orderId = 25;
  void clear_orderid();
  const std::string& orderid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_orderid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_orderid();
  PROTOBUF_NODISCARD std::string* release_orderid();
  void set_allocated_orderid(std::string* orderid);
  private:
  const std::string& _internal_orderid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orderid(const std::string& value);
  std::string* _internal_mutable_orderid();
  public:

  // .protocol.ResourceReceipt receipt = 7;
  bool has_receipt() const;
  private:
  bool _internal_has_receipt() const;
  public:
  void clear_receipt();
  const ::protocol::ResourceReceipt& receipt() const;
  PROTOBUF_NODISCARD ::protocol::ResourceReceipt* release_receipt();
  ::protocol::ResourceReceipt* mutable_receipt();
  void set_allocated_receipt(::protocol::ResourceReceipt* receipt);
  private:
  const ::protocol::ResourceReceipt& _internal_receipt() const;
  ::protocol::ResourceReceipt* _internal_mutable_receipt();
  public:
  void unsafe_arena_set_allocated_receipt(
      ::protocol::ResourceReceipt* receipt);
  ::protocol::ResourceReceipt* unsafe_arena_release_receipt();

  // int64 fee = 2;
  void clear_fee();
  int64_t fee() const;
  void set_fee(int64_t value);
  private:
  int64_t _internal_fee() const;
  void _internal_set_fee(int64_t value);
  public:

  // int64 blockNumber = 3;
  void clear_blocknumber();
  int64_t blocknumber() const;
  void set_blocknumber(int64_t value);
  private:
  int64_t _internal_blocknumber() const;
  void _internal_set_blocknumber(int64_t value);
  public:

  // int64 blockTimeStamp = 4;
  void clear_blocktimestamp();
  int64_t blocktimestamp() const;
  void set_blocktimestamp(int64_t value);
  private:
  int64_t _internal_blocktimestamp() const;
  void _internal_set_blocktimestamp(int64_t value);
  public:

  // int64 withdraw_amount = 15;
  void clear_withdraw_amount();
  int64_t withdraw_amount() const;
  void set_withdraw_amount(int64_t value);
  private:
  int64_t _internal_withdraw_amount() const;
  void _internal_set_withdraw_amount(int64_t value);
  public:

  // int64 unfreeze_amount = 16;
  void clear_unfreeze_amount();
  int64_t unfreeze_amount() const;
  void set_unfreeze_amount(int64_t value);
  private:
  int64_t _internal_unfreeze_amount() const;
  void _internal_set_unfreeze_amount(int64_t value);
  public:

  // int64 exchange_received_amount = 18;
  void clear_exchange_received_amount();
  int64_t exchange_received_amount() const;
  void set_exchange_received_amount(int64_t value);
  private:
  int64_t _internal_exchange_received_amount() const;
  void _internal_set_exchange_received_amount(int64_t value);
  public:

  // int64 exchange_inject_another_amount = 19;
  void clear_exchange_inject_another_amount();
  int64_t exchange_inject_another_amount() const;
  void set_exchange_inject_another_amount(int64_t value);
  private:
  int64_t _internal_exchange_inject_another_amount() const;
  void _internal_set_exchange_inject_another_amount(int64_t value);
  public:

  // int64 exchange_withdraw_another_amount = 20;
  void clear_exchange_withdraw_another_amount();
  int64_t exchange_withdraw_another_amount() const;
  void set_exchange_withdraw_another_amount(int64_t value);
  private:
  int64_t _internal_exchange_withdraw_another_amount() const;
  void _internal_set_exchange_withdraw_another_amount(int64_t value);
  public:

  // int64 exchange_id = 21;
  void clear_exchange_id();
  int64_t exchange_id() const;
  void set_exchange_id(int64_t value);
  private:
  int64_t _internal_exchange_id() const;
  void _internal_set_exchange_id(int64_t value);
  public:

  // int64 shielded_transaction_fee = 22;
  void clear_shielded_transaction_fee();
  int64_t shielded_transaction_fee() const;
  void set_shielded_transaction_fee(int64_t value);
  private:
  int64_t _internal_shielded_transaction_fee() const;
  void _internal_set_shielded_transaction_fee(int64_t value);
  public:

  // .protocol.TransactionInfo.code result = 9;
  void clear_result();
  ::protocol::TransactionInfo_code result() const;
  void set_result(::protocol::TransactionInfo_code value);
  private:
  ::protocol::TransactionInfo_code _internal_result() const;
  void _internal_set_result(::protocol::TransactionInfo_code value);
  public:

  // int64 packingFee = 27;
  void clear_packingfee();
  int64_t packingfee() const;
  void set_packingfee(int64_t value);
  private:
  int64_t _internal_packingfee() const;
  void _internal_set_packingfee(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TransactionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> contractresult_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo_Log > log_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::InternalTransaction > internal_transactions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail > orderdetails_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resmessage_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assetissueid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orderid_;
  ::protocol::ResourceReceipt* receipt_;
  int64_t fee_;
  int64_t blocknumber_;
  int64_t blocktimestamp_;
  int64_t withdraw_amount_;
  int64_t unfreeze_amount_;
  int64_t exchange_received_amount_;
  int64_t exchange_inject_another_amount_;
  int64_t exchange_withdraw_another_amount_;
  int64_t exchange_id_;
  int64_t shielded_transaction_fee_;
  int result_;
  int64_t packingfee_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class TransactionRet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionRet) */ {
 public:
  inline TransactionRet() : TransactionRet(nullptr) {}
  ~TransactionRet() override;
  explicit constexpr TransactionRet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionRet(const TransactionRet& from);
  TransactionRet(TransactionRet&& from) noexcept
    : TransactionRet() {
    *this = ::std::move(from);
  }

  inline TransactionRet& operator=(const TransactionRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionRet& operator=(TransactionRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionRet* internal_default_instance() {
    return reinterpret_cast<const TransactionRet*>(
               &_TransactionRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(TransactionRet& a, TransactionRet& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionRet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionRet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionRet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionRet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionRet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionRet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionRet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionRet";
  }
  protected:
  explicit TransactionRet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactioninfoFieldNumber = 3,
    kBlockNumberFieldNumber = 1,
    kBlockTimeStampFieldNumber = 2,
  };
  // repeated .protocol.TransactionInfo transactioninfo = 3;
  int transactioninfo_size() const;
  private:
  int _internal_transactioninfo_size() const;
  public:
  void clear_transactioninfo();
  ::protocol::TransactionInfo* mutable_transactioninfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo >*
      mutable_transactioninfo();
  private:
  const ::protocol::TransactionInfo& _internal_transactioninfo(int index) const;
  ::protocol::TransactionInfo* _internal_add_transactioninfo();
  public:
  const ::protocol::TransactionInfo& transactioninfo(int index) const;
  ::protocol::TransactionInfo* add_transactioninfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo >&
      transactioninfo() const;

  // int64 blockNumber = 1;
  void clear_blocknumber();
  int64_t blocknumber() const;
  void set_blocknumber(int64_t value);
  private:
  int64_t _internal_blocknumber() const;
  void _internal_set_blocknumber(int64_t value);
  public:

  // int64 blockTimeStamp = 2;
  void clear_blocktimestamp();
  int64_t blocktimestamp() const;
  void set_blocktimestamp(int64_t value);
  private:
  int64_t _internal_blocktimestamp() const;
  void _internal_set_blocktimestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TransactionRet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo > transactioninfo_;
  int64_t blocknumber_;
  int64_t blocktimestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Transactions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Transactions) */ {
 public:
  inline Transactions() : Transactions(nullptr) {}
  ~Transactions() override;
  explicit constexpr Transactions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transactions(const Transactions& from);
  Transactions(Transactions&& from) noexcept
    : Transactions() {
    *this = ::std::move(from);
  }

  inline Transactions& operator=(const Transactions& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transactions& operator=(Transactions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transactions& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transactions* internal_default_instance() {
    return reinterpret_cast<const Transactions*>(
               &_Transactions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(Transactions& a, Transactions& b) {
    a.Swap(&b);
  }
  inline void Swap(Transactions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transactions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transactions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transactions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transactions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Transactions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transactions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Transactions";
  }
  protected:
  explicit Transactions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 1,
  };
  // repeated .protocol.Transaction transactions = 1;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  ::protocol::Transaction* mutable_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >*
      mutable_transactions();
  private:
  const ::protocol::Transaction& _internal_transactions(int index) const;
  ::protocol::Transaction* _internal_add_transactions();
  public:
  const ::protocol::Transaction& transactions(int index) const;
  ::protocol::Transaction* add_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >&
      transactions() const;

  // @@protoc_insertion_point(class_scope:protocol.Transactions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction > transactions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class TransactionSign final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionSign) */ {
 public:
  inline TransactionSign() : TransactionSign(nullptr) {}
  ~TransactionSign() override;
  explicit constexpr TransactionSign(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionSign(const TransactionSign& from);
  TransactionSign(TransactionSign&& from) noexcept
    : TransactionSign() {
    *this = ::std::move(from);
  }

  inline TransactionSign& operator=(const TransactionSign& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionSign& operator=(TransactionSign&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionSign& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionSign* internal_default_instance() {
    return reinterpret_cast<const TransactionSign*>(
               &_TransactionSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(TransactionSign& a, TransactionSign& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionSign* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionSign* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionSign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionSign>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionSign& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionSign& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionSign* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TransactionSign";
  }
  protected:
  explicit TransactionSign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrivateKeyFieldNumber = 2,
    kTransactionFieldNumber = 1,
  };
  // bytes privateKey = 2;
  void clear_privatekey();
  const std::string& privatekey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_privatekey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_privatekey();
  PROTOBUF_NODISCARD std::string* release_privatekey();
  void set_allocated_privatekey(std::string* privatekey);
  private:
  const std::string& _internal_privatekey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_privatekey(const std::string& value);
  std::string* _internal_mutable_privatekey();
  public:

  // .protocol.Transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::protocol::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::protocol::Transaction* release_transaction();
  ::protocol::Transaction* mutable_transaction();
  void set_allocated_transaction(::protocol::Transaction* transaction);
  private:
  const ::protocol::Transaction& _internal_transaction() const;
  ::protocol::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::protocol::Transaction* transaction);
  ::protocol::Transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:protocol.TransactionSign)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privatekey_;
  ::protocol::Transaction* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class BlockHeader_raw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockHeader.raw) */ {
 public:
  inline BlockHeader_raw() : BlockHeader_raw(nullptr) {}
  ~BlockHeader_raw() override;
  explicit constexpr BlockHeader_raw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockHeader_raw(const BlockHeader_raw& from);
  BlockHeader_raw(BlockHeader_raw&& from) noexcept
    : BlockHeader_raw() {
    *this = ::std::move(from);
  }

  inline BlockHeader_raw& operator=(const BlockHeader_raw& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockHeader_raw& operator=(BlockHeader_raw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockHeader_raw& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockHeader_raw* internal_default_instance() {
    return reinterpret_cast<const BlockHeader_raw*>(
               &_BlockHeader_raw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(BlockHeader_raw& a, BlockHeader_raw& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockHeader_raw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockHeader_raw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockHeader_raw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockHeader_raw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockHeader_raw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockHeader_raw& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeader_raw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockHeader.raw";
  }
  protected:
  explicit BlockHeader_raw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxTrieRootFieldNumber = 2,
    kParentHashFieldNumber = 3,
    kWitnessAddressFieldNumber = 9,
    kAccountStateRootFieldNumber = 11,
    kTimestampFieldNumber = 1,
    kNumberFieldNumber = 7,
    kWitnessIdFieldNumber = 8,
    kVersionFieldNumber = 10,
  };
  // bytes txTrieRoot = 2;
  void clear_txtrieroot();
  const std::string& txtrieroot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txtrieroot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txtrieroot();
  PROTOBUF_NODISCARD std::string* release_txtrieroot();
  void set_allocated_txtrieroot(std::string* txtrieroot);
  private:
  const std::string& _internal_txtrieroot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txtrieroot(const std::string& value);
  std::string* _internal_mutable_txtrieroot();
  public:

  // bytes parentHash = 3;
  void clear_parenthash();
  const std::string& parenthash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parenthash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parenthash();
  PROTOBUF_NODISCARD std::string* release_parenthash();
  void set_allocated_parenthash(std::string* parenthash);
  private:
  const std::string& _internal_parenthash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parenthash(const std::string& value);
  std::string* _internal_mutable_parenthash();
  public:

  // bytes witness_address = 9;
  void clear_witness_address();
  const std::string& witness_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_witness_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_witness_address();
  PROTOBUF_NODISCARD std::string* release_witness_address();
  void set_allocated_witness_address(std::string* witness_address);
  private:
  const std::string& _internal_witness_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_witness_address(const std::string& value);
  std::string* _internal_mutable_witness_address();
  public:

  // bytes accountStateRoot = 11;
  void clear_accountstateroot();
  const std::string& accountstateroot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accountstateroot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accountstateroot();
  PROTOBUF_NODISCARD std::string* release_accountstateroot();
  void set_allocated_accountstateroot(std::string* accountstateroot);
  private:
  const std::string& _internal_accountstateroot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accountstateroot(const std::string& value);
  std::string* _internal_mutable_accountstateroot();
  public:

  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int64 number = 7;
  void clear_number();
  int64_t number() const;
  void set_number(int64_t value);
  private:
  int64_t _internal_number() const;
  void _internal_set_number(int64_t value);
  public:

  // int64 witness_id = 8;
  void clear_witness_id();
  int64_t witness_id() const;
  void set_witness_id(int64_t value);
  private:
  int64_t _internal_witness_id() const;
  void _internal_set_witness_id(int64_t value);
  public:

  // int32 version = 10;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.BlockHeader.raw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txtrieroot_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parenthash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr witness_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accountstateroot_;
  int64_t timestamp_;
  int64_t number_;
  int64_t witness_id_;
  int32_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class BlockHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockHeader) */ {
 public:
  inline BlockHeader() : BlockHeader(nullptr) {}
  ~BlockHeader() override;
  explicit constexpr BlockHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockHeader(const BlockHeader& from);
  BlockHeader(BlockHeader&& from) noexcept
    : BlockHeader() {
    *this = ::std::move(from);
  }

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockHeader& operator=(BlockHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockHeader* internal_default_instance() {
    return reinterpret_cast<const BlockHeader*>(
               &_BlockHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(BlockHeader& a, BlockHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockHeader& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockHeader";
  }
  protected:
  explicit BlockHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BlockHeader_raw raw;

  // accessors -------------------------------------------------------

  enum : int {
    kWitnessSignatureFieldNumber = 2,
    kRawDataFieldNumber = 1,
  };
  // bytes witness_signature = 2;
  void clear_witness_signature();
  const std::string& witness_signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_witness_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_witness_signature();
  PROTOBUF_NODISCARD std::string* release_witness_signature();
  void set_allocated_witness_signature(std::string* witness_signature);
  private:
  const std::string& _internal_witness_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_witness_signature(const std::string& value);
  std::string* _internal_mutable_witness_signature();
  public:

  // .protocol.BlockHeader.raw raw_data = 1;
  bool has_raw_data() const;
  private:
  bool _internal_has_raw_data() const;
  public:
  void clear_raw_data();
  const ::protocol::BlockHeader_raw& raw_data() const;
  PROTOBUF_NODISCARD ::protocol::BlockHeader_raw* release_raw_data();
  ::protocol::BlockHeader_raw* mutable_raw_data();
  void set_allocated_raw_data(::protocol::BlockHeader_raw* raw_data);
  private:
  const ::protocol::BlockHeader_raw& _internal_raw_data() const;
  ::protocol::BlockHeader_raw* _internal_mutable_raw_data();
  public:
  void unsafe_arena_set_allocated_raw_data(
      ::protocol::BlockHeader_raw* raw_data);
  ::protocol::BlockHeader_raw* unsafe_arena_release_raw_data();

  // @@protoc_insertion_point(class_scope:protocol.BlockHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr witness_signature_;
  ::protocol::BlockHeader_raw* raw_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Block final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Block) */ {
 public:
  inline Block() : Block(nullptr) {}
  ~Block() override;
  explicit constexpr Block(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Block(const Block& from);
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Block& default_instance() {
    return *internal_default_instance();
  }
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }
  inline void Swap(Block* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Block* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Block& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Block& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Block";
  }
  protected:
  explicit Block(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 1,
    kBlockHeaderFieldNumber = 2,
  };
  // repeated .protocol.Transaction transactions = 1;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  ::protocol::Transaction* mutable_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >*
      mutable_transactions();
  private:
  const ::protocol::Transaction& _internal_transactions(int index) const;
  ::protocol::Transaction* _internal_add_transactions();
  public:
  const ::protocol::Transaction& transactions(int index) const;
  ::protocol::Transaction* add_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >&
      transactions() const;

  // .protocol.BlockHeader block_header = 2;
  bool has_block_header() const;
  private:
  bool _internal_has_block_header() const;
  public:
  void clear_block_header();
  const ::protocol::BlockHeader& block_header() const;
  PROTOBUF_NODISCARD ::protocol::BlockHeader* release_block_header();
  ::protocol::BlockHeader* mutable_block_header();
  void set_allocated_block_header(::protocol::BlockHeader* block_header);
  private:
  const ::protocol::BlockHeader& _internal_block_header() const;
  ::protocol::BlockHeader* _internal_mutable_block_header();
  public:
  void unsafe_arena_set_allocated_block_header(
      ::protocol::BlockHeader* block_header);
  ::protocol::BlockHeader* unsafe_arena_release_block_header();

  // @@protoc_insertion_point(class_scope:protocol.Block)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction > transactions_;
  ::protocol::BlockHeader* block_header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class ChainInventory_BlockId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ChainInventory.BlockId) */ {
 public:
  inline ChainInventory_BlockId() : ChainInventory_BlockId(nullptr) {}
  ~ChainInventory_BlockId() override;
  explicit constexpr ChainInventory_BlockId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChainInventory_BlockId(const ChainInventory_BlockId& from);
  ChainInventory_BlockId(ChainInventory_BlockId&& from) noexcept
    : ChainInventory_BlockId() {
    *this = ::std::move(from);
  }

  inline ChainInventory_BlockId& operator=(const ChainInventory_BlockId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChainInventory_BlockId& operator=(ChainInventory_BlockId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChainInventory_BlockId& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChainInventory_BlockId* internal_default_instance() {
    return reinterpret_cast<const ChainInventory_BlockId*>(
               &_ChainInventory_BlockId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(ChainInventory_BlockId& a, ChainInventory_BlockId& b) {
    a.Swap(&b);
  }
  inline void Swap(ChainInventory_BlockId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChainInventory_BlockId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChainInventory_BlockId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChainInventory_BlockId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChainInventory_BlockId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChainInventory_BlockId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChainInventory_BlockId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ChainInventory.BlockId";
  }
  protected:
  explicit ChainInventory_BlockId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kNumberFieldNumber = 2,
  };
  // bytes hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // int64 number = 2;
  void clear_number();
  int64_t number() const;
  void set_number(int64_t value);
  private:
  int64_t _internal_number() const;
  void _internal_set_number(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ChainInventory.BlockId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  int64_t number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class ChainInventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ChainInventory) */ {
 public:
  inline ChainInventory() : ChainInventory(nullptr) {}
  ~ChainInventory() override;
  explicit constexpr ChainInventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChainInventory(const ChainInventory& from);
  ChainInventory(ChainInventory&& from) noexcept
    : ChainInventory() {
    *this = ::std::move(from);
  }

  inline ChainInventory& operator=(const ChainInventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChainInventory& operator=(ChainInventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChainInventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChainInventory* internal_default_instance() {
    return reinterpret_cast<const ChainInventory*>(
               &_ChainInventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(ChainInventory& a, ChainInventory& b) {
    a.Swap(&b);
  }
  inline void Swap(ChainInventory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChainInventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChainInventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChainInventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChainInventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChainInventory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChainInventory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ChainInventory";
  }
  protected:
  explicit ChainInventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChainInventory_BlockId BlockId;

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
    kRemainNumFieldNumber = 2,
  };
  // repeated .protocol.ChainInventory.BlockId ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  ::protocol::ChainInventory_BlockId* mutable_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ChainInventory_BlockId >*
      mutable_ids();
  private:
  const ::protocol::ChainInventory_BlockId& _internal_ids(int index) const;
  ::protocol::ChainInventory_BlockId* _internal_add_ids();
  public:
  const ::protocol::ChainInventory_BlockId& ids(int index) const;
  ::protocol::ChainInventory_BlockId* add_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ChainInventory_BlockId >&
      ids() const;

  // int64 remain_num = 2;
  void clear_remain_num();
  int64_t remain_num() const;
  void set_remain_num(int64_t value);
  private:
  int64_t _internal_remain_num() const;
  void _internal_set_remain_num(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.ChainInventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ChainInventory_BlockId > ids_;
  int64_t remain_num_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class BlockInventory_BlockId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockInventory.BlockId) */ {
 public:
  inline BlockInventory_BlockId() : BlockInventory_BlockId(nullptr) {}
  ~BlockInventory_BlockId() override;
  explicit constexpr BlockInventory_BlockId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockInventory_BlockId(const BlockInventory_BlockId& from);
  BlockInventory_BlockId(BlockInventory_BlockId&& from) noexcept
    : BlockInventory_BlockId() {
    *this = ::std::move(from);
  }

  inline BlockInventory_BlockId& operator=(const BlockInventory_BlockId& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockInventory_BlockId& operator=(BlockInventory_BlockId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockInventory_BlockId& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockInventory_BlockId* internal_default_instance() {
    return reinterpret_cast<const BlockInventory_BlockId*>(
               &_BlockInventory_BlockId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(BlockInventory_BlockId& a, BlockInventory_BlockId& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockInventory_BlockId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockInventory_BlockId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockInventory_BlockId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockInventory_BlockId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockInventory_BlockId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockInventory_BlockId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockInventory_BlockId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockInventory.BlockId";
  }
  protected:
  explicit BlockInventory_BlockId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kNumberFieldNumber = 2,
  };
  // bytes hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // int64 number = 2;
  void clear_number();
  int64_t number() const;
  void set_number(int64_t value);
  private:
  int64_t _internal_number() const;
  void _internal_set_number(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.BlockInventory.BlockId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  int64_t number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class BlockInventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.BlockInventory) */ {
 public:
  inline BlockInventory() : BlockInventory(nullptr) {}
  ~BlockInventory() override;
  explicit constexpr BlockInventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockInventory(const BlockInventory& from);
  BlockInventory(BlockInventory&& from) noexcept
    : BlockInventory() {
    *this = ::std::move(from);
  }

  inline BlockInventory& operator=(const BlockInventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockInventory& operator=(BlockInventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockInventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockInventory* internal_default_instance() {
    return reinterpret_cast<const BlockInventory*>(
               &_BlockInventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(BlockInventory& a, BlockInventory& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockInventory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockInventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockInventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockInventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockInventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockInventory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockInventory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.BlockInventory";
  }
  protected:
  explicit BlockInventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BlockInventory_BlockId BlockId;

  typedef BlockInventory_Type Type;
  static constexpr Type SYNC =
    BlockInventory_Type_SYNC;
  static constexpr Type ADVTISE =
    BlockInventory_Type_ADVTISE;
  static constexpr Type FETCH =
    BlockInventory_Type_FETCH;
  static inline bool Type_IsValid(int value) {
    return BlockInventory_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    BlockInventory_Type_Type_MIN;
  static constexpr Type Type_MAX =
    BlockInventory_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    BlockInventory_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return BlockInventory_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return BlockInventory_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return BlockInventory_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // repeated .protocol.BlockInventory.BlockId ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  ::protocol::BlockInventory_BlockId* mutable_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockInventory_BlockId >*
      mutable_ids();
  private:
  const ::protocol::BlockInventory_BlockId& _internal_ids(int index) const;
  ::protocol::BlockInventory_BlockId* _internal_add_ids();
  public:
  const ::protocol::BlockInventory_BlockId& ids(int index) const;
  ::protocol::BlockInventory_BlockId* add_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockInventory_BlockId >&
      ids() const;

  // .protocol.BlockInventory.Type type = 2;
  void clear_type();
  ::protocol::BlockInventory_Type type() const;
  void set_type(::protocol::BlockInventory_Type value);
  private:
  ::protocol::BlockInventory_Type _internal_type() const;
  void _internal_set_type(::protocol::BlockInventory_Type value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.BlockInventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockInventory_BlockId > ids_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Inventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Inventory) */ {
 public:
  inline Inventory() : Inventory(nullptr) {}
  ~Inventory() override;
  explicit constexpr Inventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Inventory(const Inventory& from);
  Inventory(Inventory&& from) noexcept
    : Inventory() {
    *this = ::std::move(from);
  }

  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inventory& operator=(Inventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Inventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const Inventory* internal_default_instance() {
    return reinterpret_cast<const Inventory*>(
               &_Inventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(Inventory& a, Inventory& b) {
    a.Swap(&b);
  }
  inline void Swap(Inventory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Inventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Inventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Inventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Inventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Inventory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Inventory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Inventory";
  }
  protected:
  explicit Inventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Inventory_InventoryType InventoryType;
  static constexpr InventoryType TRX =
    Inventory_InventoryType_TRX;
  static constexpr InventoryType BLOCK =
    Inventory_InventoryType_BLOCK;
  static inline bool InventoryType_IsValid(int value) {
    return Inventory_InventoryType_IsValid(value);
  }
  static constexpr InventoryType InventoryType_MIN =
    Inventory_InventoryType_InventoryType_MIN;
  static constexpr InventoryType InventoryType_MAX =
    Inventory_InventoryType_InventoryType_MAX;
  static constexpr int InventoryType_ARRAYSIZE =
    Inventory_InventoryType_InventoryType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InventoryType_descriptor() {
    return Inventory_InventoryType_descriptor();
  }
  template<typename T>
  static inline const std::string& InventoryType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InventoryType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InventoryType_Name.");
    return Inventory_InventoryType_Name(enum_t_value);
  }
  static inline bool InventoryType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InventoryType* value) {
    return Inventory_InventoryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated bytes ids = 2;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  const std::string& ids(int index) const;
  std::string* mutable_ids(int index);
  void set_ids(int index, const std::string& value);
  void set_ids(int index, std::string&& value);
  void set_ids(int index, const char* value);
  void set_ids(int index, const void* value, size_t size);
  std::string* add_ids();
  void add_ids(const std::string& value);
  void add_ids(std::string&& value);
  void add_ids(const char* value);
  void add_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ids();
  private:
  const std::string& _internal_ids(int index) const;
  std::string* _internal_add_ids();
  public:

  // .protocol.Inventory.InventoryType type = 1;
  void clear_type();
  ::protocol::Inventory_InventoryType type() const;
  void set_type(::protocol::Inventory_InventoryType value);
  private:
  ::protocol::Inventory_InventoryType _internal_type() const;
  void _internal_set_type(::protocol::Inventory_InventoryType value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Inventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ids_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class Items final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.Items) */ {
 public:
  inline Items() : Items(nullptr) {}
  ~Items() override;
  explicit constexpr Items(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Items(const Items& from);
  Items(Items&& from) noexcept
    : Items() {
    *this = ::std::move(from);
  }

  inline Items& operator=(const Items& from) {
    CopyFrom(from);
    return *this;
  }
  inline Items& operator=(Items&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Items& default_instance() {
    return *internal_default_instance();
  }
  static inline const Items* internal_default_instance() {
    return reinterpret_cast<const Items*>(
               &_Items_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(Items& a, Items& b) {
    a.Swap(&b);
  }
  inline void Swap(Items* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Items* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Items* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Items>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Items& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Items& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Items* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.Items";
  }
  protected:
  explicit Items(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Items_ItemType ItemType;
  static constexpr ItemType ERR =
    Items_ItemType_ERR;
  static constexpr ItemType TRX =
    Items_ItemType_TRX;
  static constexpr ItemType BLOCK =
    Items_ItemType_BLOCK;
  static constexpr ItemType BLOCKHEADER =
    Items_ItemType_BLOCKHEADER;
  static inline bool ItemType_IsValid(int value) {
    return Items_ItemType_IsValid(value);
  }
  static constexpr ItemType ItemType_MIN =
    Items_ItemType_ItemType_MIN;
  static constexpr ItemType ItemType_MAX =
    Items_ItemType_ItemType_MAX;
  static constexpr int ItemType_ARRAYSIZE =
    Items_ItemType_ItemType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ItemType_descriptor() {
    return Items_ItemType_descriptor();
  }
  template<typename T>
  static inline const std::string& ItemType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ItemType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ItemType_Name.");
    return Items_ItemType_Name(enum_t_value);
  }
  static inline bool ItemType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ItemType* value) {
    return Items_ItemType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 2,
    kBlockHeadersFieldNumber = 3,
    kTransactionsFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // repeated .protocol.Block blocks = 2;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::protocol::Block* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Block >*
      mutable_blocks();
  private:
  const ::protocol::Block& _internal_blocks(int index) const;
  ::protocol::Block* _internal_add_blocks();
  public:
  const ::protocol::Block& blocks(int index) const;
  ::protocol::Block* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Block >&
      blocks() const;

  // repeated .protocol.BlockHeader block_headers = 3;
  int block_headers_size() const;
  private:
  int _internal_block_headers_size() const;
  public:
  void clear_block_headers();
  ::protocol::BlockHeader* mutable_block_headers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockHeader >*
      mutable_block_headers();
  private:
  const ::protocol::BlockHeader& _internal_block_headers(int index) const;
  ::protocol::BlockHeader* _internal_add_block_headers();
  public:
  const ::protocol::BlockHeader& block_headers(int index) const;
  ::protocol::BlockHeader* add_block_headers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockHeader >&
      block_headers() const;

  // repeated .protocol.Transaction transactions = 4;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  ::protocol::Transaction* mutable_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >*
      mutable_transactions();
  private:
  const ::protocol::Transaction& _internal_transactions(int index) const;
  ::protocol::Transaction* _internal_add_transactions();
  public:
  const ::protocol::Transaction& transactions(int index) const;
  ::protocol::Transaction* add_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >&
      transactions() const;

  // .protocol.Items.ItemType type = 1;
  void clear_type();
  ::protocol::Items_ItemType type() const;
  void set_type(::protocol::Items_ItemType value);
  private:
  ::protocol::Items_ItemType _internal_type() const;
  void _internal_set_type(::protocol::Items_ItemType value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.Items)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Block > blocks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockHeader > block_headers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction > transactions_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class DynamicProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DynamicProperties) */ {
 public:
  inline DynamicProperties() : DynamicProperties(nullptr) {}
  ~DynamicProperties() override;
  explicit constexpr DynamicProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DynamicProperties(const DynamicProperties& from);
  DynamicProperties(DynamicProperties&& from) noexcept
    : DynamicProperties() {
    *this = ::std::move(from);
  }

  inline DynamicProperties& operator=(const DynamicProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicProperties& operator=(DynamicProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DynamicProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const DynamicProperties* internal_default_instance() {
    return reinterpret_cast<const DynamicProperties*>(
               &_DynamicProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(DynamicProperties& a, DynamicProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(DynamicProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DynamicProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DynamicProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DynamicProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DynamicProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DynamicProperties& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DynamicProperties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DynamicProperties";
  }
  protected:
  explicit DynamicProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastSolidityBlockNumFieldNumber = 1,
  };
  // int64 last_solidity_block_num = 1;
  void clear_last_solidity_block_num();
  int64_t last_solidity_block_num() const;
  void set_last_solidity_block_num(int64_t value);
  private:
  int64_t _internal_last_solidity_block_num() const;
  void _internal_set_last_solidity_block_num(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.DynamicProperties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t last_solidity_block_num_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class DisconnectMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DisconnectMessage) */ {
 public:
  inline DisconnectMessage() : DisconnectMessage(nullptr) {}
  ~DisconnectMessage() override;
  explicit constexpr DisconnectMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisconnectMessage(const DisconnectMessage& from);
  DisconnectMessage(DisconnectMessage&& from) noexcept
    : DisconnectMessage() {
    *this = ::std::move(from);
  }

  inline DisconnectMessage& operator=(const DisconnectMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectMessage& operator=(DisconnectMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisconnectMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectMessage* internal_default_instance() {
    return reinterpret_cast<const DisconnectMessage*>(
               &_DisconnectMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(DisconnectMessage& a, DisconnectMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisconnectMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DisconnectMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisconnectMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DisconnectMessage";
  }
  protected:
  explicit DisconnectMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
  };
  // .protocol.ReasonCode reason = 1;
  void clear_reason();
  ::protocol::ReasonCode reason() const;
  void set_reason(::protocol::ReasonCode value);
  private:
  ::protocol::ReasonCode _internal_reason() const;
  void _internal_set_reason(::protocol::ReasonCode value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.DisconnectMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class HelloMessage_BlockId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.HelloMessage.BlockId) */ {
 public:
  inline HelloMessage_BlockId() : HelloMessage_BlockId(nullptr) {}
  ~HelloMessage_BlockId() override;
  explicit constexpr HelloMessage_BlockId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloMessage_BlockId(const HelloMessage_BlockId& from);
  HelloMessage_BlockId(HelloMessage_BlockId&& from) noexcept
    : HelloMessage_BlockId() {
    *this = ::std::move(from);
  }

  inline HelloMessage_BlockId& operator=(const HelloMessage_BlockId& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloMessage_BlockId& operator=(HelloMessage_BlockId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloMessage_BlockId& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloMessage_BlockId* internal_default_instance() {
    return reinterpret_cast<const HelloMessage_BlockId*>(
               &_HelloMessage_BlockId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(HelloMessage_BlockId& a, HelloMessage_BlockId& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloMessage_BlockId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloMessage_BlockId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloMessage_BlockId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloMessage_BlockId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloMessage_BlockId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HelloMessage_BlockId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloMessage_BlockId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.HelloMessage.BlockId";
  }
  protected:
  explicit HelloMessage_BlockId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kNumberFieldNumber = 2,
  };
  // bytes hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // int64 number = 2;
  void clear_number();
  int64_t number() const;
  void set_number(int64_t value);
  private:
  int64_t _internal_number() const;
  void _internal_set_number(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.HelloMessage.BlockId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  int64_t number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class HelloMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.HelloMessage) */ {
 public:
  inline HelloMessage() : HelloMessage(nullptr) {}
  ~HelloMessage() override;
  explicit constexpr HelloMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloMessage(const HelloMessage& from);
  HelloMessage(HelloMessage&& from) noexcept
    : HelloMessage() {
    *this = ::std::move(from);
  }

  inline HelloMessage& operator=(const HelloMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloMessage& operator=(HelloMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloMessage* internal_default_instance() {
    return reinterpret_cast<const HelloMessage*>(
               &_HelloMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(HelloMessage& a, HelloMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HelloMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.HelloMessage";
  }
  protected:
  explicit HelloMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HelloMessage_BlockId BlockId;

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 7,
    kSignatureFieldNumber = 8,
    kFromFieldNumber = 1,
    kGenesisBlockIdFieldNumber = 4,
    kSolidBlockIdFieldNumber = 5,
    kHeadBlockIdFieldNumber = 6,
    kTimestampFieldNumber = 3,
    kVersionFieldNumber = 2,
  };
  // bytes address = 7;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bytes signature = 8;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .protocol.Endpoint from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::protocol::Endpoint& from() const;
  PROTOBUF_NODISCARD ::protocol::Endpoint* release_from();
  ::protocol::Endpoint* mutable_from();
  void set_allocated_from(::protocol::Endpoint* from);
  private:
  const ::protocol::Endpoint& _internal_from() const;
  ::protocol::Endpoint* _internal_mutable_from();
  public:
  void unsafe_arena_set_allocated_from(
      ::protocol::Endpoint* from);
  ::protocol::Endpoint* unsafe_arena_release_from();

  // .protocol.HelloMessage.BlockId genesisBlockId = 4;
  bool has_genesisblockid() const;
  private:
  bool _internal_has_genesisblockid() const;
  public:
  void clear_genesisblockid();
  const ::protocol::HelloMessage_BlockId& genesisblockid() const;
  PROTOBUF_NODISCARD ::protocol::HelloMessage_BlockId* release_genesisblockid();
  ::protocol::HelloMessage_BlockId* mutable_genesisblockid();
  void set_allocated_genesisblockid(::protocol::HelloMessage_BlockId* genesisblockid);
  private:
  const ::protocol::HelloMessage_BlockId& _internal_genesisblockid() const;
  ::protocol::HelloMessage_BlockId* _internal_mutable_genesisblockid();
  public:
  void unsafe_arena_set_allocated_genesisblockid(
      ::protocol::HelloMessage_BlockId* genesisblockid);
  ::protocol::HelloMessage_BlockId* unsafe_arena_release_genesisblockid();

  // .protocol.HelloMessage.BlockId solidBlockId = 5;
  bool has_solidblockid() const;
  private:
  bool _internal_has_solidblockid() const;
  public:
  void clear_solidblockid();
  const ::protocol::HelloMessage_BlockId& solidblockid() const;
  PROTOBUF_NODISCARD ::protocol::HelloMessage_BlockId* release_solidblockid();
  ::protocol::HelloMessage_BlockId* mutable_solidblockid();
  void set_allocated_solidblockid(::protocol::HelloMessage_BlockId* solidblockid);
  private:
  const ::protocol::HelloMessage_BlockId& _internal_solidblockid() const;
  ::protocol::HelloMessage_BlockId* _internal_mutable_solidblockid();
  public:
  void unsafe_arena_set_allocated_solidblockid(
      ::protocol::HelloMessage_BlockId* solidblockid);
  ::protocol::HelloMessage_BlockId* unsafe_arena_release_solidblockid();

  // .protocol.HelloMessage.BlockId headBlockId = 6;
  bool has_headblockid() const;
  private:
  bool _internal_has_headblockid() const;
  public:
  void clear_headblockid();
  const ::protocol::HelloMessage_BlockId& headblockid() const;
  PROTOBUF_NODISCARD ::protocol::HelloMessage_BlockId* release_headblockid();
  ::protocol::HelloMessage_BlockId* mutable_headblockid();
  void set_allocated_headblockid(::protocol::HelloMessage_BlockId* headblockid);
  private:
  const ::protocol::HelloMessage_BlockId& _internal_headblockid() const;
  ::protocol::HelloMessage_BlockId* _internal_mutable_headblockid();
  public:
  void unsafe_arena_set_allocated_headblockid(
      ::protocol::HelloMessage_BlockId* headblockid);
  ::protocol::HelloMessage_BlockId* unsafe_arena_release_headblockid();

  // int64 timestamp = 3;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int32 version = 2;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.HelloMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::protocol::Endpoint* from_;
  ::protocol::HelloMessage_BlockId* genesisblockid_;
  ::protocol::HelloMessage_BlockId* solidblockid_;
  ::protocol::HelloMessage_BlockId* headblockid_;
  int64_t timestamp_;
  int32_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class InternalTransaction_CallValueInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.InternalTransaction.CallValueInfo) */ {
 public:
  inline InternalTransaction_CallValueInfo() : InternalTransaction_CallValueInfo(nullptr) {}
  ~InternalTransaction_CallValueInfo() override;
  explicit constexpr InternalTransaction_CallValueInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternalTransaction_CallValueInfo(const InternalTransaction_CallValueInfo& from);
  InternalTransaction_CallValueInfo(InternalTransaction_CallValueInfo&& from) noexcept
    : InternalTransaction_CallValueInfo() {
    *this = ::std::move(from);
  }

  inline InternalTransaction_CallValueInfo& operator=(const InternalTransaction_CallValueInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternalTransaction_CallValueInfo& operator=(InternalTransaction_CallValueInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternalTransaction_CallValueInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternalTransaction_CallValueInfo* internal_default_instance() {
    return reinterpret_cast<const InternalTransaction_CallValueInfo*>(
               &_InternalTransaction_CallValueInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(InternalTransaction_CallValueInfo& a, InternalTransaction_CallValueInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(InternalTransaction_CallValueInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternalTransaction_CallValueInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternalTransaction_CallValueInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternalTransaction_CallValueInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InternalTransaction_CallValueInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InternalTransaction_CallValueInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternalTransaction_CallValueInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.InternalTransaction.CallValueInfo";
  }
  protected:
  explicit InternalTransaction_CallValueInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenIdFieldNumber = 2,
    kCallValueFieldNumber = 1,
  };
  // string tokenId = 2;
  void clear_tokenid();
  const std::string& tokenid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tokenid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tokenid();
  PROTOBUF_NODISCARD std::string* release_tokenid();
  void set_allocated_tokenid(std::string* tokenid);
  private:
  const std::string& _internal_tokenid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tokenid(const std::string& value);
  std::string* _internal_mutable_tokenid();
  public:

  // int64 callValue = 1;
  void clear_callvalue();
  int64_t callvalue() const;
  void set_callvalue(int64_t value);
  private:
  int64_t _internal_callvalue() const;
  void _internal_set_callvalue(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.InternalTransaction.CallValueInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tokenid_;
  int64_t callvalue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class InternalTransaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.InternalTransaction) */ {
 public:
  inline InternalTransaction() : InternalTransaction(nullptr) {}
  ~InternalTransaction() override;
  explicit constexpr InternalTransaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternalTransaction(const InternalTransaction& from);
  InternalTransaction(InternalTransaction&& from) noexcept
    : InternalTransaction() {
    *this = ::std::move(from);
  }

  inline InternalTransaction& operator=(const InternalTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternalTransaction& operator=(InternalTransaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternalTransaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternalTransaction* internal_default_instance() {
    return reinterpret_cast<const InternalTransaction*>(
               &_InternalTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(InternalTransaction& a, InternalTransaction& b) {
    a.Swap(&b);
  }
  inline void Swap(InternalTransaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternalTransaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternalTransaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternalTransaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InternalTransaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InternalTransaction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternalTransaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.InternalTransaction";
  }
  protected:
  explicit InternalTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InternalTransaction_CallValueInfo CallValueInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kCallValueInfoFieldNumber = 4,
    kHashFieldNumber = 1,
    kCallerAddressFieldNumber = 2,
    kTransferToAddressFieldNumber = 3,
    kNoteFieldNumber = 5,
    kExtraFieldNumber = 7,
    kRejectedFieldNumber = 6,
  };
  // repeated .protocol.InternalTransaction.CallValueInfo callValueInfo = 4;
  int callvalueinfo_size() const;
  private:
  int _internal_callvalueinfo_size() const;
  public:
  void clear_callvalueinfo();
  ::protocol::InternalTransaction_CallValueInfo* mutable_callvalueinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::InternalTransaction_CallValueInfo >*
      mutable_callvalueinfo();
  private:
  const ::protocol::InternalTransaction_CallValueInfo& _internal_callvalueinfo(int index) const;
  ::protocol::InternalTransaction_CallValueInfo* _internal_add_callvalueinfo();
  public:
  const ::protocol::InternalTransaction_CallValueInfo& callvalueinfo(int index) const;
  ::protocol::InternalTransaction_CallValueInfo* add_callvalueinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::InternalTransaction_CallValueInfo >&
      callvalueinfo() const;

  // bytes hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // bytes caller_address = 2;
  void clear_caller_address();
  const std::string& caller_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caller_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caller_address();
  PROTOBUF_NODISCARD std::string* release_caller_address();
  void set_allocated_caller_address(std::string* caller_address);
  private:
  const std::string& _internal_caller_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caller_address(const std::string& value);
  std::string* _internal_mutable_caller_address();
  public:

  // bytes transferTo_address = 3;
  void clear_transferto_address();
  const std::string& transferto_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transferto_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transferto_address();
  PROTOBUF_NODISCARD std::string* release_transferto_address();
  void set_allocated_transferto_address(std::string* transferto_address);
  private:
  const std::string& _internal_transferto_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transferto_address(const std::string& value);
  std::string* _internal_mutable_transferto_address();
  public:

  // bytes note = 5;
  void clear_note();
  const std::string& note() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_note(ArgT0&& arg0, ArgT... args);
  std::string* mutable_note();
  PROTOBUF_NODISCARD std::string* release_note();
  void set_allocated_note(std::string* note);
  private:
  const std::string& _internal_note() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_note(const std::string& value);
  std::string* _internal_mutable_note();
  public:

  // string extra = 7;
  void clear_extra();
  const std::string& extra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra();
  PROTOBUF_NODISCARD std::string* release_extra();
  void set_allocated_extra(std::string* extra);
  private:
  const std::string& _internal_extra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra(const std::string& value);
  std::string* _internal_mutable_extra();
  public:

  // bool rejected = 6;
  void clear_rejected();
  bool rejected() const;
  void set_rejected(bool value);
  private:
  bool _internal_rejected() const;
  void _internal_set_rejected(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.InternalTransaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::InternalTransaction_CallValueInfo > callvalueinfo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transferto_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr note_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_;
  bool rejected_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class DelegatedResourceAccountIndex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.DelegatedResourceAccountIndex) */ {
 public:
  inline DelegatedResourceAccountIndex() : DelegatedResourceAccountIndex(nullptr) {}
  ~DelegatedResourceAccountIndex() override;
  explicit constexpr DelegatedResourceAccountIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelegatedResourceAccountIndex(const DelegatedResourceAccountIndex& from);
  DelegatedResourceAccountIndex(DelegatedResourceAccountIndex&& from) noexcept
    : DelegatedResourceAccountIndex() {
    *this = ::std::move(from);
  }

  inline DelegatedResourceAccountIndex& operator=(const DelegatedResourceAccountIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegatedResourceAccountIndex& operator=(DelegatedResourceAccountIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegatedResourceAccountIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegatedResourceAccountIndex* internal_default_instance() {
    return reinterpret_cast<const DelegatedResourceAccountIndex*>(
               &_DelegatedResourceAccountIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(DelegatedResourceAccountIndex& a, DelegatedResourceAccountIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegatedResourceAccountIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegatedResourceAccountIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelegatedResourceAccountIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelegatedResourceAccountIndex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelegatedResourceAccountIndex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DelegatedResourceAccountIndex& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegatedResourceAccountIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.DelegatedResourceAccountIndex";
  }
  protected:
  explicit DelegatedResourceAccountIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromAccountsFieldNumber = 2,
    kToAccountsFieldNumber = 3,
    kAccountFieldNumber = 1,
  };
  // repeated bytes fromAccounts = 2;
  int fromaccounts_size() const;
  private:
  int _internal_fromaccounts_size() const;
  public:
  void clear_fromaccounts();
  const std::string& fromaccounts(int index) const;
  std::string* mutable_fromaccounts(int index);
  void set_fromaccounts(int index, const std::string& value);
  void set_fromaccounts(int index, std::string&& value);
  void set_fromaccounts(int index, const char* value);
  void set_fromaccounts(int index, const void* value, size_t size);
  std::string* add_fromaccounts();
  void add_fromaccounts(const std::string& value);
  void add_fromaccounts(std::string&& value);
  void add_fromaccounts(const char* value);
  void add_fromaccounts(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fromaccounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fromaccounts();
  private:
  const std::string& _internal_fromaccounts(int index) const;
  std::string* _internal_add_fromaccounts();
  public:

  // repeated bytes toAccounts = 3;
  int toaccounts_size() const;
  private:
  int _internal_toaccounts_size() const;
  public:
  void clear_toaccounts();
  const std::string& toaccounts(int index) const;
  std::string* mutable_toaccounts(int index);
  void set_toaccounts(int index, const std::string& value);
  void set_toaccounts(int index, std::string&& value);
  void set_toaccounts(int index, const char* value);
  void set_toaccounts(int index, const void* value, size_t size);
  std::string* add_toaccounts();
  void add_toaccounts(const std::string& value);
  void add_toaccounts(std::string&& value);
  void add_toaccounts(const char* value);
  void add_toaccounts(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& toaccounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_toaccounts();
  private:
  const std::string& _internal_toaccounts(int index) const;
  std::string* _internal_add_toaccounts();
  public:

  // bytes account = 1;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // @@protoc_insertion_point(class_scope:protocol.DelegatedResourceAccountIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fromaccounts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> toaccounts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo_CheatWitnessInfoMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeInfo_CheatWitnessInfoMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeInfo_CheatWitnessInfoMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  NodeInfo_CheatWitnessInfoMapEntry_DoNotUse();
  explicit constexpr NodeInfo_CheatWitnessInfoMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NodeInfo_CheatWitnessInfoMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NodeInfo_CheatWitnessInfoMapEntry_DoNotUse& other);
  static const NodeInfo_CheatWitnessInfoMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NodeInfo_CheatWitnessInfoMapEntry_DoNotUse*>(&_NodeInfo_CheatWitnessInfoMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.NodeInfo.CheatWitnessInfoMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "protocol.NodeInfo.CheatWitnessInfoMapEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class NodeInfo_PeerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.NodeInfo.PeerInfo) */ {
 public:
  inline NodeInfo_PeerInfo() : NodeInfo_PeerInfo(nullptr) {}
  ~NodeInfo_PeerInfo() override;
  explicit constexpr NodeInfo_PeerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfo_PeerInfo(const NodeInfo_PeerInfo& from);
  NodeInfo_PeerInfo(NodeInfo_PeerInfo&& from) noexcept
    : NodeInfo_PeerInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo_PeerInfo& operator=(const NodeInfo_PeerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo_PeerInfo& operator=(NodeInfo_PeerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfo_PeerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo_PeerInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo_PeerInfo*>(
               &_NodeInfo_PeerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(NodeInfo_PeerInfo& a, NodeInfo_PeerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo_PeerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo_PeerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfo_PeerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfo_PeerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfo_PeerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeInfo_PeerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo_PeerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.NodeInfo.PeerInfo";
  }
  protected:
  explicit NodeInfo_PeerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastSyncBlockFieldNumber = 1,
    kHostFieldNumber = 8,
    kNodeIdFieldNumber = 10,
    kHeadBlockWeBothHaveFieldNumber = 18,
    kLocalDisconnectReasonFieldNumber = 24,
    kRemoteDisconnectReasonFieldNumber = 25,
    kRemainNumFieldNumber = 2,
    kLastBlockUpdateTimeFieldNumber = 3,
    kHeadBlockTimeWeBothHaveFieldNumber = 5,
    kPortFieldNumber = 9,
    kSyncFlagFieldNumber = 4,
    kNeedSyncFromPeerFieldNumber = 6,
    kNeedSyncFromUsFieldNumber = 7,
    kIsActiveFieldNumber = 19,
    kConnectTimeFieldNumber = 11,
    kAvgLatencyFieldNumber = 12,
    kSyncToFetchSizePeekNumFieldNumber = 14,
    kSyncToFetchSizeFieldNumber = 13,
    kSyncBlockRequestedSizeFieldNumber = 15,
    kUnFetchSynNumFieldNumber = 16,
    kBlockInPorcSizeFieldNumber = 17,
    kScoreFieldNumber = 20,
    kInFlowFieldNumber = 22,
    kNodeCountFieldNumber = 21,
    kDisconnectTimesFieldNumber = 23,
  };
  // string lastSyncBlock = 1;
  void clear_lastsyncblock();
  const std::string& lastsyncblock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lastsyncblock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lastsyncblock();
  PROTOBUF_NODISCARD std::string* release_lastsyncblock();
  void set_allocated_lastsyncblock(std::string* lastsyncblock);
  private:
  const std::string& _internal_lastsyncblock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lastsyncblock(const std::string& value);
  std::string* _internal_mutable_lastsyncblock();
  public:

  // string host = 8;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string nodeId = 10;
  void clear_nodeid();
  const std::string& nodeid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nodeid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nodeid();
  PROTOBUF_NODISCARD std::string* release_nodeid();
  void set_allocated_nodeid(std::string* nodeid);
  private:
  const std::string& _internal_nodeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodeid(const std::string& value);
  std::string* _internal_mutable_nodeid();
  public:

  // string headBlockWeBothHave = 18;
  void clear_headblockwebothhave();
  const std::string& headblockwebothhave() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_headblockwebothhave(ArgT0&& arg0, ArgT... args);
  std::string* mutable_headblockwebothhave();
  PROTOBUF_NODISCARD std::string* release_headblockwebothhave();
  void set_allocated_headblockwebothhave(std::string* headblockwebothhave);
  private:
  const std::string& _internal_headblockwebothhave() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_headblockwebothhave(const std::string& value);
  std::string* _internal_mutable_headblockwebothhave();
  public:

  // string localDisconnectReason = 24;
  void clear_localdisconnectreason();
  const std::string& localdisconnectreason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_localdisconnectreason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_localdisconnectreason();
  PROTOBUF_NODISCARD std::string* release_localdisconnectreason();
  void set_allocated_localdisconnectreason(std::string* localdisconnectreason);
  private:
  const std::string& _internal_localdisconnectreason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_localdisconnectreason(const std::string& value);
  std::string* _internal_mutable_localdisconnectreason();
  public:

  // string remoteDisconnectReason = 25;
  void clear_remotedisconnectreason();
  const std::string& remotedisconnectreason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remotedisconnectreason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remotedisconnectreason();
  PROTOBUF_NODISCARD std::string* release_remotedisconnectreason();
  void set_allocated_remotedisconnectreason(std::string* remotedisconnectreason);
  private:
  const std::string& _internal_remotedisconnectreason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remotedisconnectreason(const std::string& value);
  std::string* _internal_mutable_remotedisconnectreason();
  public:

  // int64 remainNum = 2;
  void clear_remainnum();
  int64_t remainnum() const;
  void set_remainnum(int64_t value);
  private:
  int64_t _internal_remainnum() const;
  void _internal_set_remainnum(int64_t value);
  public:

  // int64 lastBlockUpdateTime = 3;
  void clear_lastblockupdatetime();
  int64_t lastblockupdatetime() const;
  void set_lastblockupdatetime(int64_t value);
  private:
  int64_t _internal_lastblockupdatetime() const;
  void _internal_set_lastblockupdatetime(int64_t value);
  public:

  // int64 headBlockTimeWeBothHave = 5;
  void clear_headblocktimewebothhave();
  int64_t headblocktimewebothhave() const;
  void set_headblocktimewebothhave(int64_t value);
  private:
  int64_t _internal_headblocktimewebothhave() const;
  void _internal_set_headblocktimewebothhave(int64_t value);
  public:

  // int32 port = 9;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // bool syncFlag = 4;
  void clear_syncflag();
  bool syncflag() const;
  void set_syncflag(bool value);
  private:
  bool _internal_syncflag() const;
  void _internal_set_syncflag(bool value);
  public:

  // bool needSyncFromPeer = 6;
  void clear_needsyncfrompeer();
  bool needsyncfrompeer() const;
  void set_needsyncfrompeer(bool value);
  private:
  bool _internal_needsyncfrompeer() const;
  void _internal_set_needsyncfrompeer(bool value);
  public:

  // bool needSyncFromUs = 7;
  void clear_needsyncfromus();
  bool needsyncfromus() const;
  void set_needsyncfromus(bool value);
  private:
  bool _internal_needsyncfromus() const;
  void _internal_set_needsyncfromus(bool value);
  public:

  // bool isActive = 19;
  void clear_isactive();
  bool isactive() const;
  void set_isactive(bool value);
  private:
  bool _internal_isactive() const;
  void _internal_set_isactive(bool value);
  public:

  // int64 connectTime = 11;
  void clear_connecttime();
  int64_t connecttime() const;
  void set_connecttime(int64_t value);
  private:
  int64_t _internal_connecttime() const;
  void _internal_set_connecttime(int64_t value);
  public:

  // double avgLatency = 12;
  void clear_avglatency();
  double avglatency() const;
  void set_avglatency(double value);
  private:
  double _internal_avglatency() const;
  void _internal_set_avglatency(double value);
  public:

  // int64 syncToFetchSizePeekNum = 14;
  void clear_synctofetchsizepeeknum();
  int64_t synctofetchsizepeeknum() const;
  void set_synctofetchsizepeeknum(int64_t value);
  private:
  int64_t _internal_synctofetchsizepeeknum() const;
  void _internal_set_synctofetchsizepeeknum(int64_t value);
  public:

  // int32 syncToFetchSize = 13;
  void clear_synctofetchsize();
  int32_t synctofetchsize() const;
  void set_synctofetchsize(int32_t value);
  private:
  int32_t _internal_synctofetchsize() const;
  void _internal_set_synctofetchsize(int32_t value);
  public:

  // int32 syncBlockRequestedSize = 15;
  void clear_syncblockrequestedsize();
  int32_t syncblockrequestedsize() const;
  void set_syncblockrequestedsize(int32_t value);
  private:
  int32_t _internal_syncblockrequestedsize() const;
  void _internal_set_syncblockrequestedsize(int32_t value);
  public:

  // int64 unFetchSynNum = 16;
  void clear_unfetchsynnum();
  int64_t unfetchsynnum() const;
  void set_unfetchsynnum(int64_t value);
  private:
  int64_t _internal_unfetchsynnum() const;
  void _internal_set_unfetchsynnum(int64_t value);
  public:

  // int32 blockInPorcSize = 17;
  void clear_blockinporcsize();
  int32_t blockinporcsize() const;
  void set_blockinporcsize(int32_t value);
  private:
  int32_t _internal_blockinporcsize() const;
  void _internal_set_blockinporcsize(int32_t value);
  public:

  // int32 score = 20;
  void clear_score();
  int32_t score() const;
  void set_score(int32_t value);
  private:
  int32_t _internal_score() const;
  void _internal_set_score(int32_t value);
  public:

  // int64 inFlow = 22;
  void clear_inflow();
  int64_t inflow() const;
  void set_inflow(int64_t value);
  private:
  int64_t _internal_inflow() const;
  void _internal_set_inflow(int64_t value);
  public:

  // int32 nodeCount = 21;
  void clear_nodecount();
  int32_t nodecount() const;
  void set_nodecount(int32_t value);
  private:
  int32_t _internal_nodecount() const;
  void _internal_set_nodecount(int32_t value);
  public:

  // int32 disconnectTimes = 23;
  void clear_disconnecttimes();
  int32_t disconnecttimes() const;
  void set_disconnecttimes(int32_t value);
  private:
  int32_t _internal_disconnecttimes() const;
  void _internal_set_disconnecttimes(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.NodeInfo.PeerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lastsyncblock_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodeid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr headblockwebothhave_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr localdisconnectreason_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remotedisconnectreason_;
  int64_t remainnum_;
  int64_t lastblockupdatetime_;
  int64_t headblocktimewebothhave_;
  int32_t port_;
  bool syncflag_;
  bool needsyncfrompeer_;
  bool needsyncfromus_;
  bool isactive_;
  int64_t connecttime_;
  double avglatency_;
  int64_t synctofetchsizepeeknum_;
  int32_t synctofetchsize_;
  int32_t syncblockrequestedsize_;
  int64_t unfetchsynnum_;
  int32_t blockinporcsize_;
  int32_t score_;
  int64_t inflow_;
  int32_t nodecount_;
  int32_t disconnecttimes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo_ConfigNodeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.NodeInfo.ConfigNodeInfo) */ {
 public:
  inline NodeInfo_ConfigNodeInfo() : NodeInfo_ConfigNodeInfo(nullptr) {}
  ~NodeInfo_ConfigNodeInfo() override;
  explicit constexpr NodeInfo_ConfigNodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfo_ConfigNodeInfo(const NodeInfo_ConfigNodeInfo& from);
  NodeInfo_ConfigNodeInfo(NodeInfo_ConfigNodeInfo&& from) noexcept
    : NodeInfo_ConfigNodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo_ConfigNodeInfo& operator=(const NodeInfo_ConfigNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo_ConfigNodeInfo& operator=(NodeInfo_ConfigNodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfo_ConfigNodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo_ConfigNodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo_ConfigNodeInfo*>(
               &_NodeInfo_ConfigNodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(NodeInfo_ConfigNodeInfo& a, NodeInfo_ConfigNodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo_ConfigNodeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo_ConfigNodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfo_ConfigNodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfo_ConfigNodeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfo_ConfigNodeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeInfo_ConfigNodeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo_ConfigNodeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.NodeInfo.ConfigNodeInfo";
  }
  protected:
  explicit NodeInfo_ConfigNodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeVersionFieldNumber = 1,
    kP2PVersionFieldNumber = 2,
    kListenPortFieldNumber = 3,
    kActiveNodeSizeFieldNumber = 5,
    kPassiveNodeSizeFieldNumber = 6,
    kSendNodeSizeFieldNumber = 7,
    kMaxConnectCountFieldNumber = 8,
    kSameIpMaxConnectCountFieldNumber = 9,
    kDiscoverEnableFieldNumber = 4,
    kSupportConstantFieldNumber = 15,
    kBackupListenPortFieldNumber = 10,
    kBackupMemberSizeFieldNumber = 11,
    kBackupPriorityFieldNumber = 12,
    kDbVersionFieldNumber = 13,
    kMinParticipationRateFieldNumber = 14,
    kMinTimeRatioFieldNumber = 16,
    kMaxTimeRatioFieldNumber = 17,
    kAllowCreationOfContractsFieldNumber = 18,
    kAllowAdaptiveEnergyFieldNumber = 19,
  };
  // string codeVersion = 1;
  void clear_codeversion();
  const std::string& codeversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_codeversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_codeversion();
  PROTOBUF_NODISCARD std::string* release_codeversion();
  void set_allocated_codeversion(std::string* codeversion);
  private:
  const std::string& _internal_codeversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codeversion(const std::string& value);
  std::string* _internal_mutable_codeversion();
  public:

  // string p2pVersion = 2;
  void clear_p2pversion();
  const std::string& p2pversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_p2pversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_p2pversion();
  PROTOBUF_NODISCARD std::string* release_p2pversion();
  void set_allocated_p2pversion(std::string* p2pversion);
  private:
  const std::string& _internal_p2pversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_p2pversion(const std::string& value);
  std::string* _internal_mutable_p2pversion();
  public:

  // int32 listenPort = 3;
  void clear_listenport();
  int32_t listenport() const;
  void set_listenport(int32_t value);
  private:
  int32_t _internal_listenport() const;
  void _internal_set_listenport(int32_t value);
  public:

  // int32 activeNodeSize = 5;
  void clear_activenodesize();
  int32_t activenodesize() const;
  void set_activenodesize(int32_t value);
  private:
  int32_t _internal_activenodesize() const;
  void _internal_set_activenodesize(int32_t value);
  public:

  // int32 passiveNodeSize = 6;
  void clear_passivenodesize();
  int32_t passivenodesize() const;
  void set_passivenodesize(int32_t value);
  private:
  int32_t _internal_passivenodesize() const;
  void _internal_set_passivenodesize(int32_t value);
  public:

  // int32 sendNodeSize = 7;
  void clear_sendnodesize();
  int32_t sendnodesize() const;
  void set_sendnodesize(int32_t value);
  private:
  int32_t _internal_sendnodesize() const;
  void _internal_set_sendnodesize(int32_t value);
  public:

  // int32 maxConnectCount = 8;
  void clear_maxconnectcount();
  int32_t maxconnectcount() const;
  void set_maxconnectcount(int32_t value);
  private:
  int32_t _internal_maxconnectcount() const;
  void _internal_set_maxconnectcount(int32_t value);
  public:

  // int32 sameIpMaxConnectCount = 9;
  void clear_sameipmaxconnectcount();
  int32_t sameipmaxconnectcount() const;
  void set_sameipmaxconnectcount(int32_t value);
  private:
  int32_t _internal_sameipmaxconnectcount() const;
  void _internal_set_sameipmaxconnectcount(int32_t value);
  public:

  // bool discoverEnable = 4;
  void clear_discoverenable();
  bool discoverenable() const;
  void set_discoverenable(bool value);
  private:
  bool _internal_discoverenable() const;
  void _internal_set_discoverenable(bool value);
  public:

  // bool supportConstant = 15;
  void clear_supportconstant();
  bool supportconstant() const;
  void set_supportconstant(bool value);
  private:
  bool _internal_supportconstant() const;
  void _internal_set_supportconstant(bool value);
  public:

  // int32 backupListenPort = 10;
  void clear_backuplistenport();
  int32_t backuplistenport() const;
  void set_backuplistenport(int32_t value);
  private:
  int32_t _internal_backuplistenport() const;
  void _internal_set_backuplistenport(int32_t value);
  public:

  // int32 backupMemberSize = 11;
  void clear_backupmembersize();
  int32_t backupmembersize() const;
  void set_backupmembersize(int32_t value);
  private:
  int32_t _internal_backupmembersize() const;
  void _internal_set_backupmembersize(int32_t value);
  public:

  // int32 backupPriority = 12;
  void clear_backuppriority();
  int32_t backuppriority() const;
  void set_backuppriority(int32_t value);
  private:
  int32_t _internal_backuppriority() const;
  void _internal_set_backuppriority(int32_t value);
  public:

  // int32 dbVersion = 13;
  void clear_dbversion();
  int32_t dbversion() const;
  void set_dbversion(int32_t value);
  private:
  int32_t _internal_dbversion() const;
  void _internal_set_dbversion(int32_t value);
  public:

  // int32 minParticipationRate = 14;
  void clear_minparticipationrate();
  int32_t minparticipationrate() const;
  void set_minparticipationrate(int32_t value);
  private:
  int32_t _internal_minparticipationrate() const;
  void _internal_set_minparticipationrate(int32_t value);
  public:

  // double minTimeRatio = 16;
  void clear_mintimeratio();
  double mintimeratio() const;
  void set_mintimeratio(double value);
  private:
  double _internal_mintimeratio() const;
  void _internal_set_mintimeratio(double value);
  public:

  // double maxTimeRatio = 17;
  void clear_maxtimeratio();
  double maxtimeratio() const;
  void set_maxtimeratio(double value);
  private:
  double _internal_maxtimeratio() const;
  void _internal_set_maxtimeratio(double value);
  public:

  // int64 allowCreationOfContracts = 18;
  void clear_allowcreationofcontracts();
  int64_t allowcreationofcontracts() const;
  void set_allowcreationofcontracts(int64_t value);
  private:
  int64_t _internal_allowcreationofcontracts() const;
  void _internal_set_allowcreationofcontracts(int64_t value);
  public:

  // int64 allowAdaptiveEnergy = 19;
  void clear_allowadaptiveenergy();
  int64_t allowadaptiveenergy() const;
  void set_allowadaptiveenergy(int64_t value);
  private:
  int64_t _internal_allowadaptiveenergy() const;
  void _internal_set_allowadaptiveenergy(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.NodeInfo.ConfigNodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codeversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p2pversion_;
  int32_t listenport_;
  int32_t activenodesize_;
  int32_t passivenodesize_;
  int32_t sendnodesize_;
  int32_t maxconnectcount_;
  int32_t sameipmaxconnectcount_;
  bool discoverenable_;
  bool supportconstant_;
  int32_t backuplistenport_;
  int32_t backupmembersize_;
  int32_t backuppriority_;
  int32_t dbversion_;
  int32_t minparticipationrate_;
  double mintimeratio_;
  double maxtimeratio_;
  int64_t allowcreationofcontracts_;
  int64_t allowadaptiveenergy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo_MachineInfo_MemoryDescInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.NodeInfo.MachineInfo.MemoryDescInfo) */ {
 public:
  inline NodeInfo_MachineInfo_MemoryDescInfo() : NodeInfo_MachineInfo_MemoryDescInfo(nullptr) {}
  ~NodeInfo_MachineInfo_MemoryDescInfo() override;
  explicit constexpr NodeInfo_MachineInfo_MemoryDescInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfo_MachineInfo_MemoryDescInfo(const NodeInfo_MachineInfo_MemoryDescInfo& from);
  NodeInfo_MachineInfo_MemoryDescInfo(NodeInfo_MachineInfo_MemoryDescInfo&& from) noexcept
    : NodeInfo_MachineInfo_MemoryDescInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo_MachineInfo_MemoryDescInfo& operator=(const NodeInfo_MachineInfo_MemoryDescInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo_MachineInfo_MemoryDescInfo& operator=(NodeInfo_MachineInfo_MemoryDescInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfo_MachineInfo_MemoryDescInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo_MachineInfo_MemoryDescInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo_MachineInfo_MemoryDescInfo*>(
               &_NodeInfo_MachineInfo_MemoryDescInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(NodeInfo_MachineInfo_MemoryDescInfo& a, NodeInfo_MachineInfo_MemoryDescInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo_MachineInfo_MemoryDescInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo_MachineInfo_MemoryDescInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfo_MachineInfo_MemoryDescInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfo_MachineInfo_MemoryDescInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfo_MachineInfo_MemoryDescInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeInfo_MachineInfo_MemoryDescInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo_MachineInfo_MemoryDescInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.NodeInfo.MachineInfo.MemoryDescInfo";
  }
  protected:
  explicit NodeInfo_MachineInfo_MemoryDescInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kInitSizeFieldNumber = 2,
    kUseSizeFieldNumber = 3,
    kMaxSizeFieldNumber = 4,
    kUseRateFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 initSize = 2;
  void clear_initsize();
  int64_t initsize() const;
  void set_initsize(int64_t value);
  private:
  int64_t _internal_initsize() const;
  void _internal_set_initsize(int64_t value);
  public:

  // int64 useSize = 3;
  void clear_usesize();
  int64_t usesize() const;
  void set_usesize(int64_t value);
  private:
  int64_t _internal_usesize() const;
  void _internal_set_usesize(int64_t value);
  public:

  // int64 maxSize = 4;
  void clear_maxsize();
  int64_t maxsize() const;
  void set_maxsize(int64_t value);
  private:
  int64_t _internal_maxsize() const;
  void _internal_set_maxsize(int64_t value);
  public:

  // double useRate = 5;
  void clear_userate();
  double userate() const;
  void set_userate(double value);
  private:
  double _internal_userate() const;
  void _internal_set_userate(double value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.NodeInfo.MachineInfo.MemoryDescInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int64_t initsize_;
  int64_t usesize_;
  int64_t maxsize_;
  double userate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo_MachineInfo_DeadLockThreadInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo) */ {
 public:
  inline NodeInfo_MachineInfo_DeadLockThreadInfo() : NodeInfo_MachineInfo_DeadLockThreadInfo(nullptr) {}
  ~NodeInfo_MachineInfo_DeadLockThreadInfo() override;
  explicit constexpr NodeInfo_MachineInfo_DeadLockThreadInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfo_MachineInfo_DeadLockThreadInfo(const NodeInfo_MachineInfo_DeadLockThreadInfo& from);
  NodeInfo_MachineInfo_DeadLockThreadInfo(NodeInfo_MachineInfo_DeadLockThreadInfo&& from) noexcept
    : NodeInfo_MachineInfo_DeadLockThreadInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo_MachineInfo_DeadLockThreadInfo& operator=(const NodeInfo_MachineInfo_DeadLockThreadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo_MachineInfo_DeadLockThreadInfo& operator=(NodeInfo_MachineInfo_DeadLockThreadInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfo_MachineInfo_DeadLockThreadInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo_MachineInfo_DeadLockThreadInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo_MachineInfo_DeadLockThreadInfo*>(
               &_NodeInfo_MachineInfo_DeadLockThreadInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(NodeInfo_MachineInfo_DeadLockThreadInfo& a, NodeInfo_MachineInfo_DeadLockThreadInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo_MachineInfo_DeadLockThreadInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo_MachineInfo_DeadLockThreadInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfo_MachineInfo_DeadLockThreadInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfo_MachineInfo_DeadLockThreadInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfo_MachineInfo_DeadLockThreadInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeInfo_MachineInfo_DeadLockThreadInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo_MachineInfo_DeadLockThreadInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.NodeInfo.MachineInfo.DeadLockThreadInfo";
  }
  protected:
  explicit NodeInfo_MachineInfo_DeadLockThreadInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLockNameFieldNumber = 2,
    kLockOwnerFieldNumber = 3,
    kStateFieldNumber = 4,
    kStackTraceFieldNumber = 7,
    kBlockTimeFieldNumber = 5,
    kWaitTimeFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string lockName = 2;
  void clear_lockname();
  const std::string& lockname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lockname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lockname();
  PROTOBUF_NODISCARD std::string* release_lockname();
  void set_allocated_lockname(std::string* lockname);
  private:
  const std::string& _internal_lockname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lockname(const std::string& value);
  std::string* _internal_mutable_lockname();
  public:

  // string lockOwner = 3;
  void clear_lockowner();
  const std::string& lockowner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lockowner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lockowner();
  PROTOBUF_NODISCARD std::string* release_lockowner();
  void set_allocated_lockowner(std::string* lockowner);
  private:
  const std::string& _internal_lockowner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lockowner(const std::string& value);
  std::string* _internal_mutable_lockowner();
  public:

  // string state = 4;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // string stackTrace = 7;
  void clear_stacktrace();
  const std::string& stacktrace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stacktrace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stacktrace();
  PROTOBUF_NODISCARD std::string* release_stacktrace();
  void set_allocated_stacktrace(std::string* stacktrace);
  private:
  const std::string& _internal_stacktrace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stacktrace(const std::string& value);
  std::string* _internal_mutable_stacktrace();
  public:

  // int64 blockTime = 5;
  void clear_blocktime();
  int64_t blocktime() const;
  void set_blocktime(int64_t value);
  private:
  int64_t _internal_blocktime() const;
  void _internal_set_blocktime(int64_t value);
  public:

  // int64 waitTime = 6;
  void clear_waittime();
  int64_t waittime() const;
  void set_waittime(int64_t value);
  private:
  int64_t _internal_waittime() const;
  void _internal_set_waittime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lockname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lockowner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stacktrace_;
  int64_t blocktime_;
  int64_t waittime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo_MachineInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.NodeInfo.MachineInfo) */ {
 public:
  inline NodeInfo_MachineInfo() : NodeInfo_MachineInfo(nullptr) {}
  ~NodeInfo_MachineInfo() override;
  explicit constexpr NodeInfo_MachineInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfo_MachineInfo(const NodeInfo_MachineInfo& from);
  NodeInfo_MachineInfo(NodeInfo_MachineInfo&& from) noexcept
    : NodeInfo_MachineInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo_MachineInfo& operator=(const NodeInfo_MachineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo_MachineInfo& operator=(NodeInfo_MachineInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfo_MachineInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo_MachineInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo_MachineInfo*>(
               &_NodeInfo_MachineInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(NodeInfo_MachineInfo& a, NodeInfo_MachineInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo_MachineInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo_MachineInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfo_MachineInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfo_MachineInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfo_MachineInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeInfo_MachineInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo_MachineInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.NodeInfo.MachineInfo";
  }
  protected:
  explicit NodeInfo_MachineInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NodeInfo_MachineInfo_MemoryDescInfo MemoryDescInfo;
  typedef NodeInfo_MachineInfo_DeadLockThreadInfo DeadLockThreadInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kMemoryDescInfoListFieldNumber = 12,
    kDeadLockThreadInfoListFieldNumber = 13,
    kJavaVersionFieldNumber = 7,
    kOsNameFieldNumber = 8,
    kThreadCountFieldNumber = 1,
    kDeadLockThreadCountFieldNumber = 2,
    kTotalMemoryFieldNumber = 4,
    kFreeMemoryFieldNumber = 5,
    kCpuRateFieldNumber = 6,
    kJvmTotalMemoryFieldNumber = 9,
    kJvmFreeMemoryFieldNumber = 10,
    kProcessCpuRateFieldNumber = 11,
    kCpuCountFieldNumber = 3,
  };
  // repeated .protocol.NodeInfo.MachineInfo.MemoryDescInfo memoryDescInfoList = 12;
  int memorydescinfolist_size() const;
  private:
  int _internal_memorydescinfolist_size() const;
  public:
  void clear_memorydescinfolist();
  ::protocol::NodeInfo_MachineInfo_MemoryDescInfo* mutable_memorydescinfolist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_MachineInfo_MemoryDescInfo >*
      mutable_memorydescinfolist();
  private:
  const ::protocol::NodeInfo_MachineInfo_MemoryDescInfo& _internal_memorydescinfolist(int index) const;
  ::protocol::NodeInfo_MachineInfo_MemoryDescInfo* _internal_add_memorydescinfolist();
  public:
  const ::protocol::NodeInfo_MachineInfo_MemoryDescInfo& memorydescinfolist(int index) const;
  ::protocol::NodeInfo_MachineInfo_MemoryDescInfo* add_memorydescinfolist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_MachineInfo_MemoryDescInfo >&
      memorydescinfolist() const;

  // repeated .protocol.NodeInfo.MachineInfo.DeadLockThreadInfo deadLockThreadInfoList = 13;
  int deadlockthreadinfolist_size() const;
  private:
  int _internal_deadlockthreadinfolist_size() const;
  public:
  void clear_deadlockthreadinfolist();
  ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo* mutable_deadlockthreadinfolist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo >*
      mutable_deadlockthreadinfolist();
  private:
  const ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo& _internal_deadlockthreadinfolist(int index) const;
  ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo* _internal_add_deadlockthreadinfolist();
  public:
  const ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo& deadlockthreadinfolist(int index) const;
  ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo* add_deadlockthreadinfolist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo >&
      deadlockthreadinfolist() const;

  // string javaVersion = 7;
  void clear_javaversion();
  const std::string& javaversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_javaversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_javaversion();
  PROTOBUF_NODISCARD std::string* release_javaversion();
  void set_allocated_javaversion(std::string* javaversion);
  private:
  const std::string& _internal_javaversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_javaversion(const std::string& value);
  std::string* _internal_mutable_javaversion();
  public:

  // string osName = 8;
  void clear_osname();
  const std::string& osname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_osname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_osname();
  PROTOBUF_NODISCARD std::string* release_osname();
  void set_allocated_osname(std::string* osname);
  private:
  const std::string& _internal_osname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_osname(const std::string& value);
  std::string* _internal_mutable_osname();
  public:

  // int32 threadCount = 1;
  void clear_threadcount();
  int32_t threadcount() const;
  void set_threadcount(int32_t value);
  private:
  int32_t _internal_threadcount() const;
  void _internal_set_threadcount(int32_t value);
  public:

  // int32 deadLockThreadCount = 2;
  void clear_deadlockthreadcount();
  int32_t deadlockthreadcount() const;
  void set_deadlockthreadcount(int32_t value);
  private:
  int32_t _internal_deadlockthreadcount() const;
  void _internal_set_deadlockthreadcount(int32_t value);
  public:

  // int64 totalMemory = 4;
  void clear_totalmemory();
  int64_t totalmemory() const;
  void set_totalmemory(int64_t value);
  private:
  int64_t _internal_totalmemory() const;
  void _internal_set_totalmemory(int64_t value);
  public:

  // int64 freeMemory = 5;
  void clear_freememory();
  int64_t freememory() const;
  void set_freememory(int64_t value);
  private:
  int64_t _internal_freememory() const;
  void _internal_set_freememory(int64_t value);
  public:

  // double cpuRate = 6;
  void clear_cpurate();
  double cpurate() const;
  void set_cpurate(double value);
  private:
  double _internal_cpurate() const;
  void _internal_set_cpurate(double value);
  public:

  // int64 jvmTotalMemory = 9;
  void clear_jvmtotalmemory();
  int64_t jvmtotalmemory() const;
  void set_jvmtotalmemory(int64_t value);
  private:
  int64_t _internal_jvmtotalmemory() const;
  void _internal_set_jvmtotalmemory(int64_t value);
  public:

  // int64 jvmFreeMemory = 10;
  void clear_jvmfreememory();
  int64_t jvmfreememory() const;
  void set_jvmfreememory(int64_t value);
  private:
  int64_t _internal_jvmfreememory() const;
  void _internal_set_jvmfreememory(int64_t value);
  public:

  // double processCpuRate = 11;
  void clear_processcpurate();
  double processcpurate() const;
  void set_processcpurate(double value);
  private:
  double _internal_processcpurate() const;
  void _internal_set_processcpurate(double value);
  public:

  // int32 cpuCount = 3;
  void clear_cpucount();
  int32_t cpucount() const;
  void set_cpucount(int32_t value);
  private:
  int32_t _internal_cpucount() const;
  void _internal_set_cpucount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.NodeInfo.MachineInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_MachineInfo_MemoryDescInfo > memorydescinfolist_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo > deadlockthreadinfolist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr javaversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr osname_;
  int32_t threadcount_;
  int32_t deadlockthreadcount_;
  int64_t totalmemory_;
  int64_t freememory_;
  double cpurate_;
  int64_t jvmtotalmemory_;
  int64_t jvmfreememory_;
  double processcpurate_;
  int32_t cpucount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.NodeInfo) */ {
 public:
  inline NodeInfo() : NodeInfo(nullptr) {}
  ~NodeInfo() override;
  explicit constexpr NodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfo(const NodeInfo& from);
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.NodeInfo";
  }
  protected:
  explicit NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NodeInfo_PeerInfo PeerInfo;
  typedef NodeInfo_ConfigNodeInfo ConfigNodeInfo;
  typedef NodeInfo_MachineInfo MachineInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kPeerInfoListFieldNumber = 8,
    kCheatWitnessInfoMapFieldNumber = 11,
    kBlockFieldNumber = 2,
    kSolidityBlockFieldNumber = 3,
    kConfigNodeInfoFieldNumber = 9,
    kMachineInfoFieldNumber = 10,
    kBeginSyncNumFieldNumber = 1,
    kCurrentConnectCountFieldNumber = 4,
    kActiveConnectCountFieldNumber = 5,
    kTotalFlowFieldNumber = 7,
    kPassiveConnectCountFieldNumber = 6,
  };
  // repeated .protocol.NodeInfo.PeerInfo peerInfoList = 8;
  int peerinfolist_size() const;
  private:
  int _internal_peerinfolist_size() const;
  public:
  void clear_peerinfolist();
  ::protocol::NodeInfo_PeerInfo* mutable_peerinfolist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_PeerInfo >*
      mutable_peerinfolist();
  private:
  const ::protocol::NodeInfo_PeerInfo& _internal_peerinfolist(int index) const;
  ::protocol::NodeInfo_PeerInfo* _internal_add_peerinfolist();
  public:
  const ::protocol::NodeInfo_PeerInfo& peerinfolist(int index) const;
  ::protocol::NodeInfo_PeerInfo* add_peerinfolist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_PeerInfo >&
      peerinfolist() const;

  // map<string, string> cheatWitnessInfoMap = 11;
  int cheatwitnessinfomap_size() const;
  private:
  int _internal_cheatwitnessinfomap_size() const;
  public:
  void clear_cheatwitnessinfomap();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_cheatwitnessinfomap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_cheatwitnessinfomap();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      cheatwitnessinfomap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_cheatwitnessinfomap();

  // string block = 2;
  void clear_block();
  const std::string& block() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block();
  PROTOBUF_NODISCARD std::string* release_block();
  void set_allocated_block(std::string* block);
  private:
  const std::string& _internal_block() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block(const std::string& value);
  std::string* _internal_mutable_block();
  public:

  // string solidityBlock = 3;
  void clear_solidityblock();
  const std::string& solidityblock() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_solidityblock(ArgT0&& arg0, ArgT... args);
  std::string* mutable_solidityblock();
  PROTOBUF_NODISCARD std::string* release_solidityblock();
  void set_allocated_solidityblock(std::string* solidityblock);
  private:
  const std::string& _internal_solidityblock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_solidityblock(const std::string& value);
  std::string* _internal_mutable_solidityblock();
  public:

  // .protocol.NodeInfo.ConfigNodeInfo configNodeInfo = 9;
  bool has_confignodeinfo() const;
  private:
  bool _internal_has_confignodeinfo() const;
  public:
  void clear_confignodeinfo();
  const ::protocol::NodeInfo_ConfigNodeInfo& confignodeinfo() const;
  PROTOBUF_NODISCARD ::protocol::NodeInfo_ConfigNodeInfo* release_confignodeinfo();
  ::protocol::NodeInfo_ConfigNodeInfo* mutable_confignodeinfo();
  void set_allocated_confignodeinfo(::protocol::NodeInfo_ConfigNodeInfo* confignodeinfo);
  private:
  const ::protocol::NodeInfo_ConfigNodeInfo& _internal_confignodeinfo() const;
  ::protocol::NodeInfo_ConfigNodeInfo* _internal_mutable_confignodeinfo();
  public:
  void unsafe_arena_set_allocated_confignodeinfo(
      ::protocol::NodeInfo_ConfigNodeInfo* confignodeinfo);
  ::protocol::NodeInfo_ConfigNodeInfo* unsafe_arena_release_confignodeinfo();

  // .protocol.NodeInfo.MachineInfo machineInfo = 10;
  bool has_machineinfo() const;
  private:
  bool _internal_has_machineinfo() const;
  public:
  void clear_machineinfo();
  const ::protocol::NodeInfo_MachineInfo& machineinfo() const;
  PROTOBUF_NODISCARD ::protocol::NodeInfo_MachineInfo* release_machineinfo();
  ::protocol::NodeInfo_MachineInfo* mutable_machineinfo();
  void set_allocated_machineinfo(::protocol::NodeInfo_MachineInfo* machineinfo);
  private:
  const ::protocol::NodeInfo_MachineInfo& _internal_machineinfo() const;
  ::protocol::NodeInfo_MachineInfo* _internal_mutable_machineinfo();
  public:
  void unsafe_arena_set_allocated_machineinfo(
      ::protocol::NodeInfo_MachineInfo* machineinfo);
  ::protocol::NodeInfo_MachineInfo* unsafe_arena_release_machineinfo();

  // int64 beginSyncNum = 1;
  void clear_beginsyncnum();
  int64_t beginsyncnum() const;
  void set_beginsyncnum(int64_t value);
  private:
  int64_t _internal_beginsyncnum() const;
  void _internal_set_beginsyncnum(int64_t value);
  public:

  // int32 currentConnectCount = 4;
  void clear_currentconnectcount();
  int32_t currentconnectcount() const;
  void set_currentconnectcount(int32_t value);
  private:
  int32_t _internal_currentconnectcount() const;
  void _internal_set_currentconnectcount(int32_t value);
  public:

  // int32 activeConnectCount = 5;
  void clear_activeconnectcount();
  int32_t activeconnectcount() const;
  void set_activeconnectcount(int32_t value);
  private:
  int32_t _internal_activeconnectcount() const;
  void _internal_set_activeconnectcount(int32_t value);
  public:

  // int64 totalFlow = 7;
  void clear_totalflow();
  int64_t totalflow() const;
  void set_totalflow(int64_t value);
  private:
  int64_t _internal_totalflow() const;
  void _internal_set_totalflow(int64_t value);
  public:

  // int32 passiveConnectCount = 6;
  void clear_passiveconnectcount();
  int32_t passiveconnectcount() const;
  void set_passiveconnectcount(int32_t value);
  private:
  int32_t _internal_passiveconnectcount() const;
  void _internal_set_passiveconnectcount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.NodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_PeerInfo > peerinfolist_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      NodeInfo_CheatWitnessInfoMapEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> cheatwitnessinfomap_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr solidityblock_;
  ::protocol::NodeInfo_ConfigNodeInfo* confignodeinfo_;
  ::protocol::NodeInfo_MachineInfo* machineinfo_;
  int64_t beginsyncnum_;
  int32_t currentconnectcount_;
  int32_t activeconnectcount_;
  int64_t totalflow_;
  int32_t passiveconnectcount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MetricsInfo_NodeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MetricsInfo.NodeInfo) */ {
 public:
  inline MetricsInfo_NodeInfo() : MetricsInfo_NodeInfo(nullptr) {}
  ~MetricsInfo_NodeInfo() override;
  explicit constexpr MetricsInfo_NodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsInfo_NodeInfo(const MetricsInfo_NodeInfo& from);
  MetricsInfo_NodeInfo(MetricsInfo_NodeInfo&& from) noexcept
    : MetricsInfo_NodeInfo() {
    *this = ::std::move(from);
  }

  inline MetricsInfo_NodeInfo& operator=(const MetricsInfo_NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsInfo_NodeInfo& operator=(MetricsInfo_NodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsInfo_NodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsInfo_NodeInfo* internal_default_instance() {
    return reinterpret_cast<const MetricsInfo_NodeInfo*>(
               &_MetricsInfo_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(MetricsInfo_NodeInfo& a, MetricsInfo_NodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsInfo_NodeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsInfo_NodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsInfo_NodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsInfo_NodeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsInfo_NodeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsInfo_NodeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsInfo_NodeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MetricsInfo.NodeInfo";
  }
  protected:
  explicit MetricsInfo_NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kVersionFieldNumber = 3,
    kNodeTypeFieldNumber = 2,
    kBackupStatusFieldNumber = 4,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string version = 3;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // int32 nodeType = 2;
  void clear_nodetype();
  int32_t nodetype() const;
  void set_nodetype(int32_t value);
  private:
  int32_t _internal_nodetype() const;
  void _internal_set_nodetype(int32_t value);
  public:

  // int32 backupStatus = 4;
  void clear_backupstatus();
  int32_t backupstatus() const;
  void set_backupstatus(int32_t value);
  private:
  int32_t _internal_backupstatus() const;
  void _internal_set_backupstatus(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MetricsInfo.NodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  int32_t nodetype_;
  int32_t backupstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MetricsInfo_BlockChainInfo_Witness final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MetricsInfo.BlockChainInfo.Witness) */ {
 public:
  inline MetricsInfo_BlockChainInfo_Witness() : MetricsInfo_BlockChainInfo_Witness(nullptr) {}
  ~MetricsInfo_BlockChainInfo_Witness() override;
  explicit constexpr MetricsInfo_BlockChainInfo_Witness(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsInfo_BlockChainInfo_Witness(const MetricsInfo_BlockChainInfo_Witness& from);
  MetricsInfo_BlockChainInfo_Witness(MetricsInfo_BlockChainInfo_Witness&& from) noexcept
    : MetricsInfo_BlockChainInfo_Witness() {
    *this = ::std::move(from);
  }

  inline MetricsInfo_BlockChainInfo_Witness& operator=(const MetricsInfo_BlockChainInfo_Witness& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsInfo_BlockChainInfo_Witness& operator=(MetricsInfo_BlockChainInfo_Witness&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsInfo_BlockChainInfo_Witness& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsInfo_BlockChainInfo_Witness* internal_default_instance() {
    return reinterpret_cast<const MetricsInfo_BlockChainInfo_Witness*>(
               &_MetricsInfo_BlockChainInfo_Witness_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(MetricsInfo_BlockChainInfo_Witness& a, MetricsInfo_BlockChainInfo_Witness& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsInfo_BlockChainInfo_Witness* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsInfo_BlockChainInfo_Witness* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsInfo_BlockChainInfo_Witness* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsInfo_BlockChainInfo_Witness>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsInfo_BlockChainInfo_Witness& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsInfo_BlockChainInfo_Witness& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsInfo_BlockChainInfo_Witness* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MetricsInfo.BlockChainInfo.Witness";
  }
  protected:
  explicit MetricsInfo_BlockChainInfo_Witness(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // int32 version = 2;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MetricsInfo.BlockChainInfo.Witness)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  int32_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MetricsInfo_BlockChainInfo_DupWitness final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MetricsInfo.BlockChainInfo.DupWitness) */ {
 public:
  inline MetricsInfo_BlockChainInfo_DupWitness() : MetricsInfo_BlockChainInfo_DupWitness(nullptr) {}
  ~MetricsInfo_BlockChainInfo_DupWitness() override;
  explicit constexpr MetricsInfo_BlockChainInfo_DupWitness(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsInfo_BlockChainInfo_DupWitness(const MetricsInfo_BlockChainInfo_DupWitness& from);
  MetricsInfo_BlockChainInfo_DupWitness(MetricsInfo_BlockChainInfo_DupWitness&& from) noexcept
    : MetricsInfo_BlockChainInfo_DupWitness() {
    *this = ::std::move(from);
  }

  inline MetricsInfo_BlockChainInfo_DupWitness& operator=(const MetricsInfo_BlockChainInfo_DupWitness& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsInfo_BlockChainInfo_DupWitness& operator=(MetricsInfo_BlockChainInfo_DupWitness&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsInfo_BlockChainInfo_DupWitness& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsInfo_BlockChainInfo_DupWitness* internal_default_instance() {
    return reinterpret_cast<const MetricsInfo_BlockChainInfo_DupWitness*>(
               &_MetricsInfo_BlockChainInfo_DupWitness_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(MetricsInfo_BlockChainInfo_DupWitness& a, MetricsInfo_BlockChainInfo_DupWitness& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsInfo_BlockChainInfo_DupWitness* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsInfo_BlockChainInfo_DupWitness* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsInfo_BlockChainInfo_DupWitness* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsInfo_BlockChainInfo_DupWitness>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsInfo_BlockChainInfo_DupWitness& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsInfo_BlockChainInfo_DupWitness& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsInfo_BlockChainInfo_DupWitness* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MetricsInfo.BlockChainInfo.DupWitness";
  }
  protected:
  explicit MetricsInfo_BlockChainInfo_DupWitness(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kBlockNumFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // int64 blockNum = 2;
  void clear_blocknum();
  int64_t blocknum() const;
  void set_blocknum(int64_t value);
  private:
  int64_t _internal_blocknum() const;
  void _internal_set_blocknum(int64_t value);
  public:

  // int32 count = 3;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MetricsInfo.BlockChainInfo.DupWitness)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  int64_t blocknum_;
  int32_t count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MetricsInfo_BlockChainInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MetricsInfo.BlockChainInfo) */ {
 public:
  inline MetricsInfo_BlockChainInfo() : MetricsInfo_BlockChainInfo(nullptr) {}
  ~MetricsInfo_BlockChainInfo() override;
  explicit constexpr MetricsInfo_BlockChainInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsInfo_BlockChainInfo(const MetricsInfo_BlockChainInfo& from);
  MetricsInfo_BlockChainInfo(MetricsInfo_BlockChainInfo&& from) noexcept
    : MetricsInfo_BlockChainInfo() {
    *this = ::std::move(from);
  }

  inline MetricsInfo_BlockChainInfo& operator=(const MetricsInfo_BlockChainInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsInfo_BlockChainInfo& operator=(MetricsInfo_BlockChainInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsInfo_BlockChainInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsInfo_BlockChainInfo* internal_default_instance() {
    return reinterpret_cast<const MetricsInfo_BlockChainInfo*>(
               &_MetricsInfo_BlockChainInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(MetricsInfo_BlockChainInfo& a, MetricsInfo_BlockChainInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsInfo_BlockChainInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsInfo_BlockChainInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsInfo_BlockChainInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsInfo_BlockChainInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsInfo_BlockChainInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsInfo_BlockChainInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsInfo_BlockChainInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MetricsInfo.BlockChainInfo";
  }
  protected:
  explicit MetricsInfo_BlockChainInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MetricsInfo_BlockChainInfo_Witness Witness;
  typedef MetricsInfo_BlockChainInfo_DupWitness DupWitness;

  // accessors -------------------------------------------------------

  enum : int {
    kWitnessesFieldNumber = 10,
    kDupWitnessFieldNumber = 13,
    kHeadBlockHashFieldNumber = 3,
    kFailProcessBlockReasonFieldNumber = 12,
    kBlockProcessTimeFieldNumber = 6,
    kTpsFieldNumber = 7,
    kMissedTransactionFieldNumber = 9,
    kHeadBlockNumFieldNumber = 1,
    kHeadBlockTimestampFieldNumber = 2,
    kForkCountFieldNumber = 4,
    kFailForkCountFieldNumber = 5,
    kFailProcessBlockNumFieldNumber = 11,
    kTransactionCacheSizeFieldNumber = 8,
  };
  // repeated .protocol.MetricsInfo.BlockChainInfo.Witness witnesses = 10;
  int witnesses_size() const;
  private:
  int _internal_witnesses_size() const;
  public:
  void clear_witnesses();
  ::protocol::MetricsInfo_BlockChainInfo_Witness* mutable_witnesses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_BlockChainInfo_Witness >*
      mutable_witnesses();
  private:
  const ::protocol::MetricsInfo_BlockChainInfo_Witness& _internal_witnesses(int index) const;
  ::protocol::MetricsInfo_BlockChainInfo_Witness* _internal_add_witnesses();
  public:
  const ::protocol::MetricsInfo_BlockChainInfo_Witness& witnesses(int index) const;
  ::protocol::MetricsInfo_BlockChainInfo_Witness* add_witnesses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_BlockChainInfo_Witness >&
      witnesses() const;

  // repeated .protocol.MetricsInfo.BlockChainInfo.DupWitness dupWitness = 13;
  int dupwitness_size() const;
  private:
  int _internal_dupwitness_size() const;
  public:
  void clear_dupwitness();
  ::protocol::MetricsInfo_BlockChainInfo_DupWitness* mutable_dupwitness(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_BlockChainInfo_DupWitness >*
      mutable_dupwitness();
  private:
  const ::protocol::MetricsInfo_BlockChainInfo_DupWitness& _internal_dupwitness(int index) const;
  ::protocol::MetricsInfo_BlockChainInfo_DupWitness* _internal_add_dupwitness();
  public:
  const ::protocol::MetricsInfo_BlockChainInfo_DupWitness& dupwitness(int index) const;
  ::protocol::MetricsInfo_BlockChainInfo_DupWitness* add_dupwitness();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_BlockChainInfo_DupWitness >&
      dupwitness() const;

  // string headBlockHash = 3;
  void clear_headblockhash();
  const std::string& headblockhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_headblockhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_headblockhash();
  PROTOBUF_NODISCARD std::string* release_headblockhash();
  void set_allocated_headblockhash(std::string* headblockhash);
  private:
  const std::string& _internal_headblockhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_headblockhash(const std::string& value);
  std::string* _internal_mutable_headblockhash();
  public:

  // string failProcessBlockReason = 12;
  void clear_failprocessblockreason();
  const std::string& failprocessblockreason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failprocessblockreason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failprocessblockreason();
  PROTOBUF_NODISCARD std::string* release_failprocessblockreason();
  void set_allocated_failprocessblockreason(std::string* failprocessblockreason);
  private:
  const std::string& _internal_failprocessblockreason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failprocessblockreason(const std::string& value);
  std::string* _internal_mutable_failprocessblockreason();
  public:

  // .protocol.MetricsInfo.RateInfo blockProcessTime = 6;
  bool has_blockprocesstime() const;
  private:
  bool _internal_has_blockprocesstime() const;
  public:
  void clear_blockprocesstime();
  const ::protocol::MetricsInfo_RateInfo& blockprocesstime() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_RateInfo* release_blockprocesstime();
  ::protocol::MetricsInfo_RateInfo* mutable_blockprocesstime();
  void set_allocated_blockprocesstime(::protocol::MetricsInfo_RateInfo* blockprocesstime);
  private:
  const ::protocol::MetricsInfo_RateInfo& _internal_blockprocesstime() const;
  ::protocol::MetricsInfo_RateInfo* _internal_mutable_blockprocesstime();
  public:
  void unsafe_arena_set_allocated_blockprocesstime(
      ::protocol::MetricsInfo_RateInfo* blockprocesstime);
  ::protocol::MetricsInfo_RateInfo* unsafe_arena_release_blockprocesstime();

  // .protocol.MetricsInfo.RateInfo tps = 7;
  bool has_tps() const;
  private:
  bool _internal_has_tps() const;
  public:
  void clear_tps();
  const ::protocol::MetricsInfo_RateInfo& tps() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_RateInfo* release_tps();
  ::protocol::MetricsInfo_RateInfo* mutable_tps();
  void set_allocated_tps(::protocol::MetricsInfo_RateInfo* tps);
  private:
  const ::protocol::MetricsInfo_RateInfo& _internal_tps() const;
  ::protocol::MetricsInfo_RateInfo* _internal_mutable_tps();
  public:
  void unsafe_arena_set_allocated_tps(
      ::protocol::MetricsInfo_RateInfo* tps);
  ::protocol::MetricsInfo_RateInfo* unsafe_arena_release_tps();

  // .protocol.MetricsInfo.RateInfo missedTransaction = 9;
  bool has_missedtransaction() const;
  private:
  bool _internal_has_missedtransaction() const;
  public:
  void clear_missedtransaction();
  const ::protocol::MetricsInfo_RateInfo& missedtransaction() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_RateInfo* release_missedtransaction();
  ::protocol::MetricsInfo_RateInfo* mutable_missedtransaction();
  void set_allocated_missedtransaction(::protocol::MetricsInfo_RateInfo* missedtransaction);
  private:
  const ::protocol::MetricsInfo_RateInfo& _internal_missedtransaction() const;
  ::protocol::MetricsInfo_RateInfo* _internal_mutable_missedtransaction();
  public:
  void unsafe_arena_set_allocated_missedtransaction(
      ::protocol::MetricsInfo_RateInfo* missedtransaction);
  ::protocol::MetricsInfo_RateInfo* unsafe_arena_release_missedtransaction();

  // int64 headBlockNum = 1;
  void clear_headblocknum();
  int64_t headblocknum() const;
  void set_headblocknum(int64_t value);
  private:
  int64_t _internal_headblocknum() const;
  void _internal_set_headblocknum(int64_t value);
  public:

  // int64 headBlockTimestamp = 2;
  void clear_headblocktimestamp();
  int64_t headblocktimestamp() const;
  void set_headblocktimestamp(int64_t value);
  private:
  int64_t _internal_headblocktimestamp() const;
  void _internal_set_headblocktimestamp(int64_t value);
  public:

  // int32 forkCount = 4;
  void clear_forkcount();
  int32_t forkcount() const;
  void set_forkcount(int32_t value);
  private:
  int32_t _internal_forkcount() const;
  void _internal_set_forkcount(int32_t value);
  public:

  // int32 failForkCount = 5;
  void clear_failforkcount();
  int32_t failforkcount() const;
  void set_failforkcount(int32_t value);
  private:
  int32_t _internal_failforkcount() const;
  void _internal_set_failforkcount(int32_t value);
  public:

  // int64 failProcessBlockNum = 11;
  void clear_failprocessblocknum();
  int64_t failprocessblocknum() const;
  void set_failprocessblocknum(int64_t value);
  private:
  int64_t _internal_failprocessblocknum() const;
  void _internal_set_failprocessblocknum(int64_t value);
  public:

  // int32 transactionCacheSize = 8;
  void clear_transactioncachesize();
  int32_t transactioncachesize() const;
  void set_transactioncachesize(int32_t value);
  private:
  int32_t _internal_transactioncachesize() const;
  void _internal_set_transactioncachesize(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MetricsInfo.BlockChainInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_BlockChainInfo_Witness > witnesses_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_BlockChainInfo_DupWitness > dupwitness_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr headblockhash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failprocessblockreason_;
  ::protocol::MetricsInfo_RateInfo* blockprocesstime_;
  ::protocol::MetricsInfo_RateInfo* tps_;
  ::protocol::MetricsInfo_RateInfo* missedtransaction_;
  int64_t headblocknum_;
  int64_t headblocktimestamp_;
  int32_t forkcount_;
  int32_t failforkcount_;
  int64_t failprocessblocknum_;
  int32_t transactioncachesize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MetricsInfo_RateInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MetricsInfo.RateInfo) */ {
 public:
  inline MetricsInfo_RateInfo() : MetricsInfo_RateInfo(nullptr) {}
  ~MetricsInfo_RateInfo() override;
  explicit constexpr MetricsInfo_RateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsInfo_RateInfo(const MetricsInfo_RateInfo& from);
  MetricsInfo_RateInfo(MetricsInfo_RateInfo&& from) noexcept
    : MetricsInfo_RateInfo() {
    *this = ::std::move(from);
  }

  inline MetricsInfo_RateInfo& operator=(const MetricsInfo_RateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsInfo_RateInfo& operator=(MetricsInfo_RateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsInfo_RateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsInfo_RateInfo* internal_default_instance() {
    return reinterpret_cast<const MetricsInfo_RateInfo*>(
               &_MetricsInfo_RateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(MetricsInfo_RateInfo& a, MetricsInfo_RateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsInfo_RateInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsInfo_RateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsInfo_RateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsInfo_RateInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsInfo_RateInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsInfo_RateInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsInfo_RateInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MetricsInfo.RateInfo";
  }
  protected:
  explicit MetricsInfo_RateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
    kMeanRateFieldNumber = 2,
    kOneMinuteRateFieldNumber = 3,
    kFiveMinuteRateFieldNumber = 4,
    kFifteenMinuteRateFieldNumber = 5,
  };
  // int64 count = 1;
  void clear_count();
  int64_t count() const;
  void set_count(int64_t value);
  private:
  int64_t _internal_count() const;
  void _internal_set_count(int64_t value);
  public:

  // double meanRate = 2;
  void clear_meanrate();
  double meanrate() const;
  void set_meanrate(double value);
  private:
  double _internal_meanrate() const;
  void _internal_set_meanrate(double value);
  public:

  // double oneMinuteRate = 3;
  void clear_oneminuterate();
  double oneminuterate() const;
  void set_oneminuterate(double value);
  private:
  double _internal_oneminuterate() const;
  void _internal_set_oneminuterate(double value);
  public:

  // double fiveMinuteRate = 4;
  void clear_fiveminuterate();
  double fiveminuterate() const;
  void set_fiveminuterate(double value);
  private:
  double _internal_fiveminuterate() const;
  void _internal_set_fiveminuterate(double value);
  public:

  // double fifteenMinuteRate = 5;
  void clear_fifteenminuterate();
  double fifteenminuterate() const;
  void set_fifteenminuterate(double value);
  private:
  double _internal_fifteenminuterate() const;
  void _internal_set_fifteenminuterate(double value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MetricsInfo.RateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t count_;
  double meanrate_;
  double oneminuterate_;
  double fiveminuterate_;
  double fifteenminuterate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo) */ {
 public:
  inline MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo() : MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo(nullptr) {}
  ~MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo() override;
  explicit constexpr MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo(const MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo& from);
  MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo&& from) noexcept
    : MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo() {
    *this = ::std::move(from);
  }

  inline MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo& operator=(const MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo& operator=(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo* internal_default_instance() {
    return reinterpret_cast<const MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo*>(
               &_MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo& a, MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo";
  }
  protected:
  explicit MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kQpsFieldNumber = 2,
    kFailQpsFieldNumber = 3,
    kOutTrafficFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .protocol.MetricsInfo.RateInfo qps = 2;
  bool has_qps() const;
  private:
  bool _internal_has_qps() const;
  public:
  void clear_qps();
  const ::protocol::MetricsInfo_RateInfo& qps() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_RateInfo* release_qps();
  ::protocol::MetricsInfo_RateInfo* mutable_qps();
  void set_allocated_qps(::protocol::MetricsInfo_RateInfo* qps);
  private:
  const ::protocol::MetricsInfo_RateInfo& _internal_qps() const;
  ::protocol::MetricsInfo_RateInfo* _internal_mutable_qps();
  public:
  void unsafe_arena_set_allocated_qps(
      ::protocol::MetricsInfo_RateInfo* qps);
  ::protocol::MetricsInfo_RateInfo* unsafe_arena_release_qps();

  // .protocol.MetricsInfo.RateInfo failQps = 3;
  bool has_failqps() const;
  private:
  bool _internal_has_failqps() const;
  public:
  void clear_failqps();
  const ::protocol::MetricsInfo_RateInfo& failqps() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_RateInfo* release_failqps();
  ::protocol::MetricsInfo_RateInfo* mutable_failqps();
  void set_allocated_failqps(::protocol::MetricsInfo_RateInfo* failqps);
  private:
  const ::protocol::MetricsInfo_RateInfo& _internal_failqps() const;
  ::protocol::MetricsInfo_RateInfo* _internal_mutable_failqps();
  public:
  void unsafe_arena_set_allocated_failqps(
      ::protocol::MetricsInfo_RateInfo* failqps);
  ::protocol::MetricsInfo_RateInfo* unsafe_arena_release_failqps();

  // .protocol.MetricsInfo.RateInfo outTraffic = 4;
  bool has_outtraffic() const;
  private:
  bool _internal_has_outtraffic() const;
  public:
  void clear_outtraffic();
  const ::protocol::MetricsInfo_RateInfo& outtraffic() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_RateInfo* release_outtraffic();
  ::protocol::MetricsInfo_RateInfo* mutable_outtraffic();
  void set_allocated_outtraffic(::protocol::MetricsInfo_RateInfo* outtraffic);
  private:
  const ::protocol::MetricsInfo_RateInfo& _internal_outtraffic() const;
  ::protocol::MetricsInfo_RateInfo* _internal_mutable_outtraffic();
  public:
  void unsafe_arena_set_allocated_outtraffic(
      ::protocol::MetricsInfo_RateInfo* outtraffic);
  ::protocol::MetricsInfo_RateInfo* unsafe_arena_release_outtraffic();

  // @@protoc_insertion_point(class_scope:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::protocol::MetricsInfo_RateInfo* qps_;
  ::protocol::MetricsInfo_RateInfo* failqps_;
  ::protocol::MetricsInfo_RateInfo* outtraffic_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MetricsInfo_NetInfo_ApiInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MetricsInfo.NetInfo.ApiInfo) */ {
 public:
  inline MetricsInfo_NetInfo_ApiInfo() : MetricsInfo_NetInfo_ApiInfo(nullptr) {}
  ~MetricsInfo_NetInfo_ApiInfo() override;
  explicit constexpr MetricsInfo_NetInfo_ApiInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsInfo_NetInfo_ApiInfo(const MetricsInfo_NetInfo_ApiInfo& from);
  MetricsInfo_NetInfo_ApiInfo(MetricsInfo_NetInfo_ApiInfo&& from) noexcept
    : MetricsInfo_NetInfo_ApiInfo() {
    *this = ::std::move(from);
  }

  inline MetricsInfo_NetInfo_ApiInfo& operator=(const MetricsInfo_NetInfo_ApiInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsInfo_NetInfo_ApiInfo& operator=(MetricsInfo_NetInfo_ApiInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsInfo_NetInfo_ApiInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsInfo_NetInfo_ApiInfo* internal_default_instance() {
    return reinterpret_cast<const MetricsInfo_NetInfo_ApiInfo*>(
               &_MetricsInfo_NetInfo_ApiInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(MetricsInfo_NetInfo_ApiInfo& a, MetricsInfo_NetInfo_ApiInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsInfo_NetInfo_ApiInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsInfo_NetInfo_ApiInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsInfo_NetInfo_ApiInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsInfo_NetInfo_ApiInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsInfo_NetInfo_ApiInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsInfo_NetInfo_ApiInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsInfo_NetInfo_ApiInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MetricsInfo.NetInfo.ApiInfo";
  }
  protected:
  explicit MetricsInfo_NetInfo_ApiInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo ApiDetailInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kDetailFieldNumber = 4,
    kQpsFieldNumber = 1,
    kFailQpsFieldNumber = 2,
    kOutTrafficFieldNumber = 3,
  };
  // repeated .protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo detail = 4;
  int detail_size() const;
  private:
  int _internal_detail_size() const;
  public:
  void clear_detail();
  ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo* mutable_detail(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo >*
      mutable_detail();
  private:
  const ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo& _internal_detail(int index) const;
  ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo* _internal_add_detail();
  public:
  const ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo& detail(int index) const;
  ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo* add_detail();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo >&
      detail() const;

  // .protocol.MetricsInfo.RateInfo qps = 1;
  bool has_qps() const;
  private:
  bool _internal_has_qps() const;
  public:
  void clear_qps();
  const ::protocol::MetricsInfo_RateInfo& qps() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_RateInfo* release_qps();
  ::protocol::MetricsInfo_RateInfo* mutable_qps();
  void set_allocated_qps(::protocol::MetricsInfo_RateInfo* qps);
  private:
  const ::protocol::MetricsInfo_RateInfo& _internal_qps() const;
  ::protocol::MetricsInfo_RateInfo* _internal_mutable_qps();
  public:
  void unsafe_arena_set_allocated_qps(
      ::protocol::MetricsInfo_RateInfo* qps);
  ::protocol::MetricsInfo_RateInfo* unsafe_arena_release_qps();

  // .protocol.MetricsInfo.RateInfo failQps = 2;
  bool has_failqps() const;
  private:
  bool _internal_has_failqps() const;
  public:
  void clear_failqps();
  const ::protocol::MetricsInfo_RateInfo& failqps() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_RateInfo* release_failqps();
  ::protocol::MetricsInfo_RateInfo* mutable_failqps();
  void set_allocated_failqps(::protocol::MetricsInfo_RateInfo* failqps);
  private:
  const ::protocol::MetricsInfo_RateInfo& _internal_failqps() const;
  ::protocol::MetricsInfo_RateInfo* _internal_mutable_failqps();
  public:
  void unsafe_arena_set_allocated_failqps(
      ::protocol::MetricsInfo_RateInfo* failqps);
  ::protocol::MetricsInfo_RateInfo* unsafe_arena_release_failqps();

  // .protocol.MetricsInfo.RateInfo outTraffic = 3;
  bool has_outtraffic() const;
  private:
  bool _internal_has_outtraffic() const;
  public:
  void clear_outtraffic();
  const ::protocol::MetricsInfo_RateInfo& outtraffic() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_RateInfo* release_outtraffic();
  ::protocol::MetricsInfo_RateInfo* mutable_outtraffic();
  void set_allocated_outtraffic(::protocol::MetricsInfo_RateInfo* outtraffic);
  private:
  const ::protocol::MetricsInfo_RateInfo& _internal_outtraffic() const;
  ::protocol::MetricsInfo_RateInfo* _internal_mutable_outtraffic();
  public:
  void unsafe_arena_set_allocated_outtraffic(
      ::protocol::MetricsInfo_RateInfo* outtraffic);
  ::protocol::MetricsInfo_RateInfo* unsafe_arena_release_outtraffic();

  // @@protoc_insertion_point(class_scope:protocol.MetricsInfo.NetInfo.ApiInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo > detail_;
  ::protocol::MetricsInfo_RateInfo* qps_;
  ::protocol::MetricsInfo_RateInfo* failqps_;
  ::protocol::MetricsInfo_RateInfo* outtraffic_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MetricsInfo_NetInfo_DisconnectionDetailInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo) */ {
 public:
  inline MetricsInfo_NetInfo_DisconnectionDetailInfo() : MetricsInfo_NetInfo_DisconnectionDetailInfo(nullptr) {}
  ~MetricsInfo_NetInfo_DisconnectionDetailInfo() override;
  explicit constexpr MetricsInfo_NetInfo_DisconnectionDetailInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsInfo_NetInfo_DisconnectionDetailInfo(const MetricsInfo_NetInfo_DisconnectionDetailInfo& from);
  MetricsInfo_NetInfo_DisconnectionDetailInfo(MetricsInfo_NetInfo_DisconnectionDetailInfo&& from) noexcept
    : MetricsInfo_NetInfo_DisconnectionDetailInfo() {
    *this = ::std::move(from);
  }

  inline MetricsInfo_NetInfo_DisconnectionDetailInfo& operator=(const MetricsInfo_NetInfo_DisconnectionDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsInfo_NetInfo_DisconnectionDetailInfo& operator=(MetricsInfo_NetInfo_DisconnectionDetailInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsInfo_NetInfo_DisconnectionDetailInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsInfo_NetInfo_DisconnectionDetailInfo* internal_default_instance() {
    return reinterpret_cast<const MetricsInfo_NetInfo_DisconnectionDetailInfo*>(
               &_MetricsInfo_NetInfo_DisconnectionDetailInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(MetricsInfo_NetInfo_DisconnectionDetailInfo& a, MetricsInfo_NetInfo_DisconnectionDetailInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsInfo_NetInfo_DisconnectionDetailInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsInfo_NetInfo_DisconnectionDetailInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsInfo_NetInfo_DisconnectionDetailInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsInfo_NetInfo_DisconnectionDetailInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsInfo_NetInfo_DisconnectionDetailInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsInfo_NetInfo_DisconnectionDetailInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsInfo_NetInfo_DisconnectionDetailInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo";
  }
  protected:
  explicit MetricsInfo_NetInfo_DisconnectionDetailInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // string reason = 1;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // int32 count = 2;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  int32_t count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo) */ {
 public:
  inline MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo() : MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo(nullptr) {}
  ~MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo() override;
  explicit constexpr MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo(const MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo& from);
  MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo&& from) noexcept
    : MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo() {
    *this = ::std::move(from);
  }

  inline MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo& operator=(const MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo& operator=(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo* internal_default_instance() {
    return reinterpret_cast<const MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo*>(
               &_MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo& a, MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo";
  }
  protected:
  explicit MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWitnessFieldNumber = 1,
    kTop99FieldNumber = 2,
    kTop95FieldNumber = 3,
    kTop75FieldNumber = 4,
    kCountFieldNumber = 5,
    kDelay1SFieldNumber = 6,
    kDelay2SFieldNumber = 7,
    kDelay3SFieldNumber = 8,
  };
  // string witness = 1;
  void clear_witness();
  const std::string& witness() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_witness(ArgT0&& arg0, ArgT... args);
  std::string* mutable_witness();
  PROTOBUF_NODISCARD std::string* release_witness();
  void set_allocated_witness(std::string* witness);
  private:
  const std::string& _internal_witness() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_witness(const std::string& value);
  std::string* _internal_mutable_witness();
  public:

  // int32 top99 = 2;
  void clear_top99();
  int32_t top99() const;
  void set_top99(int32_t value);
  private:
  int32_t _internal_top99() const;
  void _internal_set_top99(int32_t value);
  public:

  // int32 top95 = 3;
  void clear_top95();
  int32_t top95() const;
  void set_top95(int32_t value);
  private:
  int32_t _internal_top95() const;
  void _internal_set_top95(int32_t value);
  public:

  // int32 top75 = 4;
  void clear_top75();
  int32_t top75() const;
  void set_top75(int32_t value);
  private:
  int32_t _internal_top75() const;
  void _internal_set_top75(int32_t value);
  public:

  // int32 count = 5;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // int32 delay1S = 6;
  void clear_delay1s();
  int32_t delay1s() const;
  void set_delay1s(int32_t value);
  private:
  int32_t _internal_delay1s() const;
  void _internal_set_delay1s(int32_t value);
  public:

  // int32 delay2S = 7;
  void clear_delay2s();
  int32_t delay2s() const;
  void set_delay2s(int32_t value);
  private:
  int32_t _internal_delay2s() const;
  void _internal_set_delay2s(int32_t value);
  public:

  // int32 delay3S = 8;
  void clear_delay3s();
  int32_t delay3s() const;
  void set_delay3s(int32_t value);
  private:
  int32_t _internal_delay3s() const;
  void _internal_set_delay3s(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr witness_;
  int32_t top99_;
  int32_t top95_;
  int32_t top75_;
  int32_t count_;
  int32_t delay1s_;
  int32_t delay2s_;
  int32_t delay3s_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MetricsInfo_NetInfo_LatencyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MetricsInfo.NetInfo.LatencyInfo) */ {
 public:
  inline MetricsInfo_NetInfo_LatencyInfo() : MetricsInfo_NetInfo_LatencyInfo(nullptr) {}
  ~MetricsInfo_NetInfo_LatencyInfo() override;
  explicit constexpr MetricsInfo_NetInfo_LatencyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsInfo_NetInfo_LatencyInfo(const MetricsInfo_NetInfo_LatencyInfo& from);
  MetricsInfo_NetInfo_LatencyInfo(MetricsInfo_NetInfo_LatencyInfo&& from) noexcept
    : MetricsInfo_NetInfo_LatencyInfo() {
    *this = ::std::move(from);
  }

  inline MetricsInfo_NetInfo_LatencyInfo& operator=(const MetricsInfo_NetInfo_LatencyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsInfo_NetInfo_LatencyInfo& operator=(MetricsInfo_NetInfo_LatencyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsInfo_NetInfo_LatencyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsInfo_NetInfo_LatencyInfo* internal_default_instance() {
    return reinterpret_cast<const MetricsInfo_NetInfo_LatencyInfo*>(
               &_MetricsInfo_NetInfo_LatencyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(MetricsInfo_NetInfo_LatencyInfo& a, MetricsInfo_NetInfo_LatencyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsInfo_NetInfo_LatencyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsInfo_NetInfo_LatencyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsInfo_NetInfo_LatencyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsInfo_NetInfo_LatencyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsInfo_NetInfo_LatencyInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsInfo_NetInfo_LatencyInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsInfo_NetInfo_LatencyInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MetricsInfo.NetInfo.LatencyInfo";
  }
  protected:
  explicit MetricsInfo_NetInfo_LatencyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo LatencyDetailInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kDetailFieldNumber = 8,
    kTop99FieldNumber = 1,
    kTop95FieldNumber = 2,
    kTop75FieldNumber = 3,
    kTotalCountFieldNumber = 4,
    kDelay1SFieldNumber = 5,
    kDelay2SFieldNumber = 6,
    kDelay3SFieldNumber = 7,
  };
  // repeated .protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo detail = 8;
  int detail_size() const;
  private:
  int _internal_detail_size() const;
  public:
  void clear_detail();
  ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo* mutable_detail(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo >*
      mutable_detail();
  private:
  const ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo& _internal_detail(int index) const;
  ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo* _internal_add_detail();
  public:
  const ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo& detail(int index) const;
  ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo* add_detail();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo >&
      detail() const;

  // int32 top99 = 1;
  void clear_top99();
  int32_t top99() const;
  void set_top99(int32_t value);
  private:
  int32_t _internal_top99() const;
  void _internal_set_top99(int32_t value);
  public:

  // int32 top95 = 2;
  void clear_top95();
  int32_t top95() const;
  void set_top95(int32_t value);
  private:
  int32_t _internal_top95() const;
  void _internal_set_top95(int32_t value);
  public:

  // int32 top75 = 3;
  void clear_top75();
  int32_t top75() const;
  void set_top75(int32_t value);
  private:
  int32_t _internal_top75() const;
  void _internal_set_top75(int32_t value);
  public:

  // int32 totalCount = 4;
  void clear_totalcount();
  int32_t totalcount() const;
  void set_totalcount(int32_t value);
  private:
  int32_t _internal_totalcount() const;
  void _internal_set_totalcount(int32_t value);
  public:

  // int32 delay1S = 5;
  void clear_delay1s();
  int32_t delay1s() const;
  void set_delay1s(int32_t value);
  private:
  int32_t _internal_delay1s() const;
  void _internal_set_delay1s(int32_t value);
  public:

  // int32 delay2S = 6;
  void clear_delay2s();
  int32_t delay2s() const;
  void set_delay2s(int32_t value);
  private:
  int32_t _internal_delay2s() const;
  void _internal_set_delay2s(int32_t value);
  public:

  // int32 delay3S = 7;
  void clear_delay3s();
  int32_t delay3s() const;
  void set_delay3s(int32_t value);
  private:
  int32_t _internal_delay3s() const;
  void _internal_set_delay3s(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MetricsInfo.NetInfo.LatencyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo > detail_;
  int32_t top99_;
  int32_t top95_;
  int32_t top75_;
  int32_t totalcount_;
  int32_t delay1s_;
  int32_t delay2s_;
  int32_t delay3s_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MetricsInfo_NetInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MetricsInfo.NetInfo) */ {
 public:
  inline MetricsInfo_NetInfo() : MetricsInfo_NetInfo(nullptr) {}
  ~MetricsInfo_NetInfo() override;
  explicit constexpr MetricsInfo_NetInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsInfo_NetInfo(const MetricsInfo_NetInfo& from);
  MetricsInfo_NetInfo(MetricsInfo_NetInfo&& from) noexcept
    : MetricsInfo_NetInfo() {
    *this = ::std::move(from);
  }

  inline MetricsInfo_NetInfo& operator=(const MetricsInfo_NetInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsInfo_NetInfo& operator=(MetricsInfo_NetInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsInfo_NetInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsInfo_NetInfo* internal_default_instance() {
    return reinterpret_cast<const MetricsInfo_NetInfo*>(
               &_MetricsInfo_NetInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(MetricsInfo_NetInfo& a, MetricsInfo_NetInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsInfo_NetInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsInfo_NetInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsInfo_NetInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsInfo_NetInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsInfo_NetInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsInfo_NetInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsInfo_NetInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MetricsInfo.NetInfo";
  }
  protected:
  explicit MetricsInfo_NetInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MetricsInfo_NetInfo_ApiInfo ApiInfo;
  typedef MetricsInfo_NetInfo_DisconnectionDetailInfo DisconnectionDetailInfo;
  typedef MetricsInfo_NetInfo_LatencyInfo LatencyInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kDisconnectionDetailFieldNumber = 8,
    kApiFieldNumber = 2,
    kTcpInTrafficFieldNumber = 5,
    kTcpOutTrafficFieldNumber = 6,
    kUdpInTrafficFieldNumber = 9,
    kUdpOutTrafficFieldNumber = 10,
    kLatencyFieldNumber = 11,
    kErrorProtoCountFieldNumber = 1,
    kConnectionCountFieldNumber = 3,
    kValidConnectionCountFieldNumber = 4,
    kDisconnectionCountFieldNumber = 7,
  };
  // repeated .protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo disconnectionDetail = 8;
  int disconnectiondetail_size() const;
  private:
  int _internal_disconnectiondetail_size() const;
  public:
  void clear_disconnectiondetail();
  ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo* mutable_disconnectiondetail(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo >*
      mutable_disconnectiondetail();
  private:
  const ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo& _internal_disconnectiondetail(int index) const;
  ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo* _internal_add_disconnectiondetail();
  public:
  const ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo& disconnectiondetail(int index) const;
  ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo* add_disconnectiondetail();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo >&
      disconnectiondetail() const;

  // .protocol.MetricsInfo.NetInfo.ApiInfo api = 2;
  bool has_api() const;
  private:
  bool _internal_has_api() const;
  public:
  void clear_api();
  const ::protocol::MetricsInfo_NetInfo_ApiInfo& api() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_NetInfo_ApiInfo* release_api();
  ::protocol::MetricsInfo_NetInfo_ApiInfo* mutable_api();
  void set_allocated_api(::protocol::MetricsInfo_NetInfo_ApiInfo* api);
  private:
  const ::protocol::MetricsInfo_NetInfo_ApiInfo& _internal_api() const;
  ::protocol::MetricsInfo_NetInfo_ApiInfo* _internal_mutable_api();
  public:
  void unsafe_arena_set_allocated_api(
      ::protocol::MetricsInfo_NetInfo_ApiInfo* api);
  ::protocol::MetricsInfo_NetInfo_ApiInfo* unsafe_arena_release_api();

  // .protocol.MetricsInfo.RateInfo tcpInTraffic = 5;
  bool has_tcpintraffic() const;
  private:
  bool _internal_has_tcpintraffic() const;
  public:
  void clear_tcpintraffic();
  const ::protocol::MetricsInfo_RateInfo& tcpintraffic() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_RateInfo* release_tcpintraffic();
  ::protocol::MetricsInfo_RateInfo* mutable_tcpintraffic();
  void set_allocated_tcpintraffic(::protocol::MetricsInfo_RateInfo* tcpintraffic);
  private:
  const ::protocol::MetricsInfo_RateInfo& _internal_tcpintraffic() const;
  ::protocol::MetricsInfo_RateInfo* _internal_mutable_tcpintraffic();
  public:
  void unsafe_arena_set_allocated_tcpintraffic(
      ::protocol::MetricsInfo_RateInfo* tcpintraffic);
  ::protocol::MetricsInfo_RateInfo* unsafe_arena_release_tcpintraffic();

  // .protocol.MetricsInfo.RateInfo tcpOutTraffic = 6;
  bool has_tcpouttraffic() const;
  private:
  bool _internal_has_tcpouttraffic() const;
  public:
  void clear_tcpouttraffic();
  const ::protocol::MetricsInfo_RateInfo& tcpouttraffic() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_RateInfo* release_tcpouttraffic();
  ::protocol::MetricsInfo_RateInfo* mutable_tcpouttraffic();
  void set_allocated_tcpouttraffic(::protocol::MetricsInfo_RateInfo* tcpouttraffic);
  private:
  const ::protocol::MetricsInfo_RateInfo& _internal_tcpouttraffic() const;
  ::protocol::MetricsInfo_RateInfo* _internal_mutable_tcpouttraffic();
  public:
  void unsafe_arena_set_allocated_tcpouttraffic(
      ::protocol::MetricsInfo_RateInfo* tcpouttraffic);
  ::protocol::MetricsInfo_RateInfo* unsafe_arena_release_tcpouttraffic();

  // .protocol.MetricsInfo.RateInfo udpInTraffic = 9;
  bool has_udpintraffic() const;
  private:
  bool _internal_has_udpintraffic() const;
  public:
  void clear_udpintraffic();
  const ::protocol::MetricsInfo_RateInfo& udpintraffic() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_RateInfo* release_udpintraffic();
  ::protocol::MetricsInfo_RateInfo* mutable_udpintraffic();
  void set_allocated_udpintraffic(::protocol::MetricsInfo_RateInfo* udpintraffic);
  private:
  const ::protocol::MetricsInfo_RateInfo& _internal_udpintraffic() const;
  ::protocol::MetricsInfo_RateInfo* _internal_mutable_udpintraffic();
  public:
  void unsafe_arena_set_allocated_udpintraffic(
      ::protocol::MetricsInfo_RateInfo* udpintraffic);
  ::protocol::MetricsInfo_RateInfo* unsafe_arena_release_udpintraffic();

  // .protocol.MetricsInfo.RateInfo udpOutTraffic = 10;
  bool has_udpouttraffic() const;
  private:
  bool _internal_has_udpouttraffic() const;
  public:
  void clear_udpouttraffic();
  const ::protocol::MetricsInfo_RateInfo& udpouttraffic() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_RateInfo* release_udpouttraffic();
  ::protocol::MetricsInfo_RateInfo* mutable_udpouttraffic();
  void set_allocated_udpouttraffic(::protocol::MetricsInfo_RateInfo* udpouttraffic);
  private:
  const ::protocol::MetricsInfo_RateInfo& _internal_udpouttraffic() const;
  ::protocol::MetricsInfo_RateInfo* _internal_mutable_udpouttraffic();
  public:
  void unsafe_arena_set_allocated_udpouttraffic(
      ::protocol::MetricsInfo_RateInfo* udpouttraffic);
  ::protocol::MetricsInfo_RateInfo* unsafe_arena_release_udpouttraffic();

  // .protocol.MetricsInfo.NetInfo.LatencyInfo latency = 11;
  bool has_latency() const;
  private:
  bool _internal_has_latency() const;
  public:
  void clear_latency();
  const ::protocol::MetricsInfo_NetInfo_LatencyInfo& latency() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_NetInfo_LatencyInfo* release_latency();
  ::protocol::MetricsInfo_NetInfo_LatencyInfo* mutable_latency();
  void set_allocated_latency(::protocol::MetricsInfo_NetInfo_LatencyInfo* latency);
  private:
  const ::protocol::MetricsInfo_NetInfo_LatencyInfo& _internal_latency() const;
  ::protocol::MetricsInfo_NetInfo_LatencyInfo* _internal_mutable_latency();
  public:
  void unsafe_arena_set_allocated_latency(
      ::protocol::MetricsInfo_NetInfo_LatencyInfo* latency);
  ::protocol::MetricsInfo_NetInfo_LatencyInfo* unsafe_arena_release_latency();

  // int32 errorProtoCount = 1;
  void clear_errorprotocount();
  int32_t errorprotocount() const;
  void set_errorprotocount(int32_t value);
  private:
  int32_t _internal_errorprotocount() const;
  void _internal_set_errorprotocount(int32_t value);
  public:

  // int32 connectionCount = 3;
  void clear_connectioncount();
  int32_t connectioncount() const;
  void set_connectioncount(int32_t value);
  private:
  int32_t _internal_connectioncount() const;
  void _internal_set_connectioncount(int32_t value);
  public:

  // int32 validConnectionCount = 4;
  void clear_validconnectioncount();
  int32_t validconnectioncount() const;
  void set_validconnectioncount(int32_t value);
  private:
  int32_t _internal_validconnectioncount() const;
  void _internal_set_validconnectioncount(int32_t value);
  public:

  // int32 disconnectionCount = 7;
  void clear_disconnectioncount();
  int32_t disconnectioncount() const;
  void set_disconnectioncount(int32_t value);
  private:
  int32_t _internal_disconnectioncount() const;
  void _internal_set_disconnectioncount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MetricsInfo.NetInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo > disconnectiondetail_;
  ::protocol::MetricsInfo_NetInfo_ApiInfo* api_;
  ::protocol::MetricsInfo_RateInfo* tcpintraffic_;
  ::protocol::MetricsInfo_RateInfo* tcpouttraffic_;
  ::protocol::MetricsInfo_RateInfo* udpintraffic_;
  ::protocol::MetricsInfo_RateInfo* udpouttraffic_;
  ::protocol::MetricsInfo_NetInfo_LatencyInfo* latency_;
  int32_t errorprotocount_;
  int32_t connectioncount_;
  int32_t validconnectioncount_;
  int32_t disconnectioncount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class MetricsInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.MetricsInfo) */ {
 public:
  inline MetricsInfo() : MetricsInfo(nullptr) {}
  ~MetricsInfo() override;
  explicit constexpr MetricsInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricsInfo(const MetricsInfo& from);
  MetricsInfo(MetricsInfo&& from) noexcept
    : MetricsInfo() {
    *this = ::std::move(from);
  }

  inline MetricsInfo& operator=(const MetricsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricsInfo& operator=(MetricsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricsInfo* internal_default_instance() {
    return reinterpret_cast<const MetricsInfo*>(
               &_MetricsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(MetricsInfo& a, MetricsInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricsInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricsInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricsInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricsInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricsInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetricsInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricsInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.MetricsInfo";
  }
  protected:
  explicit MetricsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MetricsInfo_NodeInfo NodeInfo;
  typedef MetricsInfo_BlockChainInfo BlockChainInfo;
  typedef MetricsInfo_RateInfo RateInfo;
  typedef MetricsInfo_NetInfo NetInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 2,
    kBlockchainFieldNumber = 3,
    kNetFieldNumber = 4,
    kIntervalFieldNumber = 1,
  };
  // .protocol.MetricsInfo.NodeInfo node = 2;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::protocol::MetricsInfo_NodeInfo& node() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_NodeInfo* release_node();
  ::protocol::MetricsInfo_NodeInfo* mutable_node();
  void set_allocated_node(::protocol::MetricsInfo_NodeInfo* node);
  private:
  const ::protocol::MetricsInfo_NodeInfo& _internal_node() const;
  ::protocol::MetricsInfo_NodeInfo* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::protocol::MetricsInfo_NodeInfo* node);
  ::protocol::MetricsInfo_NodeInfo* unsafe_arena_release_node();

  // .protocol.MetricsInfo.BlockChainInfo blockchain = 3;
  bool has_blockchain() const;
  private:
  bool _internal_has_blockchain() const;
  public:
  void clear_blockchain();
  const ::protocol::MetricsInfo_BlockChainInfo& blockchain() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_BlockChainInfo* release_blockchain();
  ::protocol::MetricsInfo_BlockChainInfo* mutable_blockchain();
  void set_allocated_blockchain(::protocol::MetricsInfo_BlockChainInfo* blockchain);
  private:
  const ::protocol::MetricsInfo_BlockChainInfo& _internal_blockchain() const;
  ::protocol::MetricsInfo_BlockChainInfo* _internal_mutable_blockchain();
  public:
  void unsafe_arena_set_allocated_blockchain(
      ::protocol::MetricsInfo_BlockChainInfo* blockchain);
  ::protocol::MetricsInfo_BlockChainInfo* unsafe_arena_release_blockchain();

  // .protocol.MetricsInfo.NetInfo net = 4;
  bool has_net() const;
  private:
  bool _internal_has_net() const;
  public:
  void clear_net();
  const ::protocol::MetricsInfo_NetInfo& net() const;
  PROTOBUF_NODISCARD ::protocol::MetricsInfo_NetInfo* release_net();
  ::protocol::MetricsInfo_NetInfo* mutable_net();
  void set_allocated_net(::protocol::MetricsInfo_NetInfo* net);
  private:
  const ::protocol::MetricsInfo_NetInfo& _internal_net() const;
  ::protocol::MetricsInfo_NetInfo* _internal_mutable_net();
  public:
  void unsafe_arena_set_allocated_net(
      ::protocol::MetricsInfo_NetInfo* net);
  ::protocol::MetricsInfo_NetInfo* unsafe_arena_release_net();

  // int64 interval = 1;
  void clear_interval();
  int64_t interval() const;
  void set_interval(int64_t value);
  private:
  int64_t _internal_interval() const;
  void _internal_set_interval(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.MetricsInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protocol::MetricsInfo_NodeInfo* node_;
  ::protocol::MetricsInfo_BlockChainInfo* blockchain_;
  ::protocol::MetricsInfo_NetInfo* net_;
  int64_t interval_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class PBFTMessage_Raw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.PBFTMessage.Raw) */ {
 public:
  inline PBFTMessage_Raw() : PBFTMessage_Raw(nullptr) {}
  ~PBFTMessage_Raw() override;
  explicit constexpr PBFTMessage_Raw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PBFTMessage_Raw(const PBFTMessage_Raw& from);
  PBFTMessage_Raw(PBFTMessage_Raw&& from) noexcept
    : PBFTMessage_Raw() {
    *this = ::std::move(from);
  }

  inline PBFTMessage_Raw& operator=(const PBFTMessage_Raw& from) {
    CopyFrom(from);
    return *this;
  }
  inline PBFTMessage_Raw& operator=(PBFTMessage_Raw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PBFTMessage_Raw& default_instance() {
    return *internal_default_instance();
  }
  static inline const PBFTMessage_Raw* internal_default_instance() {
    return reinterpret_cast<const PBFTMessage_Raw*>(
               &_PBFTMessage_Raw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(PBFTMessage_Raw& a, PBFTMessage_Raw& b) {
    a.Swap(&b);
  }
  inline void Swap(PBFTMessage_Raw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PBFTMessage_Raw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PBFTMessage_Raw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PBFTMessage_Raw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PBFTMessage_Raw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PBFTMessage_Raw& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PBFTMessage_Raw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.PBFTMessage.Raw";
  }
  protected:
  explicit PBFTMessage_Raw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kMsgTypeFieldNumber = 1,
    kDataTypeFieldNumber = 2,
    kViewNFieldNumber = 3,
    kEpochFieldNumber = 4,
  };
  // bytes data = 5;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .protocol.PBFTMessage.MsgType msg_type = 1;
  void clear_msg_type();
  ::protocol::PBFTMessage_MsgType msg_type() const;
  void set_msg_type(::protocol::PBFTMessage_MsgType value);
  private:
  ::protocol::PBFTMessage_MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::protocol::PBFTMessage_MsgType value);
  public:

  // .protocol.PBFTMessage.DataType data_type = 2;
  void clear_data_type();
  ::protocol::PBFTMessage_DataType data_type() const;
  void set_data_type(::protocol::PBFTMessage_DataType value);
  private:
  ::protocol::PBFTMessage_DataType _internal_data_type() const;
  void _internal_set_data_type(::protocol::PBFTMessage_DataType value);
  public:

  // int64 view_n = 3;
  void clear_view_n();
  int64_t view_n() const;
  void set_view_n(int64_t value);
  private:
  int64_t _internal_view_n() const;
  void _internal_set_view_n(int64_t value);
  public:

  // int64 epoch = 4;
  void clear_epoch();
  int64_t epoch() const;
  void set_epoch(int64_t value);
  private:
  int64_t _internal_epoch() const;
  void _internal_set_epoch(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.PBFTMessage.Raw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int msg_type_;
  int data_type_;
  int64_t view_n_;
  int64_t epoch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class PBFTMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.PBFTMessage) */ {
 public:
  inline PBFTMessage() : PBFTMessage(nullptr) {}
  ~PBFTMessage() override;
  explicit constexpr PBFTMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PBFTMessage(const PBFTMessage& from);
  PBFTMessage(PBFTMessage&& from) noexcept
    : PBFTMessage() {
    *this = ::std::move(from);
  }

  inline PBFTMessage& operator=(const PBFTMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PBFTMessage& operator=(PBFTMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PBFTMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PBFTMessage* internal_default_instance() {
    return reinterpret_cast<const PBFTMessage*>(
               &_PBFTMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(PBFTMessage& a, PBFTMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PBFTMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PBFTMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PBFTMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PBFTMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PBFTMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PBFTMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PBFTMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.PBFTMessage";
  }
  protected:
  explicit PBFTMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PBFTMessage_Raw Raw;

  typedef PBFTMessage_MsgType MsgType;
  static constexpr MsgType VIEW_CHANGE =
    PBFTMessage_MsgType_VIEW_CHANGE;
  static constexpr MsgType REQUEST =
    PBFTMessage_MsgType_REQUEST;
  static constexpr MsgType PREPREPARE =
    PBFTMessage_MsgType_PREPREPARE;
  static constexpr MsgType PREPARE =
    PBFTMessage_MsgType_PREPARE;
  static constexpr MsgType COMMIT =
    PBFTMessage_MsgType_COMMIT;
  static inline bool MsgType_IsValid(int value) {
    return PBFTMessage_MsgType_IsValid(value);
  }
  static constexpr MsgType MsgType_MIN =
    PBFTMessage_MsgType_MsgType_MIN;
  static constexpr MsgType MsgType_MAX =
    PBFTMessage_MsgType_MsgType_MAX;
  static constexpr int MsgType_ARRAYSIZE =
    PBFTMessage_MsgType_MsgType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MsgType_descriptor() {
    return PBFTMessage_MsgType_descriptor();
  }
  template<typename T>
  static inline const std::string& MsgType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgType_Name.");
    return PBFTMessage_MsgType_Name(enum_t_value);
  }
  static inline bool MsgType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MsgType* value) {
    return PBFTMessage_MsgType_Parse(name, value);
  }

  typedef PBFTMessage_DataType DataType;
  static constexpr DataType BLOCK =
    PBFTMessage_DataType_BLOCK;
  static constexpr DataType SRL =
    PBFTMessage_DataType_SRL;
  static inline bool DataType_IsValid(int value) {
    return PBFTMessage_DataType_IsValid(value);
  }
  static constexpr DataType DataType_MIN =
    PBFTMessage_DataType_DataType_MIN;
  static constexpr DataType DataType_MAX =
    PBFTMessage_DataType_DataType_MAX;
  static constexpr int DataType_ARRAYSIZE =
    PBFTMessage_DataType_DataType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DataType_descriptor() {
    return PBFTMessage_DataType_descriptor();
  }
  template<typename T>
  static inline const std::string& DataType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DataType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DataType_Name.");
    return PBFTMessage_DataType_Name(enum_t_value);
  }
  static inline bool DataType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DataType* value) {
    return PBFTMessage_DataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 2,
    kRawDataFieldNumber = 1,
  };
  // bytes signature = 2;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // .protocol.PBFTMessage.Raw raw_data = 1;
  bool has_raw_data() const;
  private:
  bool _internal_has_raw_data() const;
  public:
  void clear_raw_data();
  const ::protocol::PBFTMessage_Raw& raw_data() const;
  PROTOBUF_NODISCARD ::protocol::PBFTMessage_Raw* release_raw_data();
  ::protocol::PBFTMessage_Raw* mutable_raw_data();
  void set_allocated_raw_data(::protocol::PBFTMessage_Raw* raw_data);
  private:
  const ::protocol::PBFTMessage_Raw& _internal_raw_data() const;
  ::protocol::PBFTMessage_Raw* _internal_mutable_raw_data();
  public:
  void unsafe_arena_set_allocated_raw_data(
      ::protocol::PBFTMessage_Raw* raw_data);
  ::protocol::PBFTMessage_Raw* unsafe_arena_release_raw_data();

  // @@protoc_insertion_point(class_scope:protocol.PBFTMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::protocol::PBFTMessage_Raw* raw_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class PBFTCommitResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.PBFTCommitResult) */ {
 public:
  inline PBFTCommitResult() : PBFTCommitResult(nullptr) {}
  ~PBFTCommitResult() override;
  explicit constexpr PBFTCommitResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PBFTCommitResult(const PBFTCommitResult& from);
  PBFTCommitResult(PBFTCommitResult&& from) noexcept
    : PBFTCommitResult() {
    *this = ::std::move(from);
  }

  inline PBFTCommitResult& operator=(const PBFTCommitResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline PBFTCommitResult& operator=(PBFTCommitResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PBFTCommitResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const PBFTCommitResult* internal_default_instance() {
    return reinterpret_cast<const PBFTCommitResult*>(
               &_PBFTCommitResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(PBFTCommitResult& a, PBFTCommitResult& b) {
    a.Swap(&b);
  }
  inline void Swap(PBFTCommitResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PBFTCommitResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PBFTCommitResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PBFTCommitResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PBFTCommitResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PBFTCommitResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PBFTCommitResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.PBFTCommitResult";
  }
  protected:
  explicit PBFTCommitResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 2,
    kDataFieldNumber = 1,
  };
  // repeated bytes signature = 2;
  int signature_size() const;
  private:
  int _internal_signature_size() const;
  public:
  void clear_signature();
  const std::string& signature(int index) const;
  std::string* mutable_signature(int index);
  void set_signature(int index, const std::string& value);
  void set_signature(int index, std::string&& value);
  void set_signature(int index, const char* value);
  void set_signature(int index, const void* value, size_t size);
  std::string* add_signature();
  void add_signature(const std::string& value);
  void add_signature(std::string&& value);
  void add_signature(const char* value);
  void add_signature(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signature() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signature();
  private:
  const std::string& _internal_signature(int index) const;
  std::string* _internal_add_signature();
  public:

  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:protocol.PBFTCommitResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// -------------------------------------------------------------------

class SRL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.SRL) */ {
 public:
  inline SRL() : SRL(nullptr) {}
  ~SRL() override;
  explicit constexpr SRL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SRL(const SRL& from);
  SRL(SRL&& from) noexcept
    : SRL() {
    *this = ::std::move(from);
  }

  inline SRL& operator=(const SRL& from) {
    CopyFrom(from);
    return *this;
  }
  inline SRL& operator=(SRL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SRL& default_instance() {
    return *internal_default_instance();
  }
  static inline const SRL* internal_default_instance() {
    return reinterpret_cast<const SRL*>(
               &_SRL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(SRL& a, SRL& b) {
    a.Swap(&b);
  }
  inline void Swap(SRL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SRL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SRL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SRL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SRL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SRL& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SRL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.SRL";
  }
  protected:
  explicit SRL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrAddressFieldNumber = 1,
  };
  // repeated bytes srAddress = 1;
  int sraddress_size() const;
  private:
  int _internal_sraddress_size() const;
  public:
  void clear_sraddress();
  const std::string& sraddress(int index) const;
  std::string* mutable_sraddress(int index);
  void set_sraddress(int index, const std::string& value);
  void set_sraddress(int index, std::string&& value);
  void set_sraddress(int index, const char* value);
  void set_sraddress(int index, const void* value, size_t size);
  std::string* add_sraddress();
  void add_sraddress(const std::string& value);
  void add_sraddress(std::string&& value);
  void add_sraddress(const char* value);
  void add_sraddress(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& sraddress() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_sraddress();
  private:
  const std::string& _internal_sraddress(int index) const;
  std::string* _internal_add_sraddress();
  public:

  // @@protoc_insertion_point(class_scope:protocol.SRL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> sraddress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_core_2fTron_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AccountId

// bytes name = 1;
inline void AccountId::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AccountId::name() const {
  // @@protoc_insertion_point(field_get:protocol.AccountId.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountId::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AccountId.name)
}
inline std::string* AccountId::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.AccountId.name)
  return _s;
}
inline const std::string& AccountId::_internal_name() const {
  return name_.Get();
}
inline void AccountId::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountId::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountId::release_name() {
  // @@protoc_insertion_point(field_release:protocol.AccountId.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountId::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountId.name)
}

// bytes address = 2;
inline void AccountId::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& AccountId::address() const {
  // @@protoc_insertion_point(field_get:protocol.AccountId.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountId::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AccountId.address)
}
inline std::string* AccountId::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.AccountId.address)
  return _s;
}
inline const std::string& AccountId::_internal_address() const {
  return address_.Get();
}
inline void AccountId::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountId::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountId::release_address() {
  // @@protoc_insertion_point(field_release:protocol.AccountId.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountId::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountId.address)
}

// -------------------------------------------------------------------

// Vote

// bytes vote_address = 1;
inline void Vote::clear_vote_address() {
  vote_address_.ClearToEmpty();
}
inline const std::string& Vote::vote_address() const {
  // @@protoc_insertion_point(field_get:protocol.Vote.vote_address)
  return _internal_vote_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Vote::set_vote_address(ArgT0&& arg0, ArgT... args) {
 
 vote_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Vote.vote_address)
}
inline std::string* Vote::mutable_vote_address() {
  std::string* _s = _internal_mutable_vote_address();
  // @@protoc_insertion_point(field_mutable:protocol.Vote.vote_address)
  return _s;
}
inline const std::string& Vote::_internal_vote_address() const {
  return vote_address_.Get();
}
inline void Vote::_internal_set_vote_address(const std::string& value) {
  
  vote_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Vote::_internal_mutable_vote_address() {
  
  return vote_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Vote::release_vote_address() {
  // @@protoc_insertion_point(field_release:protocol.Vote.vote_address)
  return vote_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Vote::set_allocated_vote_address(std::string* vote_address) {
  if (vote_address != nullptr) {
    
  } else {
    
  }
  vote_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vote_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vote_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vote_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Vote.vote_address)
}

// int64 vote_count = 2;
inline void Vote::clear_vote_count() {
  vote_count_ = int64_t{0};
}
inline int64_t Vote::_internal_vote_count() const {
  return vote_count_;
}
inline int64_t Vote::vote_count() const {
  // @@protoc_insertion_point(field_get:protocol.Vote.vote_count)
  return _internal_vote_count();
}
inline void Vote::_internal_set_vote_count(int64_t value) {
  
  vote_count_ = value;
}
inline void Vote::set_vote_count(int64_t value) {
  _internal_set_vote_count(value);
  // @@protoc_insertion_point(field_set:protocol.Vote.vote_count)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Proposal

// int64 proposal_id = 1;
inline void Proposal::clear_proposal_id() {
  proposal_id_ = int64_t{0};
}
inline int64_t Proposal::_internal_proposal_id() const {
  return proposal_id_;
}
inline int64_t Proposal::proposal_id() const {
  // @@protoc_insertion_point(field_get:protocol.Proposal.proposal_id)
  return _internal_proposal_id();
}
inline void Proposal::_internal_set_proposal_id(int64_t value) {
  
  proposal_id_ = value;
}
inline void Proposal::set_proposal_id(int64_t value) {
  _internal_set_proposal_id(value);
  // @@protoc_insertion_point(field_set:protocol.Proposal.proposal_id)
}

// bytes proposer_address = 2;
inline void Proposal::clear_proposer_address() {
  proposer_address_.ClearToEmpty();
}
inline const std::string& Proposal::proposer_address() const {
  // @@protoc_insertion_point(field_get:protocol.Proposal.proposer_address)
  return _internal_proposer_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Proposal::set_proposer_address(ArgT0&& arg0, ArgT... args) {
 
 proposer_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Proposal.proposer_address)
}
inline std::string* Proposal::mutable_proposer_address() {
  std::string* _s = _internal_mutable_proposer_address();
  // @@protoc_insertion_point(field_mutable:protocol.Proposal.proposer_address)
  return _s;
}
inline const std::string& Proposal::_internal_proposer_address() const {
  return proposer_address_.Get();
}
inline void Proposal::_internal_set_proposer_address(const std::string& value) {
  
  proposer_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Proposal::_internal_mutable_proposer_address() {
  
  return proposer_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Proposal::release_proposer_address() {
  // @@protoc_insertion_point(field_release:protocol.Proposal.proposer_address)
  return proposer_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Proposal::set_allocated_proposer_address(std::string* proposer_address) {
  if (proposer_address != nullptr) {
    
  } else {
    
  }
  proposer_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proposer_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (proposer_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    proposer_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Proposal.proposer_address)
}

// map<int64, int64> parameters = 3;
inline int Proposal::_internal_parameters_size() const {
  return parameters_.size();
}
inline int Proposal::parameters_size() const {
  return _internal_parameters_size();
}
inline void Proposal::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >&
Proposal::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >&
Proposal::parameters() const {
  // @@protoc_insertion_point(field_map:protocol.Proposal.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >*
Proposal::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, int64_t >*
Proposal::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:protocol.Proposal.parameters)
  return _internal_mutable_parameters();
}

// int64 expiration_time = 4;
inline void Proposal::clear_expiration_time() {
  expiration_time_ = int64_t{0};
}
inline int64_t Proposal::_internal_expiration_time() const {
  return expiration_time_;
}
inline int64_t Proposal::expiration_time() const {
  // @@protoc_insertion_point(field_get:protocol.Proposal.expiration_time)
  return _internal_expiration_time();
}
inline void Proposal::_internal_set_expiration_time(int64_t value) {
  
  expiration_time_ = value;
}
inline void Proposal::set_expiration_time(int64_t value) {
  _internal_set_expiration_time(value);
  // @@protoc_insertion_point(field_set:protocol.Proposal.expiration_time)
}

// int64 create_time = 5;
inline void Proposal::clear_create_time() {
  create_time_ = int64_t{0};
}
inline int64_t Proposal::_internal_create_time() const {
  return create_time_;
}
inline int64_t Proposal::create_time() const {
  // @@protoc_insertion_point(field_get:protocol.Proposal.create_time)
  return _internal_create_time();
}
inline void Proposal::_internal_set_create_time(int64_t value) {
  
  create_time_ = value;
}
inline void Proposal::set_create_time(int64_t value) {
  _internal_set_create_time(value);
  // @@protoc_insertion_point(field_set:protocol.Proposal.create_time)
}

// repeated bytes approvals = 6;
inline int Proposal::_internal_approvals_size() const {
  return approvals_.size();
}
inline int Proposal::approvals_size() const {
  return _internal_approvals_size();
}
inline void Proposal::clear_approvals() {
  approvals_.Clear();
}
inline std::string* Proposal::add_approvals() {
  std::string* _s = _internal_add_approvals();
  // @@protoc_insertion_point(field_add_mutable:protocol.Proposal.approvals)
  return _s;
}
inline const std::string& Proposal::_internal_approvals(int index) const {
  return approvals_.Get(index);
}
inline const std::string& Proposal::approvals(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Proposal.approvals)
  return _internal_approvals(index);
}
inline std::string* Proposal::mutable_approvals(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Proposal.approvals)
  return approvals_.Mutable(index);
}
inline void Proposal::set_approvals(int index, const std::string& value) {
  approvals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.Proposal.approvals)
}
inline void Proposal::set_approvals(int index, std::string&& value) {
  approvals_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.Proposal.approvals)
}
inline void Proposal::set_approvals(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  approvals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.Proposal.approvals)
}
inline void Proposal::set_approvals(int index, const void* value, size_t size) {
  approvals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.Proposal.approvals)
}
inline std::string* Proposal::_internal_add_approvals() {
  return approvals_.Add();
}
inline void Proposal::add_approvals(const std::string& value) {
  approvals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.Proposal.approvals)
}
inline void Proposal::add_approvals(std::string&& value) {
  approvals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.Proposal.approvals)
}
inline void Proposal::add_approvals(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  approvals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.Proposal.approvals)
}
inline void Proposal::add_approvals(const void* value, size_t size) {
  approvals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.Proposal.approvals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Proposal::approvals() const {
  // @@protoc_insertion_point(field_list:protocol.Proposal.approvals)
  return approvals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Proposal::mutable_approvals() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Proposal.approvals)
  return &approvals_;
}

// .protocol.Proposal.State state = 7;
inline void Proposal::clear_state() {
  state_ = 0;
}
inline ::protocol::Proposal_State Proposal::_internal_state() const {
  return static_cast< ::protocol::Proposal_State >(state_);
}
inline ::protocol::Proposal_State Proposal::state() const {
  // @@protoc_insertion_point(field_get:protocol.Proposal.state)
  return _internal_state();
}
inline void Proposal::_internal_set_state(::protocol::Proposal_State value) {
  
  state_ = value;
}
inline void Proposal::set_state(::protocol::Proposal_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:protocol.Proposal.state)
}

// -------------------------------------------------------------------

// Exchange

// int64 exchange_id = 1;
inline void Exchange::clear_exchange_id() {
  exchange_id_ = int64_t{0};
}
inline int64_t Exchange::_internal_exchange_id() const {
  return exchange_id_;
}
inline int64_t Exchange::exchange_id() const {
  // @@protoc_insertion_point(field_get:protocol.Exchange.exchange_id)
  return _internal_exchange_id();
}
inline void Exchange::_internal_set_exchange_id(int64_t value) {
  
  exchange_id_ = value;
}
inline void Exchange::set_exchange_id(int64_t value) {
  _internal_set_exchange_id(value);
  // @@protoc_insertion_point(field_set:protocol.Exchange.exchange_id)
}

// bytes creator_address = 2;
inline void Exchange::clear_creator_address() {
  creator_address_.ClearToEmpty();
}
inline const std::string& Exchange::creator_address() const {
  // @@protoc_insertion_point(field_get:protocol.Exchange.creator_address)
  return _internal_creator_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Exchange::set_creator_address(ArgT0&& arg0, ArgT... args) {
 
 creator_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Exchange.creator_address)
}
inline std::string* Exchange::mutable_creator_address() {
  std::string* _s = _internal_mutable_creator_address();
  // @@protoc_insertion_point(field_mutable:protocol.Exchange.creator_address)
  return _s;
}
inline const std::string& Exchange::_internal_creator_address() const {
  return creator_address_.Get();
}
inline void Exchange::_internal_set_creator_address(const std::string& value) {
  
  creator_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Exchange::_internal_mutable_creator_address() {
  
  return creator_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Exchange::release_creator_address() {
  // @@protoc_insertion_point(field_release:protocol.Exchange.creator_address)
  return creator_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Exchange::set_allocated_creator_address(std::string* creator_address) {
  if (creator_address != nullptr) {
    
  } else {
    
  }
  creator_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Exchange.creator_address)
}

// int64 create_time = 3;
inline void Exchange::clear_create_time() {
  create_time_ = int64_t{0};
}
inline int64_t Exchange::_internal_create_time() const {
  return create_time_;
}
inline int64_t Exchange::create_time() const {
  // @@protoc_insertion_point(field_get:protocol.Exchange.create_time)
  return _internal_create_time();
}
inline void Exchange::_internal_set_create_time(int64_t value) {
  
  create_time_ = value;
}
inline void Exchange::set_create_time(int64_t value) {
  _internal_set_create_time(value);
  // @@protoc_insertion_point(field_set:protocol.Exchange.create_time)
}

// bytes first_token_id = 6;
inline void Exchange::clear_first_token_id() {
  first_token_id_.ClearToEmpty();
}
inline const std::string& Exchange::first_token_id() const {
  // @@protoc_insertion_point(field_get:protocol.Exchange.first_token_id)
  return _internal_first_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Exchange::set_first_token_id(ArgT0&& arg0, ArgT... args) {
 
 first_token_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Exchange.first_token_id)
}
inline std::string* Exchange::mutable_first_token_id() {
  std::string* _s = _internal_mutable_first_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.Exchange.first_token_id)
  return _s;
}
inline const std::string& Exchange::_internal_first_token_id() const {
  return first_token_id_.Get();
}
inline void Exchange::_internal_set_first_token_id(const std::string& value) {
  
  first_token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Exchange::_internal_mutable_first_token_id() {
  
  return first_token_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Exchange::release_first_token_id() {
  // @@protoc_insertion_point(field_release:protocol.Exchange.first_token_id)
  return first_token_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Exchange::set_allocated_first_token_id(std::string* first_token_id) {
  if (first_token_id != nullptr) {
    
  } else {
    
  }
  first_token_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), first_token_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_token_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    first_token_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Exchange.first_token_id)
}

// int64 first_token_balance = 7;
inline void Exchange::clear_first_token_balance() {
  first_token_balance_ = int64_t{0};
}
inline int64_t Exchange::_internal_first_token_balance() const {
  return first_token_balance_;
}
inline int64_t Exchange::first_token_balance() const {
  // @@protoc_insertion_point(field_get:protocol.Exchange.first_token_balance)
  return _internal_first_token_balance();
}
inline void Exchange::_internal_set_first_token_balance(int64_t value) {
  
  first_token_balance_ = value;
}
inline void Exchange::set_first_token_balance(int64_t value) {
  _internal_set_first_token_balance(value);
  // @@protoc_insertion_point(field_set:protocol.Exchange.first_token_balance)
}

// bytes second_token_id = 8;
inline void Exchange::clear_second_token_id() {
  second_token_id_.ClearToEmpty();
}
inline const std::string& Exchange::second_token_id() const {
  // @@protoc_insertion_point(field_get:protocol.Exchange.second_token_id)
  return _internal_second_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Exchange::set_second_token_id(ArgT0&& arg0, ArgT... args) {
 
 second_token_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Exchange.second_token_id)
}
inline std::string* Exchange::mutable_second_token_id() {
  std::string* _s = _internal_mutable_second_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.Exchange.second_token_id)
  return _s;
}
inline const std::string& Exchange::_internal_second_token_id() const {
  return second_token_id_.Get();
}
inline void Exchange::_internal_set_second_token_id(const std::string& value) {
  
  second_token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Exchange::_internal_mutable_second_token_id() {
  
  return second_token_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Exchange::release_second_token_id() {
  // @@protoc_insertion_point(field_release:protocol.Exchange.second_token_id)
  return second_token_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Exchange::set_allocated_second_token_id(std::string* second_token_id) {
  if (second_token_id != nullptr) {
    
  } else {
    
  }
  second_token_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), second_token_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (second_token_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    second_token_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Exchange.second_token_id)
}

// int64 second_token_balance = 9;
inline void Exchange::clear_second_token_balance() {
  second_token_balance_ = int64_t{0};
}
inline int64_t Exchange::_internal_second_token_balance() const {
  return second_token_balance_;
}
inline int64_t Exchange::second_token_balance() const {
  // @@protoc_insertion_point(field_get:protocol.Exchange.second_token_balance)
  return _internal_second_token_balance();
}
inline void Exchange::_internal_set_second_token_balance(int64_t value) {
  
  second_token_balance_ = value;
}
inline void Exchange::set_second_token_balance(int64_t value) {
  _internal_set_second_token_balance(value);
  // @@protoc_insertion_point(field_set:protocol.Exchange.second_token_balance)
}

// -------------------------------------------------------------------

// MarketOrder

// bytes order_id = 1;
inline void MarketOrder::clear_order_id() {
  order_id_.ClearToEmpty();
}
inline const std::string& MarketOrder::order_id() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrder.order_id)
  return _internal_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrder::set_order_id(ArgT0&& arg0, ArgT... args) {
 
 order_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrder.order_id)
}
inline std::string* MarketOrder::mutable_order_id() {
  std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrder.order_id)
  return _s;
}
inline const std::string& MarketOrder::_internal_order_id() const {
  return order_id_.Get();
}
inline void MarketOrder::_internal_set_order_id(const std::string& value) {
  
  order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketOrder::_internal_mutable_order_id() {
  
  return order_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketOrder::release_order_id() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrder.order_id)
  return order_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketOrder::set_allocated_order_id(std::string* order_id) {
  if (order_id != nullptr) {
    
  } else {
    
  }
  order_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), order_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (order_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    order_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrder.order_id)
}

// bytes owner_address = 2;
inline void MarketOrder::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& MarketOrder::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrder.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrder::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrder.owner_address)
}
inline std::string* MarketOrder::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrder.owner_address)
  return _s;
}
inline const std::string& MarketOrder::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void MarketOrder::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketOrder::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketOrder::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrder.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketOrder::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrder.owner_address)
}

// int64 create_time = 3;
inline void MarketOrder::clear_create_time() {
  create_time_ = int64_t{0};
}
inline int64_t MarketOrder::_internal_create_time() const {
  return create_time_;
}
inline int64_t MarketOrder::create_time() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrder.create_time)
  return _internal_create_time();
}
inline void MarketOrder::_internal_set_create_time(int64_t value) {
  
  create_time_ = value;
}
inline void MarketOrder::set_create_time(int64_t value) {
  _internal_set_create_time(value);
  // @@protoc_insertion_point(field_set:protocol.MarketOrder.create_time)
}

// bytes sell_token_id = 4;
inline void MarketOrder::clear_sell_token_id() {
  sell_token_id_.ClearToEmpty();
}
inline const std::string& MarketOrder::sell_token_id() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrder.sell_token_id)
  return _internal_sell_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrder::set_sell_token_id(ArgT0&& arg0, ArgT... args) {
 
 sell_token_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrder.sell_token_id)
}
inline std::string* MarketOrder::mutable_sell_token_id() {
  std::string* _s = _internal_mutable_sell_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrder.sell_token_id)
  return _s;
}
inline const std::string& MarketOrder::_internal_sell_token_id() const {
  return sell_token_id_.Get();
}
inline void MarketOrder::_internal_set_sell_token_id(const std::string& value) {
  
  sell_token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketOrder::_internal_mutable_sell_token_id() {
  
  return sell_token_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketOrder::release_sell_token_id() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrder.sell_token_id)
  return sell_token_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketOrder::set_allocated_sell_token_id(std::string* sell_token_id) {
  if (sell_token_id != nullptr) {
    
  } else {
    
  }
  sell_token_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sell_token_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sell_token_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sell_token_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrder.sell_token_id)
}

// int64 sell_token_quantity = 5;
inline void MarketOrder::clear_sell_token_quantity() {
  sell_token_quantity_ = int64_t{0};
}
inline int64_t MarketOrder::_internal_sell_token_quantity() const {
  return sell_token_quantity_;
}
inline int64_t MarketOrder::sell_token_quantity() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrder.sell_token_quantity)
  return _internal_sell_token_quantity();
}
inline void MarketOrder::_internal_set_sell_token_quantity(int64_t value) {
  
  sell_token_quantity_ = value;
}
inline void MarketOrder::set_sell_token_quantity(int64_t value) {
  _internal_set_sell_token_quantity(value);
  // @@protoc_insertion_point(field_set:protocol.MarketOrder.sell_token_quantity)
}

// bytes buy_token_id = 6;
inline void MarketOrder::clear_buy_token_id() {
  buy_token_id_.ClearToEmpty();
}
inline const std::string& MarketOrder::buy_token_id() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrder.buy_token_id)
  return _internal_buy_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrder::set_buy_token_id(ArgT0&& arg0, ArgT... args) {
 
 buy_token_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrder.buy_token_id)
}
inline std::string* MarketOrder::mutable_buy_token_id() {
  std::string* _s = _internal_mutable_buy_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrder.buy_token_id)
  return _s;
}
inline const std::string& MarketOrder::_internal_buy_token_id() const {
  return buy_token_id_.Get();
}
inline void MarketOrder::_internal_set_buy_token_id(const std::string& value) {
  
  buy_token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketOrder::_internal_mutable_buy_token_id() {
  
  return buy_token_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketOrder::release_buy_token_id() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrder.buy_token_id)
  return buy_token_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketOrder::set_allocated_buy_token_id(std::string* buy_token_id) {
  if (buy_token_id != nullptr) {
    
  } else {
    
  }
  buy_token_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buy_token_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buy_token_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    buy_token_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrder.buy_token_id)
}

// int64 buy_token_quantity = 7;
inline void MarketOrder::clear_buy_token_quantity() {
  buy_token_quantity_ = int64_t{0};
}
inline int64_t MarketOrder::_internal_buy_token_quantity() const {
  return buy_token_quantity_;
}
inline int64_t MarketOrder::buy_token_quantity() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrder.buy_token_quantity)
  return _internal_buy_token_quantity();
}
inline void MarketOrder::_internal_set_buy_token_quantity(int64_t value) {
  
  buy_token_quantity_ = value;
}
inline void MarketOrder::set_buy_token_quantity(int64_t value) {
  _internal_set_buy_token_quantity(value);
  // @@protoc_insertion_point(field_set:protocol.MarketOrder.buy_token_quantity)
}

// int64 sell_token_quantity_remain = 9;
inline void MarketOrder::clear_sell_token_quantity_remain() {
  sell_token_quantity_remain_ = int64_t{0};
}
inline int64_t MarketOrder::_internal_sell_token_quantity_remain() const {
  return sell_token_quantity_remain_;
}
inline int64_t MarketOrder::sell_token_quantity_remain() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrder.sell_token_quantity_remain)
  return _internal_sell_token_quantity_remain();
}
inline void MarketOrder::_internal_set_sell_token_quantity_remain(int64_t value) {
  
  sell_token_quantity_remain_ = value;
}
inline void MarketOrder::set_sell_token_quantity_remain(int64_t value) {
  _internal_set_sell_token_quantity_remain(value);
  // @@protoc_insertion_point(field_set:protocol.MarketOrder.sell_token_quantity_remain)
}

// int64 sell_token_quantity_return = 10;
inline void MarketOrder::clear_sell_token_quantity_return() {
  sell_token_quantity_return_ = int64_t{0};
}
inline int64_t MarketOrder::_internal_sell_token_quantity_return() const {
  return sell_token_quantity_return_;
}
inline int64_t MarketOrder::sell_token_quantity_return() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrder.sell_token_quantity_return)
  return _internal_sell_token_quantity_return();
}
inline void MarketOrder::_internal_set_sell_token_quantity_return(int64_t value) {
  
  sell_token_quantity_return_ = value;
}
inline void MarketOrder::set_sell_token_quantity_return(int64_t value) {
  _internal_set_sell_token_quantity_return(value);
  // @@protoc_insertion_point(field_set:protocol.MarketOrder.sell_token_quantity_return)
}

// .protocol.MarketOrder.State state = 11;
inline void MarketOrder::clear_state() {
  state_ = 0;
}
inline ::protocol::MarketOrder_State MarketOrder::_internal_state() const {
  return static_cast< ::protocol::MarketOrder_State >(state_);
}
inline ::protocol::MarketOrder_State MarketOrder::state() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrder.state)
  return _internal_state();
}
inline void MarketOrder::_internal_set_state(::protocol::MarketOrder_State value) {
  
  state_ = value;
}
inline void MarketOrder::set_state(::protocol::MarketOrder_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:protocol.MarketOrder.state)
}

// bytes prev = 12;
inline void MarketOrder::clear_prev() {
  prev_.ClearToEmpty();
}
inline const std::string& MarketOrder::prev() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrder.prev)
  return _internal_prev();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrder::set_prev(ArgT0&& arg0, ArgT... args) {
 
 prev_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrder.prev)
}
inline std::string* MarketOrder::mutable_prev() {
  std::string* _s = _internal_mutable_prev();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrder.prev)
  return _s;
}
inline const std::string& MarketOrder::_internal_prev() const {
  return prev_.Get();
}
inline void MarketOrder::_internal_set_prev(const std::string& value) {
  
  prev_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketOrder::_internal_mutable_prev() {
  
  return prev_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketOrder::release_prev() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrder.prev)
  return prev_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketOrder::set_allocated_prev(std::string* prev) {
  if (prev != nullptr) {
    
  } else {
    
  }
  prev_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prev,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prev_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    prev_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrder.prev)
}

// bytes next = 13;
inline void MarketOrder::clear_next() {
  next_.ClearToEmpty();
}
inline const std::string& MarketOrder::next() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrder.next)
  return _internal_next();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrder::set_next(ArgT0&& arg0, ArgT... args) {
 
 next_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrder.next)
}
inline std::string* MarketOrder::mutable_next() {
  std::string* _s = _internal_mutable_next();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrder.next)
  return _s;
}
inline const std::string& MarketOrder::_internal_next() const {
  return next_.Get();
}
inline void MarketOrder::_internal_set_next(const std::string& value) {
  
  next_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketOrder::_internal_mutable_next() {
  
  return next_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketOrder::release_next() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrder.next)
  return next_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketOrder::set_allocated_next(std::string* next) {
  if (next != nullptr) {
    
  } else {
    
  }
  next_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    next_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrder.next)
}

// -------------------------------------------------------------------

// MarketOrderList

// repeated .protocol.MarketOrder orders = 1;
inline int MarketOrderList::_internal_orders_size() const {
  return orders_.size();
}
inline int MarketOrderList::orders_size() const {
  return _internal_orders_size();
}
inline void MarketOrderList::clear_orders() {
  orders_.Clear();
}
inline ::protocol::MarketOrder* MarketOrderList::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrderList.orders)
  return orders_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrder >*
MarketOrderList::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:protocol.MarketOrderList.orders)
  return &orders_;
}
inline const ::protocol::MarketOrder& MarketOrderList::_internal_orders(int index) const {
  return orders_.Get(index);
}
inline const ::protocol::MarketOrder& MarketOrderList::orders(int index) const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderList.orders)
  return _internal_orders(index);
}
inline ::protocol::MarketOrder* MarketOrderList::_internal_add_orders() {
  return orders_.Add();
}
inline ::protocol::MarketOrder* MarketOrderList::add_orders() {
  ::protocol::MarketOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:protocol.MarketOrderList.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrder >&
MarketOrderList::orders() const {
  // @@protoc_insertion_point(field_list:protocol.MarketOrderList.orders)
  return orders_;
}

// -------------------------------------------------------------------

// MarketOrderPairList

// repeated .protocol.MarketOrderPair orderPair = 1;
inline int MarketOrderPairList::_internal_orderpair_size() const {
  return orderpair_.size();
}
inline int MarketOrderPairList::orderpair_size() const {
  return _internal_orderpair_size();
}
inline void MarketOrderPairList::clear_orderpair() {
  orderpair_.Clear();
}
inline ::protocol::MarketOrderPair* MarketOrderPairList::mutable_orderpair(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrderPairList.orderPair)
  return orderpair_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderPair >*
MarketOrderPairList::mutable_orderpair() {
  // @@protoc_insertion_point(field_mutable_list:protocol.MarketOrderPairList.orderPair)
  return &orderpair_;
}
inline const ::protocol::MarketOrderPair& MarketOrderPairList::_internal_orderpair(int index) const {
  return orderpair_.Get(index);
}
inline const ::protocol::MarketOrderPair& MarketOrderPairList::orderpair(int index) const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderPairList.orderPair)
  return _internal_orderpair(index);
}
inline ::protocol::MarketOrderPair* MarketOrderPairList::_internal_add_orderpair() {
  return orderpair_.Add();
}
inline ::protocol::MarketOrderPair* MarketOrderPairList::add_orderpair() {
  ::protocol::MarketOrderPair* _add = _internal_add_orderpair();
  // @@protoc_insertion_point(field_add:protocol.MarketOrderPairList.orderPair)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderPair >&
MarketOrderPairList::orderpair() const {
  // @@protoc_insertion_point(field_list:protocol.MarketOrderPairList.orderPair)
  return orderpair_;
}

// -------------------------------------------------------------------

// MarketOrderPair

// bytes sell_token_id = 1;
inline void MarketOrderPair::clear_sell_token_id() {
  sell_token_id_.ClearToEmpty();
}
inline const std::string& MarketOrderPair::sell_token_id() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderPair.sell_token_id)
  return _internal_sell_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrderPair::set_sell_token_id(ArgT0&& arg0, ArgT... args) {
 
 sell_token_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrderPair.sell_token_id)
}
inline std::string* MarketOrderPair::mutable_sell_token_id() {
  std::string* _s = _internal_mutable_sell_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrderPair.sell_token_id)
  return _s;
}
inline const std::string& MarketOrderPair::_internal_sell_token_id() const {
  return sell_token_id_.Get();
}
inline void MarketOrderPair::_internal_set_sell_token_id(const std::string& value) {
  
  sell_token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketOrderPair::_internal_mutable_sell_token_id() {
  
  return sell_token_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketOrderPair::release_sell_token_id() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrderPair.sell_token_id)
  return sell_token_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketOrderPair::set_allocated_sell_token_id(std::string* sell_token_id) {
  if (sell_token_id != nullptr) {
    
  } else {
    
  }
  sell_token_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sell_token_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sell_token_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sell_token_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrderPair.sell_token_id)
}

// bytes buy_token_id = 2;
inline void MarketOrderPair::clear_buy_token_id() {
  buy_token_id_.ClearToEmpty();
}
inline const std::string& MarketOrderPair::buy_token_id() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderPair.buy_token_id)
  return _internal_buy_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrderPair::set_buy_token_id(ArgT0&& arg0, ArgT... args) {
 
 buy_token_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrderPair.buy_token_id)
}
inline std::string* MarketOrderPair::mutable_buy_token_id() {
  std::string* _s = _internal_mutable_buy_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrderPair.buy_token_id)
  return _s;
}
inline const std::string& MarketOrderPair::_internal_buy_token_id() const {
  return buy_token_id_.Get();
}
inline void MarketOrderPair::_internal_set_buy_token_id(const std::string& value) {
  
  buy_token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketOrderPair::_internal_mutable_buy_token_id() {
  
  return buy_token_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketOrderPair::release_buy_token_id() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrderPair.buy_token_id)
  return buy_token_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketOrderPair::set_allocated_buy_token_id(std::string* buy_token_id) {
  if (buy_token_id != nullptr) {
    
  } else {
    
  }
  buy_token_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buy_token_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buy_token_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    buy_token_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrderPair.buy_token_id)
}

// -------------------------------------------------------------------

// MarketAccountOrder

// bytes owner_address = 1;
inline void MarketAccountOrder::clear_owner_address() {
  owner_address_.ClearToEmpty();
}
inline const std::string& MarketAccountOrder::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.MarketAccountOrder.owner_address)
  return _internal_owner_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketAccountOrder::set_owner_address(ArgT0&& arg0, ArgT... args) {
 
 owner_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketAccountOrder.owner_address)
}
inline std::string* MarketAccountOrder::mutable_owner_address() {
  std::string* _s = _internal_mutable_owner_address();
  // @@protoc_insertion_point(field_mutable:protocol.MarketAccountOrder.owner_address)
  return _s;
}
inline const std::string& MarketAccountOrder::_internal_owner_address() const {
  return owner_address_.Get();
}
inline void MarketAccountOrder::_internal_set_owner_address(const std::string& value) {
  
  owner_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketAccountOrder::_internal_mutable_owner_address() {
  
  return owner_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketAccountOrder::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.MarketAccountOrder.owner_address)
  return owner_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketAccountOrder::set_allocated_owner_address(std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketAccountOrder.owner_address)
}

// repeated bytes orders = 2;
inline int MarketAccountOrder::_internal_orders_size() const {
  return orders_.size();
}
inline int MarketAccountOrder::orders_size() const {
  return _internal_orders_size();
}
inline void MarketAccountOrder::clear_orders() {
  orders_.Clear();
}
inline std::string* MarketAccountOrder::add_orders() {
  std::string* _s = _internal_add_orders();
  // @@protoc_insertion_point(field_add_mutable:protocol.MarketAccountOrder.orders)
  return _s;
}
inline const std::string& MarketAccountOrder::_internal_orders(int index) const {
  return orders_.Get(index);
}
inline const std::string& MarketAccountOrder::orders(int index) const {
  // @@protoc_insertion_point(field_get:protocol.MarketAccountOrder.orders)
  return _internal_orders(index);
}
inline std::string* MarketAccountOrder::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.MarketAccountOrder.orders)
  return orders_.Mutable(index);
}
inline void MarketAccountOrder::set_orders(int index, const std::string& value) {
  orders_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.MarketAccountOrder.orders)
}
inline void MarketAccountOrder::set_orders(int index, std::string&& value) {
  orders_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.MarketAccountOrder.orders)
}
inline void MarketAccountOrder::set_orders(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  orders_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.MarketAccountOrder.orders)
}
inline void MarketAccountOrder::set_orders(int index, const void* value, size_t size) {
  orders_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.MarketAccountOrder.orders)
}
inline std::string* MarketAccountOrder::_internal_add_orders() {
  return orders_.Add();
}
inline void MarketAccountOrder::add_orders(const std::string& value) {
  orders_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.MarketAccountOrder.orders)
}
inline void MarketAccountOrder::add_orders(std::string&& value) {
  orders_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.MarketAccountOrder.orders)
}
inline void MarketAccountOrder::add_orders(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  orders_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.MarketAccountOrder.orders)
}
inline void MarketAccountOrder::add_orders(const void* value, size_t size) {
  orders_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.MarketAccountOrder.orders)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MarketAccountOrder::orders() const {
  // @@protoc_insertion_point(field_list:protocol.MarketAccountOrder.orders)
  return orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MarketAccountOrder::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:protocol.MarketAccountOrder.orders)
  return &orders_;
}

// int64 count = 3;
inline void MarketAccountOrder::clear_count() {
  count_ = int64_t{0};
}
inline int64_t MarketAccountOrder::_internal_count() const {
  return count_;
}
inline int64_t MarketAccountOrder::count() const {
  // @@protoc_insertion_point(field_get:protocol.MarketAccountOrder.count)
  return _internal_count();
}
inline void MarketAccountOrder::_internal_set_count(int64_t value) {
  
  count_ = value;
}
inline void MarketAccountOrder::set_count(int64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:protocol.MarketAccountOrder.count)
}

// int64 total_count = 4;
inline void MarketAccountOrder::clear_total_count() {
  total_count_ = int64_t{0};
}
inline int64_t MarketAccountOrder::_internal_total_count() const {
  return total_count_;
}
inline int64_t MarketAccountOrder::total_count() const {
  // @@protoc_insertion_point(field_get:protocol.MarketAccountOrder.total_count)
  return _internal_total_count();
}
inline void MarketAccountOrder::_internal_set_total_count(int64_t value) {
  
  total_count_ = value;
}
inline void MarketAccountOrder::set_total_count(int64_t value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:protocol.MarketAccountOrder.total_count)
}

// -------------------------------------------------------------------

// MarketPrice

// int64 sell_token_quantity = 1;
inline void MarketPrice::clear_sell_token_quantity() {
  sell_token_quantity_ = int64_t{0};
}
inline int64_t MarketPrice::_internal_sell_token_quantity() const {
  return sell_token_quantity_;
}
inline int64_t MarketPrice::sell_token_quantity() const {
  // @@protoc_insertion_point(field_get:protocol.MarketPrice.sell_token_quantity)
  return _internal_sell_token_quantity();
}
inline void MarketPrice::_internal_set_sell_token_quantity(int64_t value) {
  
  sell_token_quantity_ = value;
}
inline void MarketPrice::set_sell_token_quantity(int64_t value) {
  _internal_set_sell_token_quantity(value);
  // @@protoc_insertion_point(field_set:protocol.MarketPrice.sell_token_quantity)
}

// int64 buy_token_quantity = 2;
inline void MarketPrice::clear_buy_token_quantity() {
  buy_token_quantity_ = int64_t{0};
}
inline int64_t MarketPrice::_internal_buy_token_quantity() const {
  return buy_token_quantity_;
}
inline int64_t MarketPrice::buy_token_quantity() const {
  // @@protoc_insertion_point(field_get:protocol.MarketPrice.buy_token_quantity)
  return _internal_buy_token_quantity();
}
inline void MarketPrice::_internal_set_buy_token_quantity(int64_t value) {
  
  buy_token_quantity_ = value;
}
inline void MarketPrice::set_buy_token_quantity(int64_t value) {
  _internal_set_buy_token_quantity(value);
  // @@protoc_insertion_point(field_set:protocol.MarketPrice.buy_token_quantity)
}

// -------------------------------------------------------------------

// MarketPriceList

// bytes sell_token_id = 1;
inline void MarketPriceList::clear_sell_token_id() {
  sell_token_id_.ClearToEmpty();
}
inline const std::string& MarketPriceList::sell_token_id() const {
  // @@protoc_insertion_point(field_get:protocol.MarketPriceList.sell_token_id)
  return _internal_sell_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketPriceList::set_sell_token_id(ArgT0&& arg0, ArgT... args) {
 
 sell_token_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketPriceList.sell_token_id)
}
inline std::string* MarketPriceList::mutable_sell_token_id() {
  std::string* _s = _internal_mutable_sell_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.MarketPriceList.sell_token_id)
  return _s;
}
inline const std::string& MarketPriceList::_internal_sell_token_id() const {
  return sell_token_id_.Get();
}
inline void MarketPriceList::_internal_set_sell_token_id(const std::string& value) {
  
  sell_token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketPriceList::_internal_mutable_sell_token_id() {
  
  return sell_token_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketPriceList::release_sell_token_id() {
  // @@protoc_insertion_point(field_release:protocol.MarketPriceList.sell_token_id)
  return sell_token_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketPriceList::set_allocated_sell_token_id(std::string* sell_token_id) {
  if (sell_token_id != nullptr) {
    
  } else {
    
  }
  sell_token_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sell_token_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sell_token_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sell_token_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketPriceList.sell_token_id)
}

// bytes buy_token_id = 2;
inline void MarketPriceList::clear_buy_token_id() {
  buy_token_id_.ClearToEmpty();
}
inline const std::string& MarketPriceList::buy_token_id() const {
  // @@protoc_insertion_point(field_get:protocol.MarketPriceList.buy_token_id)
  return _internal_buy_token_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketPriceList::set_buy_token_id(ArgT0&& arg0, ArgT... args) {
 
 buy_token_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketPriceList.buy_token_id)
}
inline std::string* MarketPriceList::mutable_buy_token_id() {
  std::string* _s = _internal_mutable_buy_token_id();
  // @@protoc_insertion_point(field_mutable:protocol.MarketPriceList.buy_token_id)
  return _s;
}
inline const std::string& MarketPriceList::_internal_buy_token_id() const {
  return buy_token_id_.Get();
}
inline void MarketPriceList::_internal_set_buy_token_id(const std::string& value) {
  
  buy_token_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketPriceList::_internal_mutable_buy_token_id() {
  
  return buy_token_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketPriceList::release_buy_token_id() {
  // @@protoc_insertion_point(field_release:protocol.MarketPriceList.buy_token_id)
  return buy_token_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketPriceList::set_allocated_buy_token_id(std::string* buy_token_id) {
  if (buy_token_id != nullptr) {
    
  } else {
    
  }
  buy_token_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buy_token_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buy_token_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    buy_token_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketPriceList.buy_token_id)
}

// repeated .protocol.MarketPrice prices = 3;
inline int MarketPriceList::_internal_prices_size() const {
  return prices_.size();
}
inline int MarketPriceList::prices_size() const {
  return _internal_prices_size();
}
inline void MarketPriceList::clear_prices() {
  prices_.Clear();
}
inline ::protocol::MarketPrice* MarketPriceList::mutable_prices(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.MarketPriceList.prices)
  return prices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketPrice >*
MarketPriceList::mutable_prices() {
  // @@protoc_insertion_point(field_mutable_list:protocol.MarketPriceList.prices)
  return &prices_;
}
inline const ::protocol::MarketPrice& MarketPriceList::_internal_prices(int index) const {
  return prices_.Get(index);
}
inline const ::protocol::MarketPrice& MarketPriceList::prices(int index) const {
  // @@protoc_insertion_point(field_get:protocol.MarketPriceList.prices)
  return _internal_prices(index);
}
inline ::protocol::MarketPrice* MarketPriceList::_internal_add_prices() {
  return prices_.Add();
}
inline ::protocol::MarketPrice* MarketPriceList::add_prices() {
  ::protocol::MarketPrice* _add = _internal_add_prices();
  // @@protoc_insertion_point(field_add:protocol.MarketPriceList.prices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketPrice >&
MarketPriceList::prices() const {
  // @@protoc_insertion_point(field_list:protocol.MarketPriceList.prices)
  return prices_;
}

// -------------------------------------------------------------------

// MarketOrderIdList

// bytes head = 1;
inline void MarketOrderIdList::clear_head() {
  head_.ClearToEmpty();
}
inline const std::string& MarketOrderIdList::head() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderIdList.head)
  return _internal_head();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrderIdList::set_head(ArgT0&& arg0, ArgT... args) {
 
 head_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrderIdList.head)
}
inline std::string* MarketOrderIdList::mutable_head() {
  std::string* _s = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrderIdList.head)
  return _s;
}
inline const std::string& MarketOrderIdList::_internal_head() const {
  return head_.Get();
}
inline void MarketOrderIdList::_internal_set_head(const std::string& value) {
  
  head_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketOrderIdList::_internal_mutable_head() {
  
  return head_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketOrderIdList::release_head() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrderIdList.head)
  return head_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketOrderIdList::set_allocated_head(std::string* head) {
  if (head != nullptr) {
    
  } else {
    
  }
  head_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), head,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (head_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    head_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrderIdList.head)
}

// bytes tail = 2;
inline void MarketOrderIdList::clear_tail() {
  tail_.ClearToEmpty();
}
inline const std::string& MarketOrderIdList::tail() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderIdList.tail)
  return _internal_tail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrderIdList::set_tail(ArgT0&& arg0, ArgT... args) {
 
 tail_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrderIdList.tail)
}
inline std::string* MarketOrderIdList::mutable_tail() {
  std::string* _s = _internal_mutable_tail();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrderIdList.tail)
  return _s;
}
inline const std::string& MarketOrderIdList::_internal_tail() const {
  return tail_.Get();
}
inline void MarketOrderIdList::_internal_set_tail(const std::string& value) {
  
  tail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketOrderIdList::_internal_mutable_tail() {
  
  return tail_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketOrderIdList::release_tail() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrderIdList.tail)
  return tail_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketOrderIdList::set_allocated_tail(std::string* tail) {
  if (tail != nullptr) {
    
  } else {
    
  }
  tail_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tail,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tail_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrderIdList.tail)
}

// -------------------------------------------------------------------

// ChainParameters_ChainParameter

// string key = 1;
inline void ChainParameters_ChainParameter::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& ChainParameters_ChainParameter::key() const {
  // @@protoc_insertion_point(field_get:protocol.ChainParameters.ChainParameter.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChainParameters_ChainParameter::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ChainParameters.ChainParameter.key)
}
inline std::string* ChainParameters_ChainParameter::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:protocol.ChainParameters.ChainParameter.key)
  return _s;
}
inline const std::string& ChainParameters_ChainParameter::_internal_key() const {
  return key_.Get();
}
inline void ChainParameters_ChainParameter::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChainParameters_ChainParameter::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChainParameters_ChainParameter::release_key() {
  // @@protoc_insertion_point(field_release:protocol.ChainParameters.ChainParameter.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChainParameters_ChainParameter::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainParameters.ChainParameter.key)
}

// int64 value = 2;
inline void ChainParameters_ChainParameter::clear_value() {
  value_ = int64_t{0};
}
inline int64_t ChainParameters_ChainParameter::_internal_value() const {
  return value_;
}
inline int64_t ChainParameters_ChainParameter::value() const {
  // @@protoc_insertion_point(field_get:protocol.ChainParameters.ChainParameter.value)
  return _internal_value();
}
inline void ChainParameters_ChainParameter::_internal_set_value(int64_t value) {
  
  value_ = value;
}
inline void ChainParameters_ChainParameter::set_value(int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:protocol.ChainParameters.ChainParameter.value)
}

// -------------------------------------------------------------------

// ChainParameters

// repeated .protocol.ChainParameters.ChainParameter chainParameter = 1;
inline int ChainParameters::_internal_chainparameter_size() const {
  return chainparameter_.size();
}
inline int ChainParameters::chainparameter_size() const {
  return _internal_chainparameter_size();
}
inline void ChainParameters::clear_chainparameter() {
  chainparameter_.Clear();
}
inline ::protocol::ChainParameters_ChainParameter* ChainParameters::mutable_chainparameter(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ChainParameters.chainParameter)
  return chainparameter_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ChainParameters_ChainParameter >*
ChainParameters::mutable_chainparameter() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ChainParameters.chainParameter)
  return &chainparameter_;
}
inline const ::protocol::ChainParameters_ChainParameter& ChainParameters::_internal_chainparameter(int index) const {
  return chainparameter_.Get(index);
}
inline const ::protocol::ChainParameters_ChainParameter& ChainParameters::chainparameter(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ChainParameters.chainParameter)
  return _internal_chainparameter(index);
}
inline ::protocol::ChainParameters_ChainParameter* ChainParameters::_internal_add_chainparameter() {
  return chainparameter_.Add();
}
inline ::protocol::ChainParameters_ChainParameter* ChainParameters::add_chainparameter() {
  ::protocol::ChainParameters_ChainParameter* _add = _internal_add_chainparameter();
  // @@protoc_insertion_point(field_add:protocol.ChainParameters.chainParameter)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ChainParameters_ChainParameter >&
ChainParameters::chainparameter() const {
  // @@protoc_insertion_point(field_list:protocol.ChainParameters.chainParameter)
  return chainparameter_;
}

// -------------------------------------------------------------------

// Account_Frozen

// int64 frozen_balance = 1;
inline void Account_Frozen::clear_frozen_balance() {
  frozen_balance_ = int64_t{0};
}
inline int64_t Account_Frozen::_internal_frozen_balance() const {
  return frozen_balance_;
}
inline int64_t Account_Frozen::frozen_balance() const {
  // @@protoc_insertion_point(field_get:protocol.Account.Frozen.frozen_balance)
  return _internal_frozen_balance();
}
inline void Account_Frozen::_internal_set_frozen_balance(int64_t value) {
  
  frozen_balance_ = value;
}
inline void Account_Frozen::set_frozen_balance(int64_t value) {
  _internal_set_frozen_balance(value);
  // @@protoc_insertion_point(field_set:protocol.Account.Frozen.frozen_balance)
}

// int64 expire_time = 2;
inline void Account_Frozen::clear_expire_time() {
  expire_time_ = int64_t{0};
}
inline int64_t Account_Frozen::_internal_expire_time() const {
  return expire_time_;
}
inline int64_t Account_Frozen::expire_time() const {
  // @@protoc_insertion_point(field_get:protocol.Account.Frozen.expire_time)
  return _internal_expire_time();
}
inline void Account_Frozen::_internal_set_expire_time(int64_t value) {
  
  expire_time_ = value;
}
inline void Account_Frozen::set_expire_time(int64_t value) {
  _internal_set_expire_time(value);
  // @@protoc_insertion_point(field_set:protocol.Account.Frozen.expire_time)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Account_AccountResource

// int64 energy_usage = 1;
inline void Account_AccountResource::clear_energy_usage() {
  energy_usage_ = int64_t{0};
}
inline int64_t Account_AccountResource::_internal_energy_usage() const {
  return energy_usage_;
}
inline int64_t Account_AccountResource::energy_usage() const {
  // @@protoc_insertion_point(field_get:protocol.Account.AccountResource.energy_usage)
  return _internal_energy_usage();
}
inline void Account_AccountResource::_internal_set_energy_usage(int64_t value) {
  
  energy_usage_ = value;
}
inline void Account_AccountResource::set_energy_usage(int64_t value) {
  _internal_set_energy_usage(value);
  // @@protoc_insertion_point(field_set:protocol.Account.AccountResource.energy_usage)
}

// .protocol.Account.Frozen frozen_balance_for_energy = 2;
inline bool Account_AccountResource::_internal_has_frozen_balance_for_energy() const {
  return this != internal_default_instance() && frozen_balance_for_energy_ != nullptr;
}
inline bool Account_AccountResource::has_frozen_balance_for_energy() const {
  return _internal_has_frozen_balance_for_energy();
}
inline void Account_AccountResource::clear_frozen_balance_for_energy() {
  if (GetArenaForAllocation() == nullptr && frozen_balance_for_energy_ != nullptr) {
    delete frozen_balance_for_energy_;
  }
  frozen_balance_for_energy_ = nullptr;
}
inline const ::protocol::Account_Frozen& Account_AccountResource::_internal_frozen_balance_for_energy() const {
  const ::protocol::Account_Frozen* p = frozen_balance_for_energy_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Account_Frozen&>(
      ::protocol::_Account_Frozen_default_instance_);
}
inline const ::protocol::Account_Frozen& Account_AccountResource::frozen_balance_for_energy() const {
  // @@protoc_insertion_point(field_get:protocol.Account.AccountResource.frozen_balance_for_energy)
  return _internal_frozen_balance_for_energy();
}
inline void Account_AccountResource::unsafe_arena_set_allocated_frozen_balance_for_energy(
    ::protocol::Account_Frozen* frozen_balance_for_energy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frozen_balance_for_energy_);
  }
  frozen_balance_for_energy_ = frozen_balance_for_energy;
  if (frozen_balance_for_energy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Account.AccountResource.frozen_balance_for_energy)
}
inline ::protocol::Account_Frozen* Account_AccountResource::release_frozen_balance_for_energy() {
  
  ::protocol::Account_Frozen* temp = frozen_balance_for_energy_;
  frozen_balance_for_energy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Account_Frozen* Account_AccountResource::unsafe_arena_release_frozen_balance_for_energy() {
  // @@protoc_insertion_point(field_release:protocol.Account.AccountResource.frozen_balance_for_energy)
  
  ::protocol::Account_Frozen* temp = frozen_balance_for_energy_;
  frozen_balance_for_energy_ = nullptr;
  return temp;
}
inline ::protocol::Account_Frozen* Account_AccountResource::_internal_mutable_frozen_balance_for_energy() {
  
  if (frozen_balance_for_energy_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Account_Frozen>(GetArenaForAllocation());
    frozen_balance_for_energy_ = p;
  }
  return frozen_balance_for_energy_;
}
inline ::protocol::Account_Frozen* Account_AccountResource::mutable_frozen_balance_for_energy() {
  ::protocol::Account_Frozen* _msg = _internal_mutable_frozen_balance_for_energy();
  // @@protoc_insertion_point(field_mutable:protocol.Account.AccountResource.frozen_balance_for_energy)
  return _msg;
}
inline void Account_AccountResource::set_allocated_frozen_balance_for_energy(::protocol::Account_Frozen* frozen_balance_for_energy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete frozen_balance_for_energy_;
  }
  if (frozen_balance_for_energy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Account_Frozen>::GetOwningArena(frozen_balance_for_energy);
    if (message_arena != submessage_arena) {
      frozen_balance_for_energy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frozen_balance_for_energy, submessage_arena);
    }
    
  } else {
    
  }
  frozen_balance_for_energy_ = frozen_balance_for_energy;
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.AccountResource.frozen_balance_for_energy)
}

// int64 latest_consume_time_for_energy = 3;
inline void Account_AccountResource::clear_latest_consume_time_for_energy() {
  latest_consume_time_for_energy_ = int64_t{0};
}
inline int64_t Account_AccountResource::_internal_latest_consume_time_for_energy() const {
  return latest_consume_time_for_energy_;
}
inline int64_t Account_AccountResource::latest_consume_time_for_energy() const {
  // @@protoc_insertion_point(field_get:protocol.Account.AccountResource.latest_consume_time_for_energy)
  return _internal_latest_consume_time_for_energy();
}
inline void Account_AccountResource::_internal_set_latest_consume_time_for_energy(int64_t value) {
  
  latest_consume_time_for_energy_ = value;
}
inline void Account_AccountResource::set_latest_consume_time_for_energy(int64_t value) {
  _internal_set_latest_consume_time_for_energy(value);
  // @@protoc_insertion_point(field_set:protocol.Account.AccountResource.latest_consume_time_for_energy)
}

// int64 acquired_delegated_frozen_balance_for_energy = 4;
inline void Account_AccountResource::clear_acquired_delegated_frozen_balance_for_energy() {
  acquired_delegated_frozen_balance_for_energy_ = int64_t{0};
}
inline int64_t Account_AccountResource::_internal_acquired_delegated_frozen_balance_for_energy() const {
  return acquired_delegated_frozen_balance_for_energy_;
}
inline int64_t Account_AccountResource::acquired_delegated_frozen_balance_for_energy() const {
  // @@protoc_insertion_point(field_get:protocol.Account.AccountResource.acquired_delegated_frozen_balance_for_energy)
  return _internal_acquired_delegated_frozen_balance_for_energy();
}
inline void Account_AccountResource::_internal_set_acquired_delegated_frozen_balance_for_energy(int64_t value) {
  
  acquired_delegated_frozen_balance_for_energy_ = value;
}
inline void Account_AccountResource::set_acquired_delegated_frozen_balance_for_energy(int64_t value) {
  _internal_set_acquired_delegated_frozen_balance_for_energy(value);
  // @@protoc_insertion_point(field_set:protocol.Account.AccountResource.acquired_delegated_frozen_balance_for_energy)
}

// int64 delegated_frozen_balance_for_energy = 5;
inline void Account_AccountResource::clear_delegated_frozen_balance_for_energy() {
  delegated_frozen_balance_for_energy_ = int64_t{0};
}
inline int64_t Account_AccountResource::_internal_delegated_frozen_balance_for_energy() const {
  return delegated_frozen_balance_for_energy_;
}
inline int64_t Account_AccountResource::delegated_frozen_balance_for_energy() const {
  // @@protoc_insertion_point(field_get:protocol.Account.AccountResource.delegated_frozen_balance_for_energy)
  return _internal_delegated_frozen_balance_for_energy();
}
inline void Account_AccountResource::_internal_set_delegated_frozen_balance_for_energy(int64_t value) {
  
  delegated_frozen_balance_for_energy_ = value;
}
inline void Account_AccountResource::set_delegated_frozen_balance_for_energy(int64_t value) {
  _internal_set_delegated_frozen_balance_for_energy(value);
  // @@protoc_insertion_point(field_set:protocol.Account.AccountResource.delegated_frozen_balance_for_energy)
}

// int64 storage_limit = 6;
inline void Account_AccountResource::clear_storage_limit() {
  storage_limit_ = int64_t{0};
}
inline int64_t Account_AccountResource::_internal_storage_limit() const {
  return storage_limit_;
}
inline int64_t Account_AccountResource::storage_limit() const {
  // @@protoc_insertion_point(field_get:protocol.Account.AccountResource.storage_limit)
  return _internal_storage_limit();
}
inline void Account_AccountResource::_internal_set_storage_limit(int64_t value) {
  
  storage_limit_ = value;
}
inline void Account_AccountResource::set_storage_limit(int64_t value) {
  _internal_set_storage_limit(value);
  // @@protoc_insertion_point(field_set:protocol.Account.AccountResource.storage_limit)
}

// int64 storage_usage = 7;
inline void Account_AccountResource::clear_storage_usage() {
  storage_usage_ = int64_t{0};
}
inline int64_t Account_AccountResource::_internal_storage_usage() const {
  return storage_usage_;
}
inline int64_t Account_AccountResource::storage_usage() const {
  // @@protoc_insertion_point(field_get:protocol.Account.AccountResource.storage_usage)
  return _internal_storage_usage();
}
inline void Account_AccountResource::_internal_set_storage_usage(int64_t value) {
  
  storage_usage_ = value;
}
inline void Account_AccountResource::set_storage_usage(int64_t value) {
  _internal_set_storage_usage(value);
  // @@protoc_insertion_point(field_set:protocol.Account.AccountResource.storage_usage)
}

// int64 latest_exchange_storage_time = 8;
inline void Account_AccountResource::clear_latest_exchange_storage_time() {
  latest_exchange_storage_time_ = int64_t{0};
}
inline int64_t Account_AccountResource::_internal_latest_exchange_storage_time() const {
  return latest_exchange_storage_time_;
}
inline int64_t Account_AccountResource::latest_exchange_storage_time() const {
  // @@protoc_insertion_point(field_get:protocol.Account.AccountResource.latest_exchange_storage_time)
  return _internal_latest_exchange_storage_time();
}
inline void Account_AccountResource::_internal_set_latest_exchange_storage_time(int64_t value) {
  
  latest_exchange_storage_time_ = value;
}
inline void Account_AccountResource::set_latest_exchange_storage_time(int64_t value) {
  _internal_set_latest_exchange_storage_time(value);
  // @@protoc_insertion_point(field_set:protocol.Account.AccountResource.latest_exchange_storage_time)
}

// -------------------------------------------------------------------

// Account

// bytes account_name = 1;
inline void Account::clear_account_name() {
  account_name_.ClearToEmpty();
}
inline const std::string& Account::account_name() const {
  // @@protoc_insertion_point(field_get:protocol.Account.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Account::set_account_name(ArgT0&& arg0, ArgT... args) {
 
 account_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Account.account_name)
}
inline std::string* Account::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:protocol.Account.account_name)
  return _s;
}
inline const std::string& Account::_internal_account_name() const {
  return account_name_.Get();
}
inline void Account::_internal_set_account_name(const std::string& value) {
  
  account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Account::_internal_mutable_account_name() {
  
  return account_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Account::release_account_name() {
  // @@protoc_insertion_point(field_release:protocol.Account.account_name)
  return account_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Account::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    
  } else {
    
  }
  account_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.account_name)
}

// .protocol.AccountType type = 2;
inline void Account::clear_type() {
  type_ = 0;
}
inline ::protocol::AccountType Account::_internal_type() const {
  return static_cast< ::protocol::AccountType >(type_);
}
inline ::protocol::AccountType Account::type() const {
  // @@protoc_insertion_point(field_get:protocol.Account.type)
  return _internal_type();
}
inline void Account::_internal_set_type(::protocol::AccountType value) {
  
  type_ = value;
}
inline void Account::set_type(::protocol::AccountType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.Account.type)
}

// bytes address = 3;
inline void Account::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& Account::address() const {
  // @@protoc_insertion_point(field_get:protocol.Account.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Account::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Account.address)
}
inline std::string* Account::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.Account.address)
  return _s;
}
inline const std::string& Account::_internal_address() const {
  return address_.Get();
}
inline void Account::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Account::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Account::release_address() {
  // @@protoc_insertion_point(field_release:protocol.Account.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Account::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.address)
}

// int64 balance = 4;
inline void Account::clear_balance() {
  balance_ = int64_t{0};
}
inline int64_t Account::_internal_balance() const {
  return balance_;
}
inline int64_t Account::balance() const {
  // @@protoc_insertion_point(field_get:protocol.Account.balance)
  return _internal_balance();
}
inline void Account::_internal_set_balance(int64_t value) {
  
  balance_ = value;
}
inline void Account::set_balance(int64_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:protocol.Account.balance)
}

// repeated .protocol.Vote votes = 5;
inline int Account::_internal_votes_size() const {
  return votes_.size();
}
inline int Account::votes_size() const {
  return _internal_votes_size();
}
inline void Account::clear_votes() {
  votes_.Clear();
}
inline ::protocol::Vote* Account::mutable_votes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Account.votes)
  return votes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote >*
Account::mutable_votes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Account.votes)
  return &votes_;
}
inline const ::protocol::Vote& Account::_internal_votes(int index) const {
  return votes_.Get(index);
}
inline const ::protocol::Vote& Account::votes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Account.votes)
  return _internal_votes(index);
}
inline ::protocol::Vote* Account::_internal_add_votes() {
  return votes_.Add();
}
inline ::protocol::Vote* Account::add_votes() {
  ::protocol::Vote* _add = _internal_add_votes();
  // @@protoc_insertion_point(field_add:protocol.Account.votes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote >&
Account::votes() const {
  // @@protoc_insertion_point(field_list:protocol.Account.votes)
  return votes_;
}

// map<string, int64> asset = 6;
inline int Account::_internal_asset_size() const {
  return asset_.size();
}
inline int Account::asset_size() const {
  return _internal_asset_size();
}
inline void Account::clear_asset() {
  asset_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Account::_internal_asset() const {
  return asset_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Account::asset() const {
  // @@protoc_insertion_point(field_map:protocol.Account.asset)
  return _internal_asset();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Account::_internal_mutable_asset() {
  return asset_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Account::mutable_asset() {
  // @@protoc_insertion_point(field_mutable_map:protocol.Account.asset)
  return _internal_mutable_asset();
}

// map<string, int64> assetV2 = 56;
inline int Account::_internal_assetv2_size() const {
  return assetv2_.size();
}
inline int Account::assetv2_size() const {
  return _internal_assetv2_size();
}
inline void Account::clear_assetv2() {
  assetv2_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Account::_internal_assetv2() const {
  return assetv2_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Account::assetv2() const {
  // @@protoc_insertion_point(field_map:protocol.Account.assetV2)
  return _internal_assetv2();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Account::_internal_mutable_assetv2() {
  return assetv2_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Account::mutable_assetv2() {
  // @@protoc_insertion_point(field_mutable_map:protocol.Account.assetV2)
  return _internal_mutable_assetv2();
}

// repeated .protocol.Account.Frozen frozen = 7;
inline int Account::_internal_frozen_size() const {
  return frozen_.size();
}
inline int Account::frozen_size() const {
  return _internal_frozen_size();
}
inline void Account::clear_frozen() {
  frozen_.Clear();
}
inline ::protocol::Account_Frozen* Account::mutable_frozen(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Account.frozen)
  return frozen_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Account_Frozen >*
Account::mutable_frozen() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Account.frozen)
  return &frozen_;
}
inline const ::protocol::Account_Frozen& Account::_internal_frozen(int index) const {
  return frozen_.Get(index);
}
inline const ::protocol::Account_Frozen& Account::frozen(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Account.frozen)
  return _internal_frozen(index);
}
inline ::protocol::Account_Frozen* Account::_internal_add_frozen() {
  return frozen_.Add();
}
inline ::protocol::Account_Frozen* Account::add_frozen() {
  ::protocol::Account_Frozen* _add = _internal_add_frozen();
  // @@protoc_insertion_point(field_add:protocol.Account.frozen)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Account_Frozen >&
Account::frozen() const {
  // @@protoc_insertion_point(field_list:protocol.Account.frozen)
  return frozen_;
}

// int64 net_usage = 8;
inline void Account::clear_net_usage() {
  net_usage_ = int64_t{0};
}
inline int64_t Account::_internal_net_usage() const {
  return net_usage_;
}
inline int64_t Account::net_usage() const {
  // @@protoc_insertion_point(field_get:protocol.Account.net_usage)
  return _internal_net_usage();
}
inline void Account::_internal_set_net_usage(int64_t value) {
  
  net_usage_ = value;
}
inline void Account::set_net_usage(int64_t value) {
  _internal_set_net_usage(value);
  // @@protoc_insertion_point(field_set:protocol.Account.net_usage)
}

// int64 acquired_delegated_frozen_balance_for_bandwidth = 41;
inline void Account::clear_acquired_delegated_frozen_balance_for_bandwidth() {
  acquired_delegated_frozen_balance_for_bandwidth_ = int64_t{0};
}
inline int64_t Account::_internal_acquired_delegated_frozen_balance_for_bandwidth() const {
  return acquired_delegated_frozen_balance_for_bandwidth_;
}
inline int64_t Account::acquired_delegated_frozen_balance_for_bandwidth() const {
  // @@protoc_insertion_point(field_get:protocol.Account.acquired_delegated_frozen_balance_for_bandwidth)
  return _internal_acquired_delegated_frozen_balance_for_bandwidth();
}
inline void Account::_internal_set_acquired_delegated_frozen_balance_for_bandwidth(int64_t value) {
  
  acquired_delegated_frozen_balance_for_bandwidth_ = value;
}
inline void Account::set_acquired_delegated_frozen_balance_for_bandwidth(int64_t value) {
  _internal_set_acquired_delegated_frozen_balance_for_bandwidth(value);
  // @@protoc_insertion_point(field_set:protocol.Account.acquired_delegated_frozen_balance_for_bandwidth)
}

// int64 delegated_frozen_balance_for_bandwidth = 42;
inline void Account::clear_delegated_frozen_balance_for_bandwidth() {
  delegated_frozen_balance_for_bandwidth_ = int64_t{0};
}
inline int64_t Account::_internal_delegated_frozen_balance_for_bandwidth() const {
  return delegated_frozen_balance_for_bandwidth_;
}
inline int64_t Account::delegated_frozen_balance_for_bandwidth() const {
  // @@protoc_insertion_point(field_get:protocol.Account.delegated_frozen_balance_for_bandwidth)
  return _internal_delegated_frozen_balance_for_bandwidth();
}
inline void Account::_internal_set_delegated_frozen_balance_for_bandwidth(int64_t value) {
  
  delegated_frozen_balance_for_bandwidth_ = value;
}
inline void Account::set_delegated_frozen_balance_for_bandwidth(int64_t value) {
  _internal_set_delegated_frozen_balance_for_bandwidth(value);
  // @@protoc_insertion_point(field_set:protocol.Account.delegated_frozen_balance_for_bandwidth)
}

// int64 old_tron_power = 46;
inline void Account::clear_old_tron_power() {
  old_tron_power_ = int64_t{0};
}
inline int64_t Account::_internal_old_tron_power() const {
  return old_tron_power_;
}
inline int64_t Account::old_tron_power() const {
  // @@protoc_insertion_point(field_get:protocol.Account.old_tron_power)
  return _internal_old_tron_power();
}
inline void Account::_internal_set_old_tron_power(int64_t value) {
  
  old_tron_power_ = value;
}
inline void Account::set_old_tron_power(int64_t value) {
  _internal_set_old_tron_power(value);
  // @@protoc_insertion_point(field_set:protocol.Account.old_tron_power)
}

// .protocol.Account.Frozen tron_power = 47;
inline bool Account::_internal_has_tron_power() const {
  return this != internal_default_instance() && tron_power_ != nullptr;
}
inline bool Account::has_tron_power() const {
  return _internal_has_tron_power();
}
inline void Account::clear_tron_power() {
  if (GetArenaForAllocation() == nullptr && tron_power_ != nullptr) {
    delete tron_power_;
  }
  tron_power_ = nullptr;
}
inline const ::protocol::Account_Frozen& Account::_internal_tron_power() const {
  const ::protocol::Account_Frozen* p = tron_power_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Account_Frozen&>(
      ::protocol::_Account_Frozen_default_instance_);
}
inline const ::protocol::Account_Frozen& Account::tron_power() const {
  // @@protoc_insertion_point(field_get:protocol.Account.tron_power)
  return _internal_tron_power();
}
inline void Account::unsafe_arena_set_allocated_tron_power(
    ::protocol::Account_Frozen* tron_power) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tron_power_);
  }
  tron_power_ = tron_power;
  if (tron_power) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Account.tron_power)
}
inline ::protocol::Account_Frozen* Account::release_tron_power() {
  
  ::protocol::Account_Frozen* temp = tron_power_;
  tron_power_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Account_Frozen* Account::unsafe_arena_release_tron_power() {
  // @@protoc_insertion_point(field_release:protocol.Account.tron_power)
  
  ::protocol::Account_Frozen* temp = tron_power_;
  tron_power_ = nullptr;
  return temp;
}
inline ::protocol::Account_Frozen* Account::_internal_mutable_tron_power() {
  
  if (tron_power_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Account_Frozen>(GetArenaForAllocation());
    tron_power_ = p;
  }
  return tron_power_;
}
inline ::protocol::Account_Frozen* Account::mutable_tron_power() {
  ::protocol::Account_Frozen* _msg = _internal_mutable_tron_power();
  // @@protoc_insertion_point(field_mutable:protocol.Account.tron_power)
  return _msg;
}
inline void Account::set_allocated_tron_power(::protocol::Account_Frozen* tron_power) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tron_power_;
  }
  if (tron_power) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Account_Frozen>::GetOwningArena(tron_power);
    if (message_arena != submessage_arena) {
      tron_power = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tron_power, submessage_arena);
    }
    
  } else {
    
  }
  tron_power_ = tron_power;
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.tron_power)
}

// int64 create_time = 9;
inline void Account::clear_create_time() {
  create_time_ = int64_t{0};
}
inline int64_t Account::_internal_create_time() const {
  return create_time_;
}
inline int64_t Account::create_time() const {
  // @@protoc_insertion_point(field_get:protocol.Account.create_time)
  return _internal_create_time();
}
inline void Account::_internal_set_create_time(int64_t value) {
  
  create_time_ = value;
}
inline void Account::set_create_time(int64_t value) {
  _internal_set_create_time(value);
  // @@protoc_insertion_point(field_set:protocol.Account.create_time)
}

// int64 latest_opration_time = 10;
inline void Account::clear_latest_opration_time() {
  latest_opration_time_ = int64_t{0};
}
inline int64_t Account::_internal_latest_opration_time() const {
  return latest_opration_time_;
}
inline int64_t Account::latest_opration_time() const {
  // @@protoc_insertion_point(field_get:protocol.Account.latest_opration_time)
  return _internal_latest_opration_time();
}
inline void Account::_internal_set_latest_opration_time(int64_t value) {
  
  latest_opration_time_ = value;
}
inline void Account::set_latest_opration_time(int64_t value) {
  _internal_set_latest_opration_time(value);
  // @@protoc_insertion_point(field_set:protocol.Account.latest_opration_time)
}

// int64 allowance = 11;
inline void Account::clear_allowance() {
  allowance_ = int64_t{0};
}
inline int64_t Account::_internal_allowance() const {
  return allowance_;
}
inline int64_t Account::allowance() const {
  // @@protoc_insertion_point(field_get:protocol.Account.allowance)
  return _internal_allowance();
}
inline void Account::_internal_set_allowance(int64_t value) {
  
  allowance_ = value;
}
inline void Account::set_allowance(int64_t value) {
  _internal_set_allowance(value);
  // @@protoc_insertion_point(field_set:protocol.Account.allowance)
}

// int64 latest_withdraw_time = 12;
inline void Account::clear_latest_withdraw_time() {
  latest_withdraw_time_ = int64_t{0};
}
inline int64_t Account::_internal_latest_withdraw_time() const {
  return latest_withdraw_time_;
}
inline int64_t Account::latest_withdraw_time() const {
  // @@protoc_insertion_point(field_get:protocol.Account.latest_withdraw_time)
  return _internal_latest_withdraw_time();
}
inline void Account::_internal_set_latest_withdraw_time(int64_t value) {
  
  latest_withdraw_time_ = value;
}
inline void Account::set_latest_withdraw_time(int64_t value) {
  _internal_set_latest_withdraw_time(value);
  // @@protoc_insertion_point(field_set:protocol.Account.latest_withdraw_time)
}

// bytes code = 13;
inline void Account::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& Account::code() const {
  // @@protoc_insertion_point(field_get:protocol.Account.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Account::set_code(ArgT0&& arg0, ArgT... args) {
 
 code_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Account.code)
}
inline std::string* Account::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:protocol.Account.code)
  return _s;
}
inline const std::string& Account::_internal_code() const {
  return code_.Get();
}
inline void Account::_internal_set_code(const std::string& value) {
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Account::_internal_mutable_code() {
  
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Account::release_code() {
  // @@protoc_insertion_point(field_release:protocol.Account.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Account::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.code)
}

// bool is_witness = 14;
inline void Account::clear_is_witness() {
  is_witness_ = false;
}
inline bool Account::_internal_is_witness() const {
  return is_witness_;
}
inline bool Account::is_witness() const {
  // @@protoc_insertion_point(field_get:protocol.Account.is_witness)
  return _internal_is_witness();
}
inline void Account::_internal_set_is_witness(bool value) {
  
  is_witness_ = value;
}
inline void Account::set_is_witness(bool value) {
  _internal_set_is_witness(value);
  // @@protoc_insertion_point(field_set:protocol.Account.is_witness)
}

// bool is_committee = 15;
inline void Account::clear_is_committee() {
  is_committee_ = false;
}
inline bool Account::_internal_is_committee() const {
  return is_committee_;
}
inline bool Account::is_committee() const {
  // @@protoc_insertion_point(field_get:protocol.Account.is_committee)
  return _internal_is_committee();
}
inline void Account::_internal_set_is_committee(bool value) {
  
  is_committee_ = value;
}
inline void Account::set_is_committee(bool value) {
  _internal_set_is_committee(value);
  // @@protoc_insertion_point(field_set:protocol.Account.is_committee)
}

// repeated .protocol.Account.Frozen frozen_supply = 16;
inline int Account::_internal_frozen_supply_size() const {
  return frozen_supply_.size();
}
inline int Account::frozen_supply_size() const {
  return _internal_frozen_supply_size();
}
inline void Account::clear_frozen_supply() {
  frozen_supply_.Clear();
}
inline ::protocol::Account_Frozen* Account::mutable_frozen_supply(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Account.frozen_supply)
  return frozen_supply_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Account_Frozen >*
Account::mutable_frozen_supply() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Account.frozen_supply)
  return &frozen_supply_;
}
inline const ::protocol::Account_Frozen& Account::_internal_frozen_supply(int index) const {
  return frozen_supply_.Get(index);
}
inline const ::protocol::Account_Frozen& Account::frozen_supply(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Account.frozen_supply)
  return _internal_frozen_supply(index);
}
inline ::protocol::Account_Frozen* Account::_internal_add_frozen_supply() {
  return frozen_supply_.Add();
}
inline ::protocol::Account_Frozen* Account::add_frozen_supply() {
  ::protocol::Account_Frozen* _add = _internal_add_frozen_supply();
  // @@protoc_insertion_point(field_add:protocol.Account.frozen_supply)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Account_Frozen >&
Account::frozen_supply() const {
  // @@protoc_insertion_point(field_list:protocol.Account.frozen_supply)
  return frozen_supply_;
}

// bytes asset_issued_name = 17;
inline void Account::clear_asset_issued_name() {
  asset_issued_name_.ClearToEmpty();
}
inline const std::string& Account::asset_issued_name() const {
  // @@protoc_insertion_point(field_get:protocol.Account.asset_issued_name)
  return _internal_asset_issued_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Account::set_asset_issued_name(ArgT0&& arg0, ArgT... args) {
 
 asset_issued_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Account.asset_issued_name)
}
inline std::string* Account::mutable_asset_issued_name() {
  std::string* _s = _internal_mutable_asset_issued_name();
  // @@protoc_insertion_point(field_mutable:protocol.Account.asset_issued_name)
  return _s;
}
inline const std::string& Account::_internal_asset_issued_name() const {
  return asset_issued_name_.Get();
}
inline void Account::_internal_set_asset_issued_name(const std::string& value) {
  
  asset_issued_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Account::_internal_mutable_asset_issued_name() {
  
  return asset_issued_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Account::release_asset_issued_name() {
  // @@protoc_insertion_point(field_release:protocol.Account.asset_issued_name)
  return asset_issued_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Account::set_allocated_asset_issued_name(std::string* asset_issued_name) {
  if (asset_issued_name != nullptr) {
    
  } else {
    
  }
  asset_issued_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), asset_issued_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (asset_issued_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    asset_issued_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.asset_issued_name)
}

// bytes asset_issued_ID = 57;
inline void Account::clear_asset_issued_id() {
  asset_issued_id_.ClearToEmpty();
}
inline const std::string& Account::asset_issued_id() const {
  // @@protoc_insertion_point(field_get:protocol.Account.asset_issued_ID)
  return _internal_asset_issued_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Account::set_asset_issued_id(ArgT0&& arg0, ArgT... args) {
 
 asset_issued_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Account.asset_issued_ID)
}
inline std::string* Account::mutable_asset_issued_id() {
  std::string* _s = _internal_mutable_asset_issued_id();
  // @@protoc_insertion_point(field_mutable:protocol.Account.asset_issued_ID)
  return _s;
}
inline const std::string& Account::_internal_asset_issued_id() const {
  return asset_issued_id_.Get();
}
inline void Account::_internal_set_asset_issued_id(const std::string& value) {
  
  asset_issued_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Account::_internal_mutable_asset_issued_id() {
  
  return asset_issued_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Account::release_asset_issued_id() {
  // @@protoc_insertion_point(field_release:protocol.Account.asset_issued_ID)
  return asset_issued_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Account::set_allocated_asset_issued_id(std::string* asset_issued_id) {
  if (asset_issued_id != nullptr) {
    
  } else {
    
  }
  asset_issued_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), asset_issued_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (asset_issued_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    asset_issued_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.asset_issued_ID)
}

// map<string, int64> latest_asset_operation_time = 18;
inline int Account::_internal_latest_asset_operation_time_size() const {
  return latest_asset_operation_time_.size();
}
inline int Account::latest_asset_operation_time_size() const {
  return _internal_latest_asset_operation_time_size();
}
inline void Account::clear_latest_asset_operation_time() {
  latest_asset_operation_time_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Account::_internal_latest_asset_operation_time() const {
  return latest_asset_operation_time_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Account::latest_asset_operation_time() const {
  // @@protoc_insertion_point(field_map:protocol.Account.latest_asset_operation_time)
  return _internal_latest_asset_operation_time();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Account::_internal_mutable_latest_asset_operation_time() {
  return latest_asset_operation_time_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Account::mutable_latest_asset_operation_time() {
  // @@protoc_insertion_point(field_mutable_map:protocol.Account.latest_asset_operation_time)
  return _internal_mutable_latest_asset_operation_time();
}

// map<string, int64> latest_asset_operation_timeV2 = 58;
inline int Account::_internal_latest_asset_operation_timev2_size() const {
  return latest_asset_operation_timev2_.size();
}
inline int Account::latest_asset_operation_timev2_size() const {
  return _internal_latest_asset_operation_timev2_size();
}
inline void Account::clear_latest_asset_operation_timev2() {
  latest_asset_operation_timev2_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Account::_internal_latest_asset_operation_timev2() const {
  return latest_asset_operation_timev2_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Account::latest_asset_operation_timev2() const {
  // @@protoc_insertion_point(field_map:protocol.Account.latest_asset_operation_timeV2)
  return _internal_latest_asset_operation_timev2();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Account::_internal_mutable_latest_asset_operation_timev2() {
  return latest_asset_operation_timev2_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Account::mutable_latest_asset_operation_timev2() {
  // @@protoc_insertion_point(field_mutable_map:protocol.Account.latest_asset_operation_timeV2)
  return _internal_mutable_latest_asset_operation_timev2();
}

// int64 free_net_usage = 19;
inline void Account::clear_free_net_usage() {
  free_net_usage_ = int64_t{0};
}
inline int64_t Account::_internal_free_net_usage() const {
  return free_net_usage_;
}
inline int64_t Account::free_net_usage() const {
  // @@protoc_insertion_point(field_get:protocol.Account.free_net_usage)
  return _internal_free_net_usage();
}
inline void Account::_internal_set_free_net_usage(int64_t value) {
  
  free_net_usage_ = value;
}
inline void Account::set_free_net_usage(int64_t value) {
  _internal_set_free_net_usage(value);
  // @@protoc_insertion_point(field_set:protocol.Account.free_net_usage)
}

// map<string, int64> free_asset_net_usage = 20;
inline int Account::_internal_free_asset_net_usage_size() const {
  return free_asset_net_usage_.size();
}
inline int Account::free_asset_net_usage_size() const {
  return _internal_free_asset_net_usage_size();
}
inline void Account::clear_free_asset_net_usage() {
  free_asset_net_usage_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Account::_internal_free_asset_net_usage() const {
  return free_asset_net_usage_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Account::free_asset_net_usage() const {
  // @@protoc_insertion_point(field_map:protocol.Account.free_asset_net_usage)
  return _internal_free_asset_net_usage();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Account::_internal_mutable_free_asset_net_usage() {
  return free_asset_net_usage_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Account::mutable_free_asset_net_usage() {
  // @@protoc_insertion_point(field_mutable_map:protocol.Account.free_asset_net_usage)
  return _internal_mutable_free_asset_net_usage();
}

// map<string, int64> free_asset_net_usageV2 = 59;
inline int Account::_internal_free_asset_net_usagev2_size() const {
  return free_asset_net_usagev2_.size();
}
inline int Account::free_asset_net_usagev2_size() const {
  return _internal_free_asset_net_usagev2_size();
}
inline void Account::clear_free_asset_net_usagev2() {
  free_asset_net_usagev2_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Account::_internal_free_asset_net_usagev2() const {
  return free_asset_net_usagev2_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
Account::free_asset_net_usagev2() const {
  // @@protoc_insertion_point(field_map:protocol.Account.free_asset_net_usageV2)
  return _internal_free_asset_net_usagev2();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Account::_internal_mutable_free_asset_net_usagev2() {
  return free_asset_net_usagev2_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
Account::mutable_free_asset_net_usagev2() {
  // @@protoc_insertion_point(field_mutable_map:protocol.Account.free_asset_net_usageV2)
  return _internal_mutable_free_asset_net_usagev2();
}

// int64 latest_consume_time = 21;
inline void Account::clear_latest_consume_time() {
  latest_consume_time_ = int64_t{0};
}
inline int64_t Account::_internal_latest_consume_time() const {
  return latest_consume_time_;
}
inline int64_t Account::latest_consume_time() const {
  // @@protoc_insertion_point(field_get:protocol.Account.latest_consume_time)
  return _internal_latest_consume_time();
}
inline void Account::_internal_set_latest_consume_time(int64_t value) {
  
  latest_consume_time_ = value;
}
inline void Account::set_latest_consume_time(int64_t value) {
  _internal_set_latest_consume_time(value);
  // @@protoc_insertion_point(field_set:protocol.Account.latest_consume_time)
}

// int64 latest_consume_free_time = 22;
inline void Account::clear_latest_consume_free_time() {
  latest_consume_free_time_ = int64_t{0};
}
inline int64_t Account::_internal_latest_consume_free_time() const {
  return latest_consume_free_time_;
}
inline int64_t Account::latest_consume_free_time() const {
  // @@protoc_insertion_point(field_get:protocol.Account.latest_consume_free_time)
  return _internal_latest_consume_free_time();
}
inline void Account::_internal_set_latest_consume_free_time(int64_t value) {
  
  latest_consume_free_time_ = value;
}
inline void Account::set_latest_consume_free_time(int64_t value) {
  _internal_set_latest_consume_free_time(value);
  // @@protoc_insertion_point(field_set:protocol.Account.latest_consume_free_time)
}

// bytes account_id = 23;
inline void Account::clear_account_id() {
  account_id_.ClearToEmpty();
}
inline const std::string& Account::account_id() const {
  // @@protoc_insertion_point(field_get:protocol.Account.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Account::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 account_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Account.account_id)
}
inline std::string* Account::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:protocol.Account.account_id)
  return _s;
}
inline const std::string& Account::_internal_account_id() const {
  return account_id_.Get();
}
inline void Account::_internal_set_account_id(const std::string& value) {
  
  account_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Account::_internal_mutable_account_id() {
  
  return account_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Account::release_account_id() {
  // @@protoc_insertion_point(field_release:protocol.Account.account_id)
  return account_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Account::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  account_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.account_id)
}

// .protocol.Account.AccountResource account_resource = 26;
inline bool Account::_internal_has_account_resource() const {
  return this != internal_default_instance() && account_resource_ != nullptr;
}
inline bool Account::has_account_resource() const {
  return _internal_has_account_resource();
}
inline void Account::clear_account_resource() {
  if (GetArenaForAllocation() == nullptr && account_resource_ != nullptr) {
    delete account_resource_;
  }
  account_resource_ = nullptr;
}
inline const ::protocol::Account_AccountResource& Account::_internal_account_resource() const {
  const ::protocol::Account_AccountResource* p = account_resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Account_AccountResource&>(
      ::protocol::_Account_AccountResource_default_instance_);
}
inline const ::protocol::Account_AccountResource& Account::account_resource() const {
  // @@protoc_insertion_point(field_get:protocol.Account.account_resource)
  return _internal_account_resource();
}
inline void Account::unsafe_arena_set_allocated_account_resource(
    ::protocol::Account_AccountResource* account_resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_resource_);
  }
  account_resource_ = account_resource;
  if (account_resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Account.account_resource)
}
inline ::protocol::Account_AccountResource* Account::release_account_resource() {
  
  ::protocol::Account_AccountResource* temp = account_resource_;
  account_resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Account_AccountResource* Account::unsafe_arena_release_account_resource() {
  // @@protoc_insertion_point(field_release:protocol.Account.account_resource)
  
  ::protocol::Account_AccountResource* temp = account_resource_;
  account_resource_ = nullptr;
  return temp;
}
inline ::protocol::Account_AccountResource* Account::_internal_mutable_account_resource() {
  
  if (account_resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Account_AccountResource>(GetArenaForAllocation());
    account_resource_ = p;
  }
  return account_resource_;
}
inline ::protocol::Account_AccountResource* Account::mutable_account_resource() {
  ::protocol::Account_AccountResource* _msg = _internal_mutable_account_resource();
  // @@protoc_insertion_point(field_mutable:protocol.Account.account_resource)
  return _msg;
}
inline void Account::set_allocated_account_resource(::protocol::Account_AccountResource* account_resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete account_resource_;
  }
  if (account_resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Account_AccountResource>::GetOwningArena(account_resource);
    if (message_arena != submessage_arena) {
      account_resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_resource, submessage_arena);
    }
    
  } else {
    
  }
  account_resource_ = account_resource;
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.account_resource)
}

// bytes codeHash = 30;
inline void Account::clear_codehash() {
  codehash_.ClearToEmpty();
}
inline const std::string& Account::codehash() const {
  // @@protoc_insertion_point(field_get:protocol.Account.codeHash)
  return _internal_codehash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Account::set_codehash(ArgT0&& arg0, ArgT... args) {
 
 codehash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Account.codeHash)
}
inline std::string* Account::mutable_codehash() {
  std::string* _s = _internal_mutable_codehash();
  // @@protoc_insertion_point(field_mutable:protocol.Account.codeHash)
  return _s;
}
inline const std::string& Account::_internal_codehash() const {
  return codehash_.Get();
}
inline void Account::_internal_set_codehash(const std::string& value) {
  
  codehash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Account::_internal_mutable_codehash() {
  
  return codehash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Account::release_codehash() {
  // @@protoc_insertion_point(field_release:protocol.Account.codeHash)
  return codehash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Account::set_allocated_codehash(std::string* codehash) {
  if (codehash != nullptr) {
    
  } else {
    
  }
  codehash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), codehash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (codehash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    codehash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.codeHash)
}

// .protocol.Permission owner_permission = 31;
inline bool Account::_internal_has_owner_permission() const {
  return this != internal_default_instance() && owner_permission_ != nullptr;
}
inline bool Account::has_owner_permission() const {
  return _internal_has_owner_permission();
}
inline void Account::clear_owner_permission() {
  if (GetArenaForAllocation() == nullptr && owner_permission_ != nullptr) {
    delete owner_permission_;
  }
  owner_permission_ = nullptr;
}
inline const ::protocol::Permission& Account::_internal_owner_permission() const {
  const ::protocol::Permission* p = owner_permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Permission&>(
      ::protocol::_Permission_default_instance_);
}
inline const ::protocol::Permission& Account::owner_permission() const {
  // @@protoc_insertion_point(field_get:protocol.Account.owner_permission)
  return _internal_owner_permission();
}
inline void Account::unsafe_arena_set_allocated_owner_permission(
    ::protocol::Permission* owner_permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_permission_);
  }
  owner_permission_ = owner_permission;
  if (owner_permission) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Account.owner_permission)
}
inline ::protocol::Permission* Account::release_owner_permission() {
  
  ::protocol::Permission* temp = owner_permission_;
  owner_permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Permission* Account::unsafe_arena_release_owner_permission() {
  // @@protoc_insertion_point(field_release:protocol.Account.owner_permission)
  
  ::protocol::Permission* temp = owner_permission_;
  owner_permission_ = nullptr;
  return temp;
}
inline ::protocol::Permission* Account::_internal_mutable_owner_permission() {
  
  if (owner_permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Permission>(GetArenaForAllocation());
    owner_permission_ = p;
  }
  return owner_permission_;
}
inline ::protocol::Permission* Account::mutable_owner_permission() {
  ::protocol::Permission* _msg = _internal_mutable_owner_permission();
  // @@protoc_insertion_point(field_mutable:protocol.Account.owner_permission)
  return _msg;
}
inline void Account::set_allocated_owner_permission(::protocol::Permission* owner_permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete owner_permission_;
  }
  if (owner_permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Permission>::GetOwningArena(owner_permission);
    if (message_arena != submessage_arena) {
      owner_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_permission, submessage_arena);
    }
    
  } else {
    
  }
  owner_permission_ = owner_permission;
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.owner_permission)
}

// .protocol.Permission witness_permission = 32;
inline bool Account::_internal_has_witness_permission() const {
  return this != internal_default_instance() && witness_permission_ != nullptr;
}
inline bool Account::has_witness_permission() const {
  return _internal_has_witness_permission();
}
inline void Account::clear_witness_permission() {
  if (GetArenaForAllocation() == nullptr && witness_permission_ != nullptr) {
    delete witness_permission_;
  }
  witness_permission_ = nullptr;
}
inline const ::protocol::Permission& Account::_internal_witness_permission() const {
  const ::protocol::Permission* p = witness_permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Permission&>(
      ::protocol::_Permission_default_instance_);
}
inline const ::protocol::Permission& Account::witness_permission() const {
  // @@protoc_insertion_point(field_get:protocol.Account.witness_permission)
  return _internal_witness_permission();
}
inline void Account::unsafe_arena_set_allocated_witness_permission(
    ::protocol::Permission* witness_permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(witness_permission_);
  }
  witness_permission_ = witness_permission;
  if (witness_permission) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Account.witness_permission)
}
inline ::protocol::Permission* Account::release_witness_permission() {
  
  ::protocol::Permission* temp = witness_permission_;
  witness_permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Permission* Account::unsafe_arena_release_witness_permission() {
  // @@protoc_insertion_point(field_release:protocol.Account.witness_permission)
  
  ::protocol::Permission* temp = witness_permission_;
  witness_permission_ = nullptr;
  return temp;
}
inline ::protocol::Permission* Account::_internal_mutable_witness_permission() {
  
  if (witness_permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Permission>(GetArenaForAllocation());
    witness_permission_ = p;
  }
  return witness_permission_;
}
inline ::protocol::Permission* Account::mutable_witness_permission() {
  ::protocol::Permission* _msg = _internal_mutable_witness_permission();
  // @@protoc_insertion_point(field_mutable:protocol.Account.witness_permission)
  return _msg;
}
inline void Account::set_allocated_witness_permission(::protocol::Permission* witness_permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete witness_permission_;
  }
  if (witness_permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Permission>::GetOwningArena(witness_permission);
    if (message_arena != submessage_arena) {
      witness_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, witness_permission, submessage_arena);
    }
    
  } else {
    
  }
  witness_permission_ = witness_permission;
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.witness_permission)
}

// repeated .protocol.Permission active_permission = 33;
inline int Account::_internal_active_permission_size() const {
  return active_permission_.size();
}
inline int Account::active_permission_size() const {
  return _internal_active_permission_size();
}
inline void Account::clear_active_permission() {
  active_permission_.Clear();
}
inline ::protocol::Permission* Account::mutable_active_permission(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Account.active_permission)
  return active_permission_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Permission >*
Account::mutable_active_permission() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Account.active_permission)
  return &active_permission_;
}
inline const ::protocol::Permission& Account::_internal_active_permission(int index) const {
  return active_permission_.Get(index);
}
inline const ::protocol::Permission& Account::active_permission(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Account.active_permission)
  return _internal_active_permission(index);
}
inline ::protocol::Permission* Account::_internal_add_active_permission() {
  return active_permission_.Add();
}
inline ::protocol::Permission* Account::add_active_permission() {
  ::protocol::Permission* _add = _internal_add_active_permission();
  // @@protoc_insertion_point(field_add:protocol.Account.active_permission)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Permission >&
Account::active_permission() const {
  // @@protoc_insertion_point(field_list:protocol.Account.active_permission)
  return active_permission_;
}

// -------------------------------------------------------------------

// AccountAsset_Frozen

// int64 frozen_balance = 1;
inline void AccountAsset_Frozen::clear_frozen_balance() {
  frozen_balance_ = int64_t{0};
}
inline int64_t AccountAsset_Frozen::_internal_frozen_balance() const {
  return frozen_balance_;
}
inline int64_t AccountAsset_Frozen::frozen_balance() const {
  // @@protoc_insertion_point(field_get:protocol.AccountAsset.Frozen.frozen_balance)
  return _internal_frozen_balance();
}
inline void AccountAsset_Frozen::_internal_set_frozen_balance(int64_t value) {
  
  frozen_balance_ = value;
}
inline void AccountAsset_Frozen::set_frozen_balance(int64_t value) {
  _internal_set_frozen_balance(value);
  // @@protoc_insertion_point(field_set:protocol.AccountAsset.Frozen.frozen_balance)
}

// int64 expire_time = 2;
inline void AccountAsset_Frozen::clear_expire_time() {
  expire_time_ = int64_t{0};
}
inline int64_t AccountAsset_Frozen::_internal_expire_time() const {
  return expire_time_;
}
inline int64_t AccountAsset_Frozen::expire_time() const {
  // @@protoc_insertion_point(field_get:protocol.AccountAsset.Frozen.expire_time)
  return _internal_expire_time();
}
inline void AccountAsset_Frozen::_internal_set_expire_time(int64_t value) {
  
  expire_time_ = value;
}
inline void AccountAsset_Frozen::set_expire_time(int64_t value) {
  _internal_set_expire_time(value);
  // @@protoc_insertion_point(field_set:protocol.AccountAsset.Frozen.expire_time)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AccountAsset

// bytes address = 1;
inline void AccountAsset::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& AccountAsset::address() const {
  // @@protoc_insertion_point(field_get:protocol.AccountAsset.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountAsset::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AccountAsset.address)
}
inline std::string* AccountAsset::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.AccountAsset.address)
  return _s;
}
inline const std::string& AccountAsset::_internal_address() const {
  return address_.Get();
}
inline void AccountAsset::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountAsset::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountAsset::release_address() {
  // @@protoc_insertion_point(field_release:protocol.AccountAsset.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountAsset::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountAsset.address)
}

// map<string, int64> asset = 2;
inline int AccountAsset::_internal_asset_size() const {
  return asset_.size();
}
inline int AccountAsset::asset_size() const {
  return _internal_asset_size();
}
inline void AccountAsset::clear_asset() {
  asset_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AccountAsset::_internal_asset() const {
  return asset_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AccountAsset::asset() const {
  // @@protoc_insertion_point(field_map:protocol.AccountAsset.asset)
  return _internal_asset();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AccountAsset::_internal_mutable_asset() {
  return asset_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AccountAsset::mutable_asset() {
  // @@protoc_insertion_point(field_mutable_map:protocol.AccountAsset.asset)
  return _internal_mutable_asset();
}

// map<string, int64> assetV2 = 3;
inline int AccountAsset::_internal_assetv2_size() const {
  return assetv2_.size();
}
inline int AccountAsset::assetv2_size() const {
  return _internal_assetv2_size();
}
inline void AccountAsset::clear_assetv2() {
  assetv2_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AccountAsset::_internal_assetv2() const {
  return assetv2_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AccountAsset::assetv2() const {
  // @@protoc_insertion_point(field_map:protocol.AccountAsset.assetV2)
  return _internal_assetv2();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AccountAsset::_internal_mutable_assetv2() {
  return assetv2_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AccountAsset::mutable_assetv2() {
  // @@protoc_insertion_point(field_mutable_map:protocol.AccountAsset.assetV2)
  return _internal_mutable_assetv2();
}

// bytes asset_issued_name = 4;
inline void AccountAsset::clear_asset_issued_name() {
  asset_issued_name_.ClearToEmpty();
}
inline const std::string& AccountAsset::asset_issued_name() const {
  // @@protoc_insertion_point(field_get:protocol.AccountAsset.asset_issued_name)
  return _internal_asset_issued_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountAsset::set_asset_issued_name(ArgT0&& arg0, ArgT... args) {
 
 asset_issued_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AccountAsset.asset_issued_name)
}
inline std::string* AccountAsset::mutable_asset_issued_name() {
  std::string* _s = _internal_mutable_asset_issued_name();
  // @@protoc_insertion_point(field_mutable:protocol.AccountAsset.asset_issued_name)
  return _s;
}
inline const std::string& AccountAsset::_internal_asset_issued_name() const {
  return asset_issued_name_.Get();
}
inline void AccountAsset::_internal_set_asset_issued_name(const std::string& value) {
  
  asset_issued_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountAsset::_internal_mutable_asset_issued_name() {
  
  return asset_issued_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountAsset::release_asset_issued_name() {
  // @@protoc_insertion_point(field_release:protocol.AccountAsset.asset_issued_name)
  return asset_issued_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountAsset::set_allocated_asset_issued_name(std::string* asset_issued_name) {
  if (asset_issued_name != nullptr) {
    
  } else {
    
  }
  asset_issued_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), asset_issued_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (asset_issued_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    asset_issued_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountAsset.asset_issued_name)
}

// bytes asset_issued_ID = 5;
inline void AccountAsset::clear_asset_issued_id() {
  asset_issued_id_.ClearToEmpty();
}
inline const std::string& AccountAsset::asset_issued_id() const {
  // @@protoc_insertion_point(field_get:protocol.AccountAsset.asset_issued_ID)
  return _internal_asset_issued_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountAsset::set_asset_issued_id(ArgT0&& arg0, ArgT... args) {
 
 asset_issued_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.AccountAsset.asset_issued_ID)
}
inline std::string* AccountAsset::mutable_asset_issued_id() {
  std::string* _s = _internal_mutable_asset_issued_id();
  // @@protoc_insertion_point(field_mutable:protocol.AccountAsset.asset_issued_ID)
  return _s;
}
inline const std::string& AccountAsset::_internal_asset_issued_id() const {
  return asset_issued_id_.Get();
}
inline void AccountAsset::_internal_set_asset_issued_id(const std::string& value) {
  
  asset_issued_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountAsset::_internal_mutable_asset_issued_id() {
  
  return asset_issued_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountAsset::release_asset_issued_id() {
  // @@protoc_insertion_point(field_release:protocol.AccountAsset.asset_issued_ID)
  return asset_issued_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountAsset::set_allocated_asset_issued_id(std::string* asset_issued_id) {
  if (asset_issued_id != nullptr) {
    
  } else {
    
  }
  asset_issued_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), asset_issued_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (asset_issued_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    asset_issued_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.AccountAsset.asset_issued_ID)
}

// map<string, int64> latest_asset_operation_time = 6;
inline int AccountAsset::_internal_latest_asset_operation_time_size() const {
  return latest_asset_operation_time_.size();
}
inline int AccountAsset::latest_asset_operation_time_size() const {
  return _internal_latest_asset_operation_time_size();
}
inline void AccountAsset::clear_latest_asset_operation_time() {
  latest_asset_operation_time_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AccountAsset::_internal_latest_asset_operation_time() const {
  return latest_asset_operation_time_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AccountAsset::latest_asset_operation_time() const {
  // @@protoc_insertion_point(field_map:protocol.AccountAsset.latest_asset_operation_time)
  return _internal_latest_asset_operation_time();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AccountAsset::_internal_mutable_latest_asset_operation_time() {
  return latest_asset_operation_time_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AccountAsset::mutable_latest_asset_operation_time() {
  // @@protoc_insertion_point(field_mutable_map:protocol.AccountAsset.latest_asset_operation_time)
  return _internal_mutable_latest_asset_operation_time();
}

// map<string, int64> latest_asset_operation_timeV2 = 7;
inline int AccountAsset::_internal_latest_asset_operation_timev2_size() const {
  return latest_asset_operation_timev2_.size();
}
inline int AccountAsset::latest_asset_operation_timev2_size() const {
  return _internal_latest_asset_operation_timev2_size();
}
inline void AccountAsset::clear_latest_asset_operation_timev2() {
  latest_asset_operation_timev2_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AccountAsset::_internal_latest_asset_operation_timev2() const {
  return latest_asset_operation_timev2_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AccountAsset::latest_asset_operation_timev2() const {
  // @@protoc_insertion_point(field_map:protocol.AccountAsset.latest_asset_operation_timeV2)
  return _internal_latest_asset_operation_timev2();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AccountAsset::_internal_mutable_latest_asset_operation_timev2() {
  return latest_asset_operation_timev2_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AccountAsset::mutable_latest_asset_operation_timev2() {
  // @@protoc_insertion_point(field_mutable_map:protocol.AccountAsset.latest_asset_operation_timeV2)
  return _internal_mutable_latest_asset_operation_timev2();
}

// map<string, int64> free_asset_net_usage = 8;
inline int AccountAsset::_internal_free_asset_net_usage_size() const {
  return free_asset_net_usage_.size();
}
inline int AccountAsset::free_asset_net_usage_size() const {
  return _internal_free_asset_net_usage_size();
}
inline void AccountAsset::clear_free_asset_net_usage() {
  free_asset_net_usage_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AccountAsset::_internal_free_asset_net_usage() const {
  return free_asset_net_usage_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AccountAsset::free_asset_net_usage() const {
  // @@protoc_insertion_point(field_map:protocol.AccountAsset.free_asset_net_usage)
  return _internal_free_asset_net_usage();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AccountAsset::_internal_mutable_free_asset_net_usage() {
  return free_asset_net_usage_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AccountAsset::mutable_free_asset_net_usage() {
  // @@protoc_insertion_point(field_mutable_map:protocol.AccountAsset.free_asset_net_usage)
  return _internal_mutable_free_asset_net_usage();
}

// map<string, int64> free_asset_net_usageV2 = 9;
inline int AccountAsset::_internal_free_asset_net_usagev2_size() const {
  return free_asset_net_usagev2_.size();
}
inline int AccountAsset::free_asset_net_usagev2_size() const {
  return _internal_free_asset_net_usagev2_size();
}
inline void AccountAsset::clear_free_asset_net_usagev2() {
  free_asset_net_usagev2_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AccountAsset::_internal_free_asset_net_usagev2() const {
  return free_asset_net_usagev2_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AccountAsset::free_asset_net_usagev2() const {
  // @@protoc_insertion_point(field_map:protocol.AccountAsset.free_asset_net_usageV2)
  return _internal_free_asset_net_usagev2();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AccountAsset::_internal_mutable_free_asset_net_usagev2() {
  return free_asset_net_usagev2_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AccountAsset::mutable_free_asset_net_usagev2() {
  // @@protoc_insertion_point(field_mutable_map:protocol.AccountAsset.free_asset_net_usageV2)
  return _internal_mutable_free_asset_net_usagev2();
}

// repeated .protocol.AccountAsset.Frozen frozen_supply = 10;
inline int AccountAsset::_internal_frozen_supply_size() const {
  return frozen_supply_.size();
}
inline int AccountAsset::frozen_supply_size() const {
  return _internal_frozen_supply_size();
}
inline void AccountAsset::clear_frozen_supply() {
  frozen_supply_.Clear();
}
inline ::protocol::AccountAsset_Frozen* AccountAsset::mutable_frozen_supply(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.AccountAsset.frozen_supply)
  return frozen_supply_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AccountAsset_Frozen >*
AccountAsset::mutable_frozen_supply() {
  // @@protoc_insertion_point(field_mutable_list:protocol.AccountAsset.frozen_supply)
  return &frozen_supply_;
}
inline const ::protocol::AccountAsset_Frozen& AccountAsset::_internal_frozen_supply(int index) const {
  return frozen_supply_.Get(index);
}
inline const ::protocol::AccountAsset_Frozen& AccountAsset::frozen_supply(int index) const {
  // @@protoc_insertion_point(field_get:protocol.AccountAsset.frozen_supply)
  return _internal_frozen_supply(index);
}
inline ::protocol::AccountAsset_Frozen* AccountAsset::_internal_add_frozen_supply() {
  return frozen_supply_.Add();
}
inline ::protocol::AccountAsset_Frozen* AccountAsset::add_frozen_supply() {
  ::protocol::AccountAsset_Frozen* _add = _internal_add_frozen_supply();
  // @@protoc_insertion_point(field_add:protocol.AccountAsset.frozen_supply)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::AccountAsset_Frozen >&
AccountAsset::frozen_supply() const {
  // @@protoc_insertion_point(field_list:protocol.AccountAsset.frozen_supply)
  return frozen_supply_;
}

// -------------------------------------------------------------------

// Key

// bytes address = 1;
inline void Key::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& Key::address() const {
  // @@protoc_insertion_point(field_get:protocol.Key.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Key::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Key.address)
}
inline std::string* Key::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.Key.address)
  return _s;
}
inline const std::string& Key::_internal_address() const {
  return address_.Get();
}
inline void Key::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Key::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Key::release_address() {
  // @@protoc_insertion_point(field_release:protocol.Key.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Key::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Key.address)
}

// int64 weight = 2;
inline void Key::clear_weight() {
  weight_ = int64_t{0};
}
inline int64_t Key::_internal_weight() const {
  return weight_;
}
inline int64_t Key::weight() const {
  // @@protoc_insertion_point(field_get:protocol.Key.weight)
  return _internal_weight();
}
inline void Key::_internal_set_weight(int64_t value) {
  
  weight_ = value;
}
inline void Key::set_weight(int64_t value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:protocol.Key.weight)
}

// -------------------------------------------------------------------

// DelegatedResource

// bytes from = 1;
inline void DelegatedResource::clear_from() {
  from_.ClearToEmpty();
}
inline const std::string& DelegatedResource::from() const {
  // @@protoc_insertion_point(field_get:protocol.DelegatedResource.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegatedResource::set_from(ArgT0&& arg0, ArgT... args) {
 
 from_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.DelegatedResource.from)
}
inline std::string* DelegatedResource::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:protocol.DelegatedResource.from)
  return _s;
}
inline const std::string& DelegatedResource::_internal_from() const {
  return from_.Get();
}
inline void DelegatedResource::_internal_set_from(const std::string& value) {
  
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DelegatedResource::_internal_mutable_from() {
  
  return from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DelegatedResource::release_from() {
  // @@protoc_insertion_point(field_release:protocol.DelegatedResource.from)
  return from_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DelegatedResource::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.DelegatedResource.from)
}

// bytes to = 2;
inline void DelegatedResource::clear_to() {
  to_.ClearToEmpty();
}
inline const std::string& DelegatedResource::to() const {
  // @@protoc_insertion_point(field_get:protocol.DelegatedResource.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegatedResource::set_to(ArgT0&& arg0, ArgT... args) {
 
 to_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.DelegatedResource.to)
}
inline std::string* DelegatedResource::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:protocol.DelegatedResource.to)
  return _s;
}
inline const std::string& DelegatedResource::_internal_to() const {
  return to_.Get();
}
inline void DelegatedResource::_internal_set_to(const std::string& value) {
  
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DelegatedResource::_internal_mutable_to() {
  
  return to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DelegatedResource::release_to() {
  // @@protoc_insertion_point(field_release:protocol.DelegatedResource.to)
  return to_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DelegatedResource::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.DelegatedResource.to)
}

// int64 frozen_balance_for_bandwidth = 3;
inline void DelegatedResource::clear_frozen_balance_for_bandwidth() {
  frozen_balance_for_bandwidth_ = int64_t{0};
}
inline int64_t DelegatedResource::_internal_frozen_balance_for_bandwidth() const {
  return frozen_balance_for_bandwidth_;
}
inline int64_t DelegatedResource::frozen_balance_for_bandwidth() const {
  // @@protoc_insertion_point(field_get:protocol.DelegatedResource.frozen_balance_for_bandwidth)
  return _internal_frozen_balance_for_bandwidth();
}
inline void DelegatedResource::_internal_set_frozen_balance_for_bandwidth(int64_t value) {
  
  frozen_balance_for_bandwidth_ = value;
}
inline void DelegatedResource::set_frozen_balance_for_bandwidth(int64_t value) {
  _internal_set_frozen_balance_for_bandwidth(value);
  // @@protoc_insertion_point(field_set:protocol.DelegatedResource.frozen_balance_for_bandwidth)
}

// int64 frozen_balance_for_energy = 4;
inline void DelegatedResource::clear_frozen_balance_for_energy() {
  frozen_balance_for_energy_ = int64_t{0};
}
inline int64_t DelegatedResource::_internal_frozen_balance_for_energy() const {
  return frozen_balance_for_energy_;
}
inline int64_t DelegatedResource::frozen_balance_for_energy() const {
  // @@protoc_insertion_point(field_get:protocol.DelegatedResource.frozen_balance_for_energy)
  return _internal_frozen_balance_for_energy();
}
inline void DelegatedResource::_internal_set_frozen_balance_for_energy(int64_t value) {
  
  frozen_balance_for_energy_ = value;
}
inline void DelegatedResource::set_frozen_balance_for_energy(int64_t value) {
  _internal_set_frozen_balance_for_energy(value);
  // @@protoc_insertion_point(field_set:protocol.DelegatedResource.frozen_balance_for_energy)
}

// int64 expire_time_for_bandwidth = 5;
inline void DelegatedResource::clear_expire_time_for_bandwidth() {
  expire_time_for_bandwidth_ = int64_t{0};
}
inline int64_t DelegatedResource::_internal_expire_time_for_bandwidth() const {
  return expire_time_for_bandwidth_;
}
inline int64_t DelegatedResource::expire_time_for_bandwidth() const {
  // @@protoc_insertion_point(field_get:protocol.DelegatedResource.expire_time_for_bandwidth)
  return _internal_expire_time_for_bandwidth();
}
inline void DelegatedResource::_internal_set_expire_time_for_bandwidth(int64_t value) {
  
  expire_time_for_bandwidth_ = value;
}
inline void DelegatedResource::set_expire_time_for_bandwidth(int64_t value) {
  _internal_set_expire_time_for_bandwidth(value);
  // @@protoc_insertion_point(field_set:protocol.DelegatedResource.expire_time_for_bandwidth)
}

// int64 expire_time_for_energy = 6;
inline void DelegatedResource::clear_expire_time_for_energy() {
  expire_time_for_energy_ = int64_t{0};
}
inline int64_t DelegatedResource::_internal_expire_time_for_energy() const {
  return expire_time_for_energy_;
}
inline int64_t DelegatedResource::expire_time_for_energy() const {
  // @@protoc_insertion_point(field_get:protocol.DelegatedResource.expire_time_for_energy)
  return _internal_expire_time_for_energy();
}
inline void DelegatedResource::_internal_set_expire_time_for_energy(int64_t value) {
  
  expire_time_for_energy_ = value;
}
inline void DelegatedResource::set_expire_time_for_energy(int64_t value) {
  _internal_set_expire_time_for_energy(value);
  // @@protoc_insertion_point(field_set:protocol.DelegatedResource.expire_time_for_energy)
}

// -------------------------------------------------------------------

// authority

// .protocol.AccountId account = 1;
inline bool authority::_internal_has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline bool authority::has_account() const {
  return _internal_has_account();
}
inline void authority::clear_account() {
  if (GetArenaForAllocation() == nullptr && account_ != nullptr) {
    delete account_;
  }
  account_ = nullptr;
}
inline const ::protocol::AccountId& authority::_internal_account() const {
  const ::protocol::AccountId* p = account_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::AccountId&>(
      ::protocol::_AccountId_default_instance_);
}
inline const ::protocol::AccountId& authority::account() const {
  // @@protoc_insertion_point(field_get:protocol.authority.account)
  return _internal_account();
}
inline void authority::unsafe_arena_set_allocated_account(
    ::protocol::AccountId* account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.authority.account)
}
inline ::protocol::AccountId* authority::release_account() {
  
  ::protocol::AccountId* temp = account_;
  account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::AccountId* authority::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:protocol.authority.account)
  
  ::protocol::AccountId* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::protocol::AccountId* authority::_internal_mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::AccountId>(GetArenaForAllocation());
    account_ = p;
  }
  return account_;
}
inline ::protocol::AccountId* authority::mutable_account() {
  ::protocol::AccountId* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:protocol.authority.account)
  return _msg;
}
inline void authority::set_allocated_account(::protocol::AccountId* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete account_;
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::AccountId>::GetOwningArena(account);
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:protocol.authority.account)
}

// bytes permission_name = 2;
inline void authority::clear_permission_name() {
  permission_name_.ClearToEmpty();
}
inline const std::string& authority::permission_name() const {
  // @@protoc_insertion_point(field_get:protocol.authority.permission_name)
  return _internal_permission_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void authority::set_permission_name(ArgT0&& arg0, ArgT... args) {
 
 permission_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.authority.permission_name)
}
inline std::string* authority::mutable_permission_name() {
  std::string* _s = _internal_mutable_permission_name();
  // @@protoc_insertion_point(field_mutable:protocol.authority.permission_name)
  return _s;
}
inline const std::string& authority::_internal_permission_name() const {
  return permission_name_.Get();
}
inline void authority::_internal_set_permission_name(const std::string& value) {
  
  permission_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* authority::_internal_mutable_permission_name() {
  
  return permission_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* authority::release_permission_name() {
  // @@protoc_insertion_point(field_release:protocol.authority.permission_name)
  return permission_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void authority::set_allocated_permission_name(std::string* permission_name) {
  if (permission_name != nullptr) {
    
  } else {
    
  }
  permission_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), permission_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (permission_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    permission_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.authority.permission_name)
}

// -------------------------------------------------------------------

// Permission

// .protocol.Permission.PermissionType type = 1;
inline void Permission::clear_type() {
  type_ = 0;
}
inline ::protocol::Permission_PermissionType Permission::_internal_type() const {
  return static_cast< ::protocol::Permission_PermissionType >(type_);
}
inline ::protocol::Permission_PermissionType Permission::type() const {
  // @@protoc_insertion_point(field_get:protocol.Permission.type)
  return _internal_type();
}
inline void Permission::_internal_set_type(::protocol::Permission_PermissionType value) {
  
  type_ = value;
}
inline void Permission::set_type(::protocol::Permission_PermissionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.Permission.type)
}

// int32 id = 2;
inline void Permission::clear_id() {
  id_ = 0;
}
inline int32_t Permission::_internal_id() const {
  return id_;
}
inline int32_t Permission::id() const {
  // @@protoc_insertion_point(field_get:protocol.Permission.id)
  return _internal_id();
}
inline void Permission::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void Permission::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:protocol.Permission.id)
}

// string permission_name = 3;
inline void Permission::clear_permission_name() {
  permission_name_.ClearToEmpty();
}
inline const std::string& Permission::permission_name() const {
  // @@protoc_insertion_point(field_get:protocol.Permission.permission_name)
  return _internal_permission_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Permission::set_permission_name(ArgT0&& arg0, ArgT... args) {
 
 permission_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Permission.permission_name)
}
inline std::string* Permission::mutable_permission_name() {
  std::string* _s = _internal_mutable_permission_name();
  // @@protoc_insertion_point(field_mutable:protocol.Permission.permission_name)
  return _s;
}
inline const std::string& Permission::_internal_permission_name() const {
  return permission_name_.Get();
}
inline void Permission::_internal_set_permission_name(const std::string& value) {
  
  permission_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Permission::_internal_mutable_permission_name() {
  
  return permission_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Permission::release_permission_name() {
  // @@protoc_insertion_point(field_release:protocol.Permission.permission_name)
  return permission_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Permission::set_allocated_permission_name(std::string* permission_name) {
  if (permission_name != nullptr) {
    
  } else {
    
  }
  permission_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), permission_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (permission_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    permission_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Permission.permission_name)
}

// int64 threshold = 4;
inline void Permission::clear_threshold() {
  threshold_ = int64_t{0};
}
inline int64_t Permission::_internal_threshold() const {
  return threshold_;
}
inline int64_t Permission::threshold() const {
  // @@protoc_insertion_point(field_get:protocol.Permission.threshold)
  return _internal_threshold();
}
inline void Permission::_internal_set_threshold(int64_t value) {
  
  threshold_ = value;
}
inline void Permission::set_threshold(int64_t value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:protocol.Permission.threshold)
}

// int32 parent_id = 5;
inline void Permission::clear_parent_id() {
  parent_id_ = 0;
}
inline int32_t Permission::_internal_parent_id() const {
  return parent_id_;
}
inline int32_t Permission::parent_id() const {
  // @@protoc_insertion_point(field_get:protocol.Permission.parent_id)
  return _internal_parent_id();
}
inline void Permission::_internal_set_parent_id(int32_t value) {
  
  parent_id_ = value;
}
inline void Permission::set_parent_id(int32_t value) {
  _internal_set_parent_id(value);
  // @@protoc_insertion_point(field_set:protocol.Permission.parent_id)
}

// bytes operations = 6;
inline void Permission::clear_operations() {
  operations_.ClearToEmpty();
}
inline const std::string& Permission::operations() const {
  // @@protoc_insertion_point(field_get:protocol.Permission.operations)
  return _internal_operations();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Permission::set_operations(ArgT0&& arg0, ArgT... args) {
 
 operations_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Permission.operations)
}
inline std::string* Permission::mutable_operations() {
  std::string* _s = _internal_mutable_operations();
  // @@protoc_insertion_point(field_mutable:protocol.Permission.operations)
  return _s;
}
inline const std::string& Permission::_internal_operations() const {
  return operations_.Get();
}
inline void Permission::_internal_set_operations(const std::string& value) {
  
  operations_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Permission::_internal_mutable_operations() {
  
  return operations_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Permission::release_operations() {
  // @@protoc_insertion_point(field_release:protocol.Permission.operations)
  return operations_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Permission::set_allocated_operations(std::string* operations) {
  if (operations != nullptr) {
    
  } else {
    
  }
  operations_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operations,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operations_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operations_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Permission.operations)
}

// repeated .protocol.Key keys = 7;
inline int Permission::_internal_keys_size() const {
  return keys_.size();
}
inline int Permission::keys_size() const {
  return _internal_keys_size();
}
inline void Permission::clear_keys() {
  keys_.Clear();
}
inline ::protocol::Key* Permission::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Permission.keys)
  return keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Key >*
Permission::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Permission.keys)
  return &keys_;
}
inline const ::protocol::Key& Permission::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const ::protocol::Key& Permission::keys(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Permission.keys)
  return _internal_keys(index);
}
inline ::protocol::Key* Permission::_internal_add_keys() {
  return keys_.Add();
}
inline ::protocol::Key* Permission::add_keys() {
  ::protocol::Key* _add = _internal_add_keys();
  // @@protoc_insertion_point(field_add:protocol.Permission.keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Key >&
Permission::keys() const {
  // @@protoc_insertion_point(field_list:protocol.Permission.keys)
  return keys_;
}

// -------------------------------------------------------------------

// Witness

// bytes address = 1;
inline void Witness::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& Witness::address() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Witness::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Witness.address)
}
inline std::string* Witness::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.Witness.address)
  return _s;
}
inline const std::string& Witness::_internal_address() const {
  return address_.Get();
}
inline void Witness::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Witness::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Witness::release_address() {
  // @@protoc_insertion_point(field_release:protocol.Witness.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Witness::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Witness.address)
}

// int64 voteCount = 2;
inline void Witness::clear_votecount() {
  votecount_ = int64_t{0};
}
inline int64_t Witness::_internal_votecount() const {
  return votecount_;
}
inline int64_t Witness::votecount() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.voteCount)
  return _internal_votecount();
}
inline void Witness::_internal_set_votecount(int64_t value) {
  
  votecount_ = value;
}
inline void Witness::set_votecount(int64_t value) {
  _internal_set_votecount(value);
  // @@protoc_insertion_point(field_set:protocol.Witness.voteCount)
}

// bytes pubKey = 3;
inline void Witness::clear_pubkey() {
  pubkey_.ClearToEmpty();
}
inline const std::string& Witness::pubkey() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.pubKey)
  return _internal_pubkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Witness::set_pubkey(ArgT0&& arg0, ArgT... args) {
 
 pubkey_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Witness.pubKey)
}
inline std::string* Witness::mutable_pubkey() {
  std::string* _s = _internal_mutable_pubkey();
  // @@protoc_insertion_point(field_mutable:protocol.Witness.pubKey)
  return _s;
}
inline const std::string& Witness::_internal_pubkey() const {
  return pubkey_.Get();
}
inline void Witness::_internal_set_pubkey(const std::string& value) {
  
  pubkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Witness::_internal_mutable_pubkey() {
  
  return pubkey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Witness::release_pubkey() {
  // @@protoc_insertion_point(field_release:protocol.Witness.pubKey)
  return pubkey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Witness::set_allocated_pubkey(std::string* pubkey) {
  if (pubkey != nullptr) {
    
  } else {
    
  }
  pubkey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pubkey,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubkey_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Witness.pubKey)
}

// string url = 4;
inline void Witness::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& Witness::url() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Witness::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Witness.url)
}
inline std::string* Witness::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:protocol.Witness.url)
  return _s;
}
inline const std::string& Witness::_internal_url() const {
  return url_.Get();
}
inline void Witness::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Witness::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Witness::release_url() {
  // @@protoc_insertion_point(field_release:protocol.Witness.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Witness::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Witness.url)
}

// int64 totalProduced = 5;
inline void Witness::clear_totalproduced() {
  totalproduced_ = int64_t{0};
}
inline int64_t Witness::_internal_totalproduced() const {
  return totalproduced_;
}
inline int64_t Witness::totalproduced() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.totalProduced)
  return _internal_totalproduced();
}
inline void Witness::_internal_set_totalproduced(int64_t value) {
  
  totalproduced_ = value;
}
inline void Witness::set_totalproduced(int64_t value) {
  _internal_set_totalproduced(value);
  // @@protoc_insertion_point(field_set:protocol.Witness.totalProduced)
}

// int64 totalMissed = 6;
inline void Witness::clear_totalmissed() {
  totalmissed_ = int64_t{0};
}
inline int64_t Witness::_internal_totalmissed() const {
  return totalmissed_;
}
inline int64_t Witness::totalmissed() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.totalMissed)
  return _internal_totalmissed();
}
inline void Witness::_internal_set_totalmissed(int64_t value) {
  
  totalmissed_ = value;
}
inline void Witness::set_totalmissed(int64_t value) {
  _internal_set_totalmissed(value);
  // @@protoc_insertion_point(field_set:protocol.Witness.totalMissed)
}

// int64 latestBlockNum = 7;
inline void Witness::clear_latestblocknum() {
  latestblocknum_ = int64_t{0};
}
inline int64_t Witness::_internal_latestblocknum() const {
  return latestblocknum_;
}
inline int64_t Witness::latestblocknum() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.latestBlockNum)
  return _internal_latestblocknum();
}
inline void Witness::_internal_set_latestblocknum(int64_t value) {
  
  latestblocknum_ = value;
}
inline void Witness::set_latestblocknum(int64_t value) {
  _internal_set_latestblocknum(value);
  // @@protoc_insertion_point(field_set:protocol.Witness.latestBlockNum)
}

// int64 latestSlotNum = 8;
inline void Witness::clear_latestslotnum() {
  latestslotnum_ = int64_t{0};
}
inline int64_t Witness::_internal_latestslotnum() const {
  return latestslotnum_;
}
inline int64_t Witness::latestslotnum() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.latestSlotNum)
  return _internal_latestslotnum();
}
inline void Witness::_internal_set_latestslotnum(int64_t value) {
  
  latestslotnum_ = value;
}
inline void Witness::set_latestslotnum(int64_t value) {
  _internal_set_latestslotnum(value);
  // @@protoc_insertion_point(field_set:protocol.Witness.latestSlotNum)
}

// bool isJobs = 9;
inline void Witness::clear_isjobs() {
  isjobs_ = false;
}
inline bool Witness::_internal_isjobs() const {
  return isjobs_;
}
inline bool Witness::isjobs() const {
  // @@protoc_insertion_point(field_get:protocol.Witness.isJobs)
  return _internal_isjobs();
}
inline void Witness::_internal_set_isjobs(bool value) {
  
  isjobs_ = value;
}
inline void Witness::set_isjobs(bool value) {
  _internal_set_isjobs(value);
  // @@protoc_insertion_point(field_set:protocol.Witness.isJobs)
}

// -------------------------------------------------------------------

// Votes

// bytes address = 1;
inline void Votes::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& Votes::address() const {
  // @@protoc_insertion_point(field_get:protocol.Votes.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Votes::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Votes.address)
}
inline std::string* Votes::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.Votes.address)
  return _s;
}
inline const std::string& Votes::_internal_address() const {
  return address_.Get();
}
inline void Votes::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Votes::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Votes::release_address() {
  // @@protoc_insertion_point(field_release:protocol.Votes.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Votes::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Votes.address)
}

// repeated .protocol.Vote old_votes = 2;
inline int Votes::_internal_old_votes_size() const {
  return old_votes_.size();
}
inline int Votes::old_votes_size() const {
  return _internal_old_votes_size();
}
inline void Votes::clear_old_votes() {
  old_votes_.Clear();
}
inline ::protocol::Vote* Votes::mutable_old_votes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Votes.old_votes)
  return old_votes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote >*
Votes::mutable_old_votes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Votes.old_votes)
  return &old_votes_;
}
inline const ::protocol::Vote& Votes::_internal_old_votes(int index) const {
  return old_votes_.Get(index);
}
inline const ::protocol::Vote& Votes::old_votes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Votes.old_votes)
  return _internal_old_votes(index);
}
inline ::protocol::Vote* Votes::_internal_add_old_votes() {
  return old_votes_.Add();
}
inline ::protocol::Vote* Votes::add_old_votes() {
  ::protocol::Vote* _add = _internal_add_old_votes();
  // @@protoc_insertion_point(field_add:protocol.Votes.old_votes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote >&
Votes::old_votes() const {
  // @@protoc_insertion_point(field_list:protocol.Votes.old_votes)
  return old_votes_;
}

// repeated .protocol.Vote new_votes = 3;
inline int Votes::_internal_new_votes_size() const {
  return new_votes_.size();
}
inline int Votes::new_votes_size() const {
  return _internal_new_votes_size();
}
inline void Votes::clear_new_votes() {
  new_votes_.Clear();
}
inline ::protocol::Vote* Votes::mutable_new_votes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Votes.new_votes)
  return new_votes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote >*
Votes::mutable_new_votes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Votes.new_votes)
  return &new_votes_;
}
inline const ::protocol::Vote& Votes::_internal_new_votes(int index) const {
  return new_votes_.Get(index);
}
inline const ::protocol::Vote& Votes::new_votes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Votes.new_votes)
  return _internal_new_votes(index);
}
inline ::protocol::Vote* Votes::_internal_add_new_votes() {
  return new_votes_.Add();
}
inline ::protocol::Vote* Votes::add_new_votes() {
  ::protocol::Vote* _add = _internal_add_new_votes();
  // @@protoc_insertion_point(field_add:protocol.Votes.new_votes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Vote >&
Votes::new_votes() const {
  // @@protoc_insertion_point(field_list:protocol.Votes.new_votes)
  return new_votes_;
}

// -------------------------------------------------------------------

// TXOutput

// int64 value = 1;
inline void TXOutput::clear_value() {
  value_ = int64_t{0};
}
inline int64_t TXOutput::_internal_value() const {
  return value_;
}
inline int64_t TXOutput::value() const {
  // @@protoc_insertion_point(field_get:protocol.TXOutput.value)
  return _internal_value();
}
inline void TXOutput::_internal_set_value(int64_t value) {
  
  value_ = value;
}
inline void TXOutput::set_value(int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:protocol.TXOutput.value)
}

// bytes pubKeyHash = 2;
inline void TXOutput::clear_pubkeyhash() {
  pubkeyhash_.ClearToEmpty();
}
inline const std::string& TXOutput::pubkeyhash() const {
  // @@protoc_insertion_point(field_get:protocol.TXOutput.pubKeyHash)
  return _internal_pubkeyhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TXOutput::set_pubkeyhash(ArgT0&& arg0, ArgT... args) {
 
 pubkeyhash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TXOutput.pubKeyHash)
}
inline std::string* TXOutput::mutable_pubkeyhash() {
  std::string* _s = _internal_mutable_pubkeyhash();
  // @@protoc_insertion_point(field_mutable:protocol.TXOutput.pubKeyHash)
  return _s;
}
inline const std::string& TXOutput::_internal_pubkeyhash() const {
  return pubkeyhash_.Get();
}
inline void TXOutput::_internal_set_pubkeyhash(const std::string& value) {
  
  pubkeyhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TXOutput::_internal_mutable_pubkeyhash() {
  
  return pubkeyhash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TXOutput::release_pubkeyhash() {
  // @@protoc_insertion_point(field_release:protocol.TXOutput.pubKeyHash)
  return pubkeyhash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TXOutput::set_allocated_pubkeyhash(std::string* pubkeyhash) {
  if (pubkeyhash != nullptr) {
    
  } else {
    
  }
  pubkeyhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pubkeyhash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubkeyhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pubkeyhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TXOutput.pubKeyHash)
}

// -------------------------------------------------------------------

// TXInput_raw

// bytes txID = 1;
inline void TXInput_raw::clear_txid() {
  txid_.ClearToEmpty();
}
inline const std::string& TXInput_raw::txid() const {
  // @@protoc_insertion_point(field_get:protocol.TXInput.raw.txID)
  return _internal_txid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TXInput_raw::set_txid(ArgT0&& arg0, ArgT... args) {
 
 txid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TXInput.raw.txID)
}
inline std::string* TXInput_raw::mutable_txid() {
  std::string* _s = _internal_mutable_txid();
  // @@protoc_insertion_point(field_mutable:protocol.TXInput.raw.txID)
  return _s;
}
inline const std::string& TXInput_raw::_internal_txid() const {
  return txid_.Get();
}
inline void TXInput_raw::_internal_set_txid(const std::string& value) {
  
  txid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TXInput_raw::_internal_mutable_txid() {
  
  return txid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TXInput_raw::release_txid() {
  // @@protoc_insertion_point(field_release:protocol.TXInput.raw.txID)
  return txid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TXInput_raw::set_allocated_txid(std::string* txid) {
  if (txid != nullptr) {
    
  } else {
    
  }
  txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), txid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (txid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    txid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TXInput.raw.txID)
}

// int64 vout = 2;
inline void TXInput_raw::clear_vout() {
  vout_ = int64_t{0};
}
inline int64_t TXInput_raw::_internal_vout() const {
  return vout_;
}
inline int64_t TXInput_raw::vout() const {
  // @@protoc_insertion_point(field_get:protocol.TXInput.raw.vout)
  return _internal_vout();
}
inline void TXInput_raw::_internal_set_vout(int64_t value) {
  
  vout_ = value;
}
inline void TXInput_raw::set_vout(int64_t value) {
  _internal_set_vout(value);
  // @@protoc_insertion_point(field_set:protocol.TXInput.raw.vout)
}

// bytes pubKey = 3;
inline void TXInput_raw::clear_pubkey() {
  pubkey_.ClearToEmpty();
}
inline const std::string& TXInput_raw::pubkey() const {
  // @@protoc_insertion_point(field_get:protocol.TXInput.raw.pubKey)
  return _internal_pubkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TXInput_raw::set_pubkey(ArgT0&& arg0, ArgT... args) {
 
 pubkey_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TXInput.raw.pubKey)
}
inline std::string* TXInput_raw::mutable_pubkey() {
  std::string* _s = _internal_mutable_pubkey();
  // @@protoc_insertion_point(field_mutable:protocol.TXInput.raw.pubKey)
  return _s;
}
inline const std::string& TXInput_raw::_internal_pubkey() const {
  return pubkey_.Get();
}
inline void TXInput_raw::_internal_set_pubkey(const std::string& value) {
  
  pubkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TXInput_raw::_internal_mutable_pubkey() {
  
  return pubkey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TXInput_raw::release_pubkey() {
  // @@protoc_insertion_point(field_release:protocol.TXInput.raw.pubKey)
  return pubkey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TXInput_raw::set_allocated_pubkey(std::string* pubkey) {
  if (pubkey != nullptr) {
    
  } else {
    
  }
  pubkey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pubkey,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubkey_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TXInput.raw.pubKey)
}

// -------------------------------------------------------------------

// TXInput

// .protocol.TXInput.raw raw_data = 1;
inline bool TXInput::_internal_has_raw_data() const {
  return this != internal_default_instance() && raw_data_ != nullptr;
}
inline bool TXInput::has_raw_data() const {
  return _internal_has_raw_data();
}
inline void TXInput::clear_raw_data() {
  if (GetArenaForAllocation() == nullptr && raw_data_ != nullptr) {
    delete raw_data_;
  }
  raw_data_ = nullptr;
}
inline const ::protocol::TXInput_raw& TXInput::_internal_raw_data() const {
  const ::protocol::TXInput_raw* p = raw_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::TXInput_raw&>(
      ::protocol::_TXInput_raw_default_instance_);
}
inline const ::protocol::TXInput_raw& TXInput::raw_data() const {
  // @@protoc_insertion_point(field_get:protocol.TXInput.raw_data)
  return _internal_raw_data();
}
inline void TXInput::unsafe_arena_set_allocated_raw_data(
    ::protocol::TXInput_raw* raw_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_data_);
  }
  raw_data_ = raw_data;
  if (raw_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TXInput.raw_data)
}
inline ::protocol::TXInput_raw* TXInput::release_raw_data() {
  
  ::protocol::TXInput_raw* temp = raw_data_;
  raw_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::TXInput_raw* TXInput::unsafe_arena_release_raw_data() {
  // @@protoc_insertion_point(field_release:protocol.TXInput.raw_data)
  
  ::protocol::TXInput_raw* temp = raw_data_;
  raw_data_ = nullptr;
  return temp;
}
inline ::protocol::TXInput_raw* TXInput::_internal_mutable_raw_data() {
  
  if (raw_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::TXInput_raw>(GetArenaForAllocation());
    raw_data_ = p;
  }
  return raw_data_;
}
inline ::protocol::TXInput_raw* TXInput::mutable_raw_data() {
  ::protocol::TXInput_raw* _msg = _internal_mutable_raw_data();
  // @@protoc_insertion_point(field_mutable:protocol.TXInput.raw_data)
  return _msg;
}
inline void TXInput::set_allocated_raw_data(::protocol::TXInput_raw* raw_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete raw_data_;
  }
  if (raw_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::TXInput_raw>::GetOwningArena(raw_data);
    if (message_arena != submessage_arena) {
      raw_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    
  } else {
    
  }
  raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:protocol.TXInput.raw_data)
}

// bytes signature = 4;
inline void TXInput::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& TXInput::signature() const {
  // @@protoc_insertion_point(field_get:protocol.TXInput.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TXInput::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TXInput.signature)
}
inline std::string* TXInput::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:protocol.TXInput.signature)
  return _s;
}
inline const std::string& TXInput::_internal_signature() const {
  return signature_.Get();
}
inline void TXInput::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TXInput::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TXInput::release_signature() {
  // @@protoc_insertion_point(field_release:protocol.TXInput.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TXInput::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TXInput.signature)
}

// -------------------------------------------------------------------

// TXOutputs

// repeated .protocol.TXOutput outputs = 1;
inline int TXOutputs::_internal_outputs_size() const {
  return outputs_.size();
}
inline int TXOutputs::outputs_size() const {
  return _internal_outputs_size();
}
inline void TXOutputs::clear_outputs() {
  outputs_.Clear();
}
inline ::protocol::TXOutput* TXOutputs::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TXOutputs.outputs)
  return outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TXOutput >*
TXOutputs::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TXOutputs.outputs)
  return &outputs_;
}
inline const ::protocol::TXOutput& TXOutputs::_internal_outputs(int index) const {
  return outputs_.Get(index);
}
inline const ::protocol::TXOutput& TXOutputs::outputs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TXOutputs.outputs)
  return _internal_outputs(index);
}
inline ::protocol::TXOutput* TXOutputs::_internal_add_outputs() {
  return outputs_.Add();
}
inline ::protocol::TXOutput* TXOutputs::add_outputs() {
  ::protocol::TXOutput* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:protocol.TXOutputs.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TXOutput >&
TXOutputs::outputs() const {
  // @@protoc_insertion_point(field_list:protocol.TXOutputs.outputs)
  return outputs_;
}

// -------------------------------------------------------------------

// ResourceReceipt

// int64 energy_usage = 1;
inline void ResourceReceipt::clear_energy_usage() {
  energy_usage_ = int64_t{0};
}
inline int64_t ResourceReceipt::_internal_energy_usage() const {
  return energy_usage_;
}
inline int64_t ResourceReceipt::energy_usage() const {
  // @@protoc_insertion_point(field_get:protocol.ResourceReceipt.energy_usage)
  return _internal_energy_usage();
}
inline void ResourceReceipt::_internal_set_energy_usage(int64_t value) {
  
  energy_usage_ = value;
}
inline void ResourceReceipt::set_energy_usage(int64_t value) {
  _internal_set_energy_usage(value);
  // @@protoc_insertion_point(field_set:protocol.ResourceReceipt.energy_usage)
}

// int64 energy_fee = 2;
inline void ResourceReceipt::clear_energy_fee() {
  energy_fee_ = int64_t{0};
}
inline int64_t ResourceReceipt::_internal_energy_fee() const {
  return energy_fee_;
}
inline int64_t ResourceReceipt::energy_fee() const {
  // @@protoc_insertion_point(field_get:protocol.ResourceReceipt.energy_fee)
  return _internal_energy_fee();
}
inline void ResourceReceipt::_internal_set_energy_fee(int64_t value) {
  
  energy_fee_ = value;
}
inline void ResourceReceipt::set_energy_fee(int64_t value) {
  _internal_set_energy_fee(value);
  // @@protoc_insertion_point(field_set:protocol.ResourceReceipt.energy_fee)
}

// int64 origin_energy_usage = 3;
inline void ResourceReceipt::clear_origin_energy_usage() {
  origin_energy_usage_ = int64_t{0};
}
inline int64_t ResourceReceipt::_internal_origin_energy_usage() const {
  return origin_energy_usage_;
}
inline int64_t ResourceReceipt::origin_energy_usage() const {
  // @@protoc_insertion_point(field_get:protocol.ResourceReceipt.origin_energy_usage)
  return _internal_origin_energy_usage();
}
inline void ResourceReceipt::_internal_set_origin_energy_usage(int64_t value) {
  
  origin_energy_usage_ = value;
}
inline void ResourceReceipt::set_origin_energy_usage(int64_t value) {
  _internal_set_origin_energy_usage(value);
  // @@protoc_insertion_point(field_set:protocol.ResourceReceipt.origin_energy_usage)
}

// int64 energy_usage_total = 4;
inline void ResourceReceipt::clear_energy_usage_total() {
  energy_usage_total_ = int64_t{0};
}
inline int64_t ResourceReceipt::_internal_energy_usage_total() const {
  return energy_usage_total_;
}
inline int64_t ResourceReceipt::energy_usage_total() const {
  // @@protoc_insertion_point(field_get:protocol.ResourceReceipt.energy_usage_total)
  return _internal_energy_usage_total();
}
inline void ResourceReceipt::_internal_set_energy_usage_total(int64_t value) {
  
  energy_usage_total_ = value;
}
inline void ResourceReceipt::set_energy_usage_total(int64_t value) {
  _internal_set_energy_usage_total(value);
  // @@protoc_insertion_point(field_set:protocol.ResourceReceipt.energy_usage_total)
}

// int64 net_usage = 5;
inline void ResourceReceipt::clear_net_usage() {
  net_usage_ = int64_t{0};
}
inline int64_t ResourceReceipt::_internal_net_usage() const {
  return net_usage_;
}
inline int64_t ResourceReceipt::net_usage() const {
  // @@protoc_insertion_point(field_get:protocol.ResourceReceipt.net_usage)
  return _internal_net_usage();
}
inline void ResourceReceipt::_internal_set_net_usage(int64_t value) {
  
  net_usage_ = value;
}
inline void ResourceReceipt::set_net_usage(int64_t value) {
  _internal_set_net_usage(value);
  // @@protoc_insertion_point(field_set:protocol.ResourceReceipt.net_usage)
}

// int64 net_fee = 6;
inline void ResourceReceipt::clear_net_fee() {
  net_fee_ = int64_t{0};
}
inline int64_t ResourceReceipt::_internal_net_fee() const {
  return net_fee_;
}
inline int64_t ResourceReceipt::net_fee() const {
  // @@protoc_insertion_point(field_get:protocol.ResourceReceipt.net_fee)
  return _internal_net_fee();
}
inline void ResourceReceipt::_internal_set_net_fee(int64_t value) {
  
  net_fee_ = value;
}
inline void ResourceReceipt::set_net_fee(int64_t value) {
  _internal_set_net_fee(value);
  // @@protoc_insertion_point(field_set:protocol.ResourceReceipt.net_fee)
}

// .protocol.Transaction.Result.contractResult result = 7;
inline void ResourceReceipt::clear_result() {
  result_ = 0;
}
inline ::protocol::Transaction_Result_contractResult ResourceReceipt::_internal_result() const {
  return static_cast< ::protocol::Transaction_Result_contractResult >(result_);
}
inline ::protocol::Transaction_Result_contractResult ResourceReceipt::result() const {
  // @@protoc_insertion_point(field_get:protocol.ResourceReceipt.result)
  return _internal_result();
}
inline void ResourceReceipt::_internal_set_result(::protocol::Transaction_Result_contractResult value) {
  
  result_ = value;
}
inline void ResourceReceipt::set_result(::protocol::Transaction_Result_contractResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:protocol.ResourceReceipt.result)
}

// -------------------------------------------------------------------

// MarketOrderDetail

// bytes makerOrderId = 1;
inline void MarketOrderDetail::clear_makerorderid() {
  makerorderid_.ClearToEmpty();
}
inline const std::string& MarketOrderDetail::makerorderid() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderDetail.makerOrderId)
  return _internal_makerorderid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrderDetail::set_makerorderid(ArgT0&& arg0, ArgT... args) {
 
 makerorderid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrderDetail.makerOrderId)
}
inline std::string* MarketOrderDetail::mutable_makerorderid() {
  std::string* _s = _internal_mutable_makerorderid();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrderDetail.makerOrderId)
  return _s;
}
inline const std::string& MarketOrderDetail::_internal_makerorderid() const {
  return makerorderid_.Get();
}
inline void MarketOrderDetail::_internal_set_makerorderid(const std::string& value) {
  
  makerorderid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketOrderDetail::_internal_mutable_makerorderid() {
  
  return makerorderid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketOrderDetail::release_makerorderid() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrderDetail.makerOrderId)
  return makerorderid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketOrderDetail::set_allocated_makerorderid(std::string* makerorderid) {
  if (makerorderid != nullptr) {
    
  } else {
    
  }
  makerorderid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), makerorderid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (makerorderid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    makerorderid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrderDetail.makerOrderId)
}

// bytes takerOrderId = 2;
inline void MarketOrderDetail::clear_takerorderid() {
  takerorderid_.ClearToEmpty();
}
inline const std::string& MarketOrderDetail::takerorderid() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderDetail.takerOrderId)
  return _internal_takerorderid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketOrderDetail::set_takerorderid(ArgT0&& arg0, ArgT... args) {
 
 takerorderid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MarketOrderDetail.takerOrderId)
}
inline std::string* MarketOrderDetail::mutable_takerorderid() {
  std::string* _s = _internal_mutable_takerorderid();
  // @@protoc_insertion_point(field_mutable:protocol.MarketOrderDetail.takerOrderId)
  return _s;
}
inline const std::string& MarketOrderDetail::_internal_takerorderid() const {
  return takerorderid_.Get();
}
inline void MarketOrderDetail::_internal_set_takerorderid(const std::string& value) {
  
  takerorderid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MarketOrderDetail::_internal_mutable_takerorderid() {
  
  return takerorderid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MarketOrderDetail::release_takerorderid() {
  // @@protoc_insertion_point(field_release:protocol.MarketOrderDetail.takerOrderId)
  return takerorderid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MarketOrderDetail::set_allocated_takerorderid(std::string* takerorderid) {
  if (takerorderid != nullptr) {
    
  } else {
    
  }
  takerorderid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), takerorderid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (takerorderid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    takerorderid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MarketOrderDetail.takerOrderId)
}

// int64 fillSellQuantity = 3;
inline void MarketOrderDetail::clear_fillsellquantity() {
  fillsellquantity_ = int64_t{0};
}
inline int64_t MarketOrderDetail::_internal_fillsellquantity() const {
  return fillsellquantity_;
}
inline int64_t MarketOrderDetail::fillsellquantity() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderDetail.fillSellQuantity)
  return _internal_fillsellquantity();
}
inline void MarketOrderDetail::_internal_set_fillsellquantity(int64_t value) {
  
  fillsellquantity_ = value;
}
inline void MarketOrderDetail::set_fillsellquantity(int64_t value) {
  _internal_set_fillsellquantity(value);
  // @@protoc_insertion_point(field_set:protocol.MarketOrderDetail.fillSellQuantity)
}

// int64 fillBuyQuantity = 4;
inline void MarketOrderDetail::clear_fillbuyquantity() {
  fillbuyquantity_ = int64_t{0};
}
inline int64_t MarketOrderDetail::_internal_fillbuyquantity() const {
  return fillbuyquantity_;
}
inline int64_t MarketOrderDetail::fillbuyquantity() const {
  // @@protoc_insertion_point(field_get:protocol.MarketOrderDetail.fillBuyQuantity)
  return _internal_fillbuyquantity();
}
inline void MarketOrderDetail::_internal_set_fillbuyquantity(int64_t value) {
  
  fillbuyquantity_ = value;
}
inline void MarketOrderDetail::set_fillbuyquantity(int64_t value) {
  _internal_set_fillbuyquantity(value);
  // @@protoc_insertion_point(field_set:protocol.MarketOrderDetail.fillBuyQuantity)
}

// -------------------------------------------------------------------

// Transaction_Contract

// .protocol.Transaction.Contract.ContractType type = 1;
inline void Transaction_Contract::clear_type() {
  type_ = 0;
}
inline ::protocol::Transaction_Contract_ContractType Transaction_Contract::_internal_type() const {
  return static_cast< ::protocol::Transaction_Contract_ContractType >(type_);
}
inline ::protocol::Transaction_Contract_ContractType Transaction_Contract::type() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.type)
  return _internal_type();
}
inline void Transaction_Contract::_internal_set_type(::protocol::Transaction_Contract_ContractType value) {
  
  type_ = value;
}
inline void Transaction_Contract::set_type(::protocol::Transaction_Contract_ContractType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.type)
}

// .google.protobuf.Any parameter = 2;
inline bool Transaction_Contract::_internal_has_parameter() const {
  return this != internal_default_instance() && parameter_ != nullptr;
}
inline bool Transaction_Contract::has_parameter() const {
  return _internal_has_parameter();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Transaction_Contract::_internal_parameter() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = parameter_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Transaction_Contract::parameter() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.parameter)
  return _internal_parameter();
}
inline void Transaction_Contract::unsafe_arena_set_allocated_parameter(
    ::PROTOBUF_NAMESPACE_ID::Any* parameter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parameter_);
  }
  parameter_ = parameter;
  if (parameter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Transaction.Contract.parameter)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Transaction_Contract::release_parameter() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = parameter_;
  parameter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Transaction_Contract::unsafe_arena_release_parameter() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Contract.parameter)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = parameter_;
  parameter_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Transaction_Contract::_internal_mutable_parameter() {
  
  if (parameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    parameter_ = p;
  }
  return parameter_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Transaction_Contract::mutable_parameter() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_parameter();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Contract.parameter)
  return _msg;
}
inline void Transaction_Contract::set_allocated_parameter(::PROTOBUF_NAMESPACE_ID::Any* parameter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parameter_);
  }
  if (parameter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parameter));
    if (message_arena != submessage_arena) {
      parameter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parameter, submessage_arena);
    }
    
  } else {
    
  }
  parameter_ = parameter;
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Contract.parameter)
}

// bytes provider = 3;
inline void Transaction_Contract::clear_provider() {
  provider_.ClearToEmpty();
}
inline const std::string& Transaction_Contract::provider() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.provider)
  return _internal_provider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_Contract::set_provider(ArgT0&& arg0, ArgT... args) {
 
 provider_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.provider)
}
inline std::string* Transaction_Contract::mutable_provider() {
  std::string* _s = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Contract.provider)
  return _s;
}
inline const std::string& Transaction_Contract::_internal_provider() const {
  return provider_.Get();
}
inline void Transaction_Contract::_internal_set_provider(const std::string& value) {
  
  provider_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transaction_Contract::_internal_mutable_provider() {
  
  return provider_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transaction_Contract::release_provider() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Contract.provider)
  return provider_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transaction_Contract::set_allocated_provider(std::string* provider) {
  if (provider != nullptr) {
    
  } else {
    
  }
  provider_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), provider,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (provider_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    provider_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Contract.provider)
}

// bytes ContractName = 4;
inline void Transaction_Contract::clear_contractname() {
  contractname_.ClearToEmpty();
}
inline const std::string& Transaction_Contract::contractname() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.ContractName)
  return _internal_contractname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_Contract::set_contractname(ArgT0&& arg0, ArgT... args) {
 
 contractname_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.ContractName)
}
inline std::string* Transaction_Contract::mutable_contractname() {
  std::string* _s = _internal_mutable_contractname();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Contract.ContractName)
  return _s;
}
inline const std::string& Transaction_Contract::_internal_contractname() const {
  return contractname_.Get();
}
inline void Transaction_Contract::_internal_set_contractname(const std::string& value) {
  
  contractname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transaction_Contract::_internal_mutable_contractname() {
  
  return contractname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transaction_Contract::release_contractname() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Contract.ContractName)
  return contractname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transaction_Contract::set_allocated_contractname(std::string* contractname) {
  if (contractname != nullptr) {
    
  } else {
    
  }
  contractname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contractname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contractname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contractname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Contract.ContractName)
}

// int32 Permission_id = 5;
inline void Transaction_Contract::clear_permission_id() {
  permission_id_ = 0;
}
inline int32_t Transaction_Contract::_internal_permission_id() const {
  return permission_id_;
}
inline int32_t Transaction_Contract::permission_id() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.Permission_id)
  return _internal_permission_id();
}
inline void Transaction_Contract::_internal_set_permission_id(int32_t value) {
  
  permission_id_ = value;
}
inline void Transaction_Contract::set_permission_id(int32_t value) {
  _internal_set_permission_id(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.Permission_id)
}

// -------------------------------------------------------------------

// Transaction_Result

// int64 fee = 1;
inline void Transaction_Result::clear_fee() {
  fee_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_fee() const {
  return fee_;
}
inline int64_t Transaction_Result::fee() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.fee)
  return _internal_fee();
}
inline void Transaction_Result::_internal_set_fee(int64_t value) {
  
  fee_ = value;
}
inline void Transaction_Result::set_fee(int64_t value) {
  _internal_set_fee(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.fee)
}

// .protocol.Transaction.Result.code ret = 2;
inline void Transaction_Result::clear_ret() {
  ret_ = 0;
}
inline ::protocol::Transaction_Result_code Transaction_Result::_internal_ret() const {
  return static_cast< ::protocol::Transaction_Result_code >(ret_);
}
inline ::protocol::Transaction_Result_code Transaction_Result::ret() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.ret)
  return _internal_ret();
}
inline void Transaction_Result::_internal_set_ret(::protocol::Transaction_Result_code value) {
  
  ret_ = value;
}
inline void Transaction_Result::set_ret(::protocol::Transaction_Result_code value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.ret)
}

// .protocol.Transaction.Result.contractResult contractRet = 3;
inline void Transaction_Result::clear_contractret() {
  contractret_ = 0;
}
inline ::protocol::Transaction_Result_contractResult Transaction_Result::_internal_contractret() const {
  return static_cast< ::protocol::Transaction_Result_contractResult >(contractret_);
}
inline ::protocol::Transaction_Result_contractResult Transaction_Result::contractret() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.contractRet)
  return _internal_contractret();
}
inline void Transaction_Result::_internal_set_contractret(::protocol::Transaction_Result_contractResult value) {
  
  contractret_ = value;
}
inline void Transaction_Result::set_contractret(::protocol::Transaction_Result_contractResult value) {
  _internal_set_contractret(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.contractRet)
}

// string assetIssueID = 14;
inline void Transaction_Result::clear_assetissueid() {
  assetissueid_.ClearToEmpty();
}
inline const std::string& Transaction_Result::assetissueid() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.assetIssueID)
  return _internal_assetissueid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_Result::set_assetissueid(ArgT0&& arg0, ArgT... args) {
 
 assetissueid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.assetIssueID)
}
inline std::string* Transaction_Result::mutable_assetissueid() {
  std::string* _s = _internal_mutable_assetissueid();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Result.assetIssueID)
  return _s;
}
inline const std::string& Transaction_Result::_internal_assetissueid() const {
  return assetissueid_.Get();
}
inline void Transaction_Result::_internal_set_assetissueid(const std::string& value) {
  
  assetissueid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transaction_Result::_internal_mutable_assetissueid() {
  
  return assetissueid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transaction_Result::release_assetissueid() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Result.assetIssueID)
  return assetissueid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transaction_Result::set_allocated_assetissueid(std::string* assetissueid) {
  if (assetissueid != nullptr) {
    
  } else {
    
  }
  assetissueid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assetissueid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (assetissueid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    assetissueid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Result.assetIssueID)
}

// int64 withdraw_amount = 15;
inline void Transaction_Result::clear_withdraw_amount() {
  withdraw_amount_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_withdraw_amount() const {
  return withdraw_amount_;
}
inline int64_t Transaction_Result::withdraw_amount() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.withdraw_amount)
  return _internal_withdraw_amount();
}
inline void Transaction_Result::_internal_set_withdraw_amount(int64_t value) {
  
  withdraw_amount_ = value;
}
inline void Transaction_Result::set_withdraw_amount(int64_t value) {
  _internal_set_withdraw_amount(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.withdraw_amount)
}

// int64 unfreeze_amount = 16;
inline void Transaction_Result::clear_unfreeze_amount() {
  unfreeze_amount_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_unfreeze_amount() const {
  return unfreeze_amount_;
}
inline int64_t Transaction_Result::unfreeze_amount() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.unfreeze_amount)
  return _internal_unfreeze_amount();
}
inline void Transaction_Result::_internal_set_unfreeze_amount(int64_t value) {
  
  unfreeze_amount_ = value;
}
inline void Transaction_Result::set_unfreeze_amount(int64_t value) {
  _internal_set_unfreeze_amount(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.unfreeze_amount)
}

// int64 exchange_received_amount = 18;
inline void Transaction_Result::clear_exchange_received_amount() {
  exchange_received_amount_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_exchange_received_amount() const {
  return exchange_received_amount_;
}
inline int64_t Transaction_Result::exchange_received_amount() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.exchange_received_amount)
  return _internal_exchange_received_amount();
}
inline void Transaction_Result::_internal_set_exchange_received_amount(int64_t value) {
  
  exchange_received_amount_ = value;
}
inline void Transaction_Result::set_exchange_received_amount(int64_t value) {
  _internal_set_exchange_received_amount(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.exchange_received_amount)
}

// int64 exchange_inject_another_amount = 19;
inline void Transaction_Result::clear_exchange_inject_another_amount() {
  exchange_inject_another_amount_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_exchange_inject_another_amount() const {
  return exchange_inject_another_amount_;
}
inline int64_t Transaction_Result::exchange_inject_another_amount() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.exchange_inject_another_amount)
  return _internal_exchange_inject_another_amount();
}
inline void Transaction_Result::_internal_set_exchange_inject_another_amount(int64_t value) {
  
  exchange_inject_another_amount_ = value;
}
inline void Transaction_Result::set_exchange_inject_another_amount(int64_t value) {
  _internal_set_exchange_inject_another_amount(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.exchange_inject_another_amount)
}

// int64 exchange_withdraw_another_amount = 20;
inline void Transaction_Result::clear_exchange_withdraw_another_amount() {
  exchange_withdraw_another_amount_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_exchange_withdraw_another_amount() const {
  return exchange_withdraw_another_amount_;
}
inline int64_t Transaction_Result::exchange_withdraw_another_amount() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.exchange_withdraw_another_amount)
  return _internal_exchange_withdraw_another_amount();
}
inline void Transaction_Result::_internal_set_exchange_withdraw_another_amount(int64_t value) {
  
  exchange_withdraw_another_amount_ = value;
}
inline void Transaction_Result::set_exchange_withdraw_another_amount(int64_t value) {
  _internal_set_exchange_withdraw_another_amount(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.exchange_withdraw_another_amount)
}

// int64 exchange_id = 21;
inline void Transaction_Result::clear_exchange_id() {
  exchange_id_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_exchange_id() const {
  return exchange_id_;
}
inline int64_t Transaction_Result::exchange_id() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.exchange_id)
  return _internal_exchange_id();
}
inline void Transaction_Result::_internal_set_exchange_id(int64_t value) {
  
  exchange_id_ = value;
}
inline void Transaction_Result::set_exchange_id(int64_t value) {
  _internal_set_exchange_id(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.exchange_id)
}

// int64 shielded_transaction_fee = 22;
inline void Transaction_Result::clear_shielded_transaction_fee() {
  shielded_transaction_fee_ = int64_t{0};
}
inline int64_t Transaction_Result::_internal_shielded_transaction_fee() const {
  return shielded_transaction_fee_;
}
inline int64_t Transaction_Result::shielded_transaction_fee() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.shielded_transaction_fee)
  return _internal_shielded_transaction_fee();
}
inline void Transaction_Result::_internal_set_shielded_transaction_fee(int64_t value) {
  
  shielded_transaction_fee_ = value;
}
inline void Transaction_Result::set_shielded_transaction_fee(int64_t value) {
  _internal_set_shielded_transaction_fee(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.shielded_transaction_fee)
}

// bytes orderId = 25;
inline void Transaction_Result::clear_orderid() {
  orderid_.ClearToEmpty();
}
inline const std::string& Transaction_Result::orderid() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.orderId)
  return _internal_orderid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_Result::set_orderid(ArgT0&& arg0, ArgT... args) {
 
 orderid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.Result.orderId)
}
inline std::string* Transaction_Result::mutable_orderid() {
  std::string* _s = _internal_mutable_orderid();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Result.orderId)
  return _s;
}
inline const std::string& Transaction_Result::_internal_orderid() const {
  return orderid_.Get();
}
inline void Transaction_Result::_internal_set_orderid(const std::string& value) {
  
  orderid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transaction_Result::_internal_mutable_orderid() {
  
  return orderid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transaction_Result::release_orderid() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Result.orderId)
  return orderid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transaction_Result::set_allocated_orderid(std::string* orderid) {
  if (orderid != nullptr) {
    
  } else {
    
  }
  orderid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), orderid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (orderid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    orderid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Result.orderId)
}

// repeated .protocol.MarketOrderDetail orderDetails = 26;
inline int Transaction_Result::_internal_orderdetails_size() const {
  return orderdetails_.size();
}
inline int Transaction_Result::orderdetails_size() const {
  return _internal_orderdetails_size();
}
inline void Transaction_Result::clear_orderdetails() {
  orderdetails_.Clear();
}
inline ::protocol::MarketOrderDetail* Transaction_Result::mutable_orderdetails(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Result.orderDetails)
  return orderdetails_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail >*
Transaction_Result::mutable_orderdetails() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.Result.orderDetails)
  return &orderdetails_;
}
inline const ::protocol::MarketOrderDetail& Transaction_Result::_internal_orderdetails(int index) const {
  return orderdetails_.Get(index);
}
inline const ::protocol::MarketOrderDetail& Transaction_Result::orderdetails(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Result.orderDetails)
  return _internal_orderdetails(index);
}
inline ::protocol::MarketOrderDetail* Transaction_Result::_internal_add_orderdetails() {
  return orderdetails_.Add();
}
inline ::protocol::MarketOrderDetail* Transaction_Result::add_orderdetails() {
  ::protocol::MarketOrderDetail* _add = _internal_add_orderdetails();
  // @@protoc_insertion_point(field_add:protocol.Transaction.Result.orderDetails)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail >&
Transaction_Result::orderdetails() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.Result.orderDetails)
  return orderdetails_;
}

// -------------------------------------------------------------------

// Transaction_raw

// bytes ref_block_bytes = 1;
inline void Transaction_raw::clear_ref_block_bytes() {
  ref_block_bytes_.ClearToEmpty();
}
inline const std::string& Transaction_raw::ref_block_bytes() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_bytes)
  return _internal_ref_block_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_raw::set_ref_block_bytes(ArgT0&& arg0, ArgT... args) {
 
 ref_block_bytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_bytes)
}
inline std::string* Transaction_raw::mutable_ref_block_bytes() {
  std::string* _s = _internal_mutable_ref_block_bytes();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.ref_block_bytes)
  return _s;
}
inline const std::string& Transaction_raw::_internal_ref_block_bytes() const {
  return ref_block_bytes_.Get();
}
inline void Transaction_raw::_internal_set_ref_block_bytes(const std::string& value) {
  
  ref_block_bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transaction_raw::_internal_mutable_ref_block_bytes() {
  
  return ref_block_bytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transaction_raw::release_ref_block_bytes() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.ref_block_bytes)
  return ref_block_bytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transaction_raw::set_allocated_ref_block_bytes(std::string* ref_block_bytes) {
  if (ref_block_bytes != nullptr) {
    
  } else {
    
  }
  ref_block_bytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ref_block_bytes,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ref_block_bytes_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ref_block_bytes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.ref_block_bytes)
}

// int64 ref_block_num = 3;
inline void Transaction_raw::clear_ref_block_num() {
  ref_block_num_ = int64_t{0};
}
inline int64_t Transaction_raw::_internal_ref_block_num() const {
  return ref_block_num_;
}
inline int64_t Transaction_raw::ref_block_num() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_num)
  return _internal_ref_block_num();
}
inline void Transaction_raw::_internal_set_ref_block_num(int64_t value) {
  
  ref_block_num_ = value;
}
inline void Transaction_raw::set_ref_block_num(int64_t value) {
  _internal_set_ref_block_num(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_num)
}

// bytes ref_block_hash = 4;
inline void Transaction_raw::clear_ref_block_hash() {
  ref_block_hash_.ClearToEmpty();
}
inline const std::string& Transaction_raw::ref_block_hash() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_hash)
  return _internal_ref_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_raw::set_ref_block_hash(ArgT0&& arg0, ArgT... args) {
 
 ref_block_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_hash)
}
inline std::string* Transaction_raw::mutable_ref_block_hash() {
  std::string* _s = _internal_mutable_ref_block_hash();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.ref_block_hash)
  return _s;
}
inline const std::string& Transaction_raw::_internal_ref_block_hash() const {
  return ref_block_hash_.Get();
}
inline void Transaction_raw::_internal_set_ref_block_hash(const std::string& value) {
  
  ref_block_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transaction_raw::_internal_mutable_ref_block_hash() {
  
  return ref_block_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transaction_raw::release_ref_block_hash() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.ref_block_hash)
  return ref_block_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transaction_raw::set_allocated_ref_block_hash(std::string* ref_block_hash) {
  if (ref_block_hash != nullptr) {
    
  } else {
    
  }
  ref_block_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ref_block_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ref_block_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ref_block_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.ref_block_hash)
}

// int64 expiration = 8;
inline void Transaction_raw::clear_expiration() {
  expiration_ = int64_t{0};
}
inline int64_t Transaction_raw::_internal_expiration() const {
  return expiration_;
}
inline int64_t Transaction_raw::expiration() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.expiration)
  return _internal_expiration();
}
inline void Transaction_raw::_internal_set_expiration(int64_t value) {
  
  expiration_ = value;
}
inline void Transaction_raw::set_expiration(int64_t value) {
  _internal_set_expiration(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.expiration)
}

// repeated .protocol.authority auths = 9;
inline int Transaction_raw::_internal_auths_size() const {
  return auths_.size();
}
inline int Transaction_raw::auths_size() const {
  return _internal_auths_size();
}
inline void Transaction_raw::clear_auths() {
  auths_.Clear();
}
inline ::protocol::authority* Transaction_raw::mutable_auths(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.auths)
  return auths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::authority >*
Transaction_raw::mutable_auths() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.raw.auths)
  return &auths_;
}
inline const ::protocol::authority& Transaction_raw::_internal_auths(int index) const {
  return auths_.Get(index);
}
inline const ::protocol::authority& Transaction_raw::auths(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.auths)
  return _internal_auths(index);
}
inline ::protocol::authority* Transaction_raw::_internal_add_auths() {
  return auths_.Add();
}
inline ::protocol::authority* Transaction_raw::add_auths() {
  ::protocol::authority* _add = _internal_add_auths();
  // @@protoc_insertion_point(field_add:protocol.Transaction.raw.auths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::authority >&
Transaction_raw::auths() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.raw.auths)
  return auths_;
}

// bytes data = 10;
inline void Transaction_raw::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Transaction_raw::data() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_raw::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.data)
}
inline std::string* Transaction_raw::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.data)
  return _s;
}
inline const std::string& Transaction_raw::_internal_data() const {
  return data_.Get();
}
inline void Transaction_raw::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transaction_raw::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transaction_raw::release_data() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transaction_raw::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.data)
}

// repeated .protocol.Transaction.Contract contract = 11;
inline int Transaction_raw::_internal_contract_size() const {
  return contract_.size();
}
inline int Transaction_raw::contract_size() const {
  return _internal_contract_size();
}
inline void Transaction_raw::clear_contract() {
  contract_.Clear();
}
inline ::protocol::Transaction_Contract* Transaction_raw::mutable_contract(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.contract)
  return contract_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Contract >*
Transaction_raw::mutable_contract() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.raw.contract)
  return &contract_;
}
inline const ::protocol::Transaction_Contract& Transaction_raw::_internal_contract(int index) const {
  return contract_.Get(index);
}
inline const ::protocol::Transaction_Contract& Transaction_raw::contract(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.contract)
  return _internal_contract(index);
}
inline ::protocol::Transaction_Contract* Transaction_raw::_internal_add_contract() {
  return contract_.Add();
}
inline ::protocol::Transaction_Contract* Transaction_raw::add_contract() {
  ::protocol::Transaction_Contract* _add = _internal_add_contract();
  // @@protoc_insertion_point(field_add:protocol.Transaction.raw.contract)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Contract >&
Transaction_raw::contract() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.raw.contract)
  return contract_;
}

// bytes scripts = 12;
inline void Transaction_raw::clear_scripts() {
  scripts_.ClearToEmpty();
}
inline const std::string& Transaction_raw::scripts() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.scripts)
  return _internal_scripts();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction_raw::set_scripts(ArgT0&& arg0, ArgT... args) {
 
 scripts_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.scripts)
}
inline std::string* Transaction_raw::mutable_scripts() {
  std::string* _s = _internal_mutable_scripts();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.scripts)
  return _s;
}
inline const std::string& Transaction_raw::_internal_scripts() const {
  return scripts_.Get();
}
inline void Transaction_raw::_internal_set_scripts(const std::string& value) {
  
  scripts_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transaction_raw::_internal_mutable_scripts() {
  
  return scripts_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transaction_raw::release_scripts() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.scripts)
  return scripts_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transaction_raw::set_allocated_scripts(std::string* scripts) {
  if (scripts != nullptr) {
    
  } else {
    
  }
  scripts_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scripts,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (scripts_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    scripts_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.scripts)
}

// int64 timestamp = 14;
inline void Transaction_raw::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t Transaction_raw::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t Transaction_raw::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.timestamp)
  return _internal_timestamp();
}
inline void Transaction_raw::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void Transaction_raw::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.timestamp)
}

// int64 fee_limit = 18;
inline void Transaction_raw::clear_fee_limit() {
  fee_limit_ = int64_t{0};
}
inline int64_t Transaction_raw::_internal_fee_limit() const {
  return fee_limit_;
}
inline int64_t Transaction_raw::fee_limit() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.fee_limit)
  return _internal_fee_limit();
}
inline void Transaction_raw::_internal_set_fee_limit(int64_t value) {
  
  fee_limit_ = value;
}
inline void Transaction_raw::set_fee_limit(int64_t value) {
  _internal_set_fee_limit(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.fee_limit)
}

// -------------------------------------------------------------------

// Transaction

// .protocol.Transaction.raw raw_data = 1;
inline bool Transaction::_internal_has_raw_data() const {
  return this != internal_default_instance() && raw_data_ != nullptr;
}
inline bool Transaction::has_raw_data() const {
  return _internal_has_raw_data();
}
inline void Transaction::clear_raw_data() {
  if (GetArenaForAllocation() == nullptr && raw_data_ != nullptr) {
    delete raw_data_;
  }
  raw_data_ = nullptr;
}
inline const ::protocol::Transaction_raw& Transaction::_internal_raw_data() const {
  const ::protocol::Transaction_raw* p = raw_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Transaction_raw&>(
      ::protocol::_Transaction_raw_default_instance_);
}
inline const ::protocol::Transaction_raw& Transaction::raw_data() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw_data)
  return _internal_raw_data();
}
inline void Transaction::unsafe_arena_set_allocated_raw_data(
    ::protocol::Transaction_raw* raw_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_data_);
  }
  raw_data_ = raw_data;
  if (raw_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Transaction.raw_data)
}
inline ::protocol::Transaction_raw* Transaction::release_raw_data() {
  
  ::protocol::Transaction_raw* temp = raw_data_;
  raw_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Transaction_raw* Transaction::unsafe_arena_release_raw_data() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw_data)
  
  ::protocol::Transaction_raw* temp = raw_data_;
  raw_data_ = nullptr;
  return temp;
}
inline ::protocol::Transaction_raw* Transaction::_internal_mutable_raw_data() {
  
  if (raw_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Transaction_raw>(GetArenaForAllocation());
    raw_data_ = p;
  }
  return raw_data_;
}
inline ::protocol::Transaction_raw* Transaction::mutable_raw_data() {
  ::protocol::Transaction_raw* _msg = _internal_mutable_raw_data();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw_data)
  return _msg;
}
inline void Transaction::set_allocated_raw_data(::protocol::Transaction_raw* raw_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete raw_data_;
  }
  if (raw_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Transaction_raw>::GetOwningArena(raw_data);
    if (message_arena != submessage_arena) {
      raw_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    
  } else {
    
  }
  raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw_data)
}

// repeated bytes signature = 2;
inline int Transaction::_internal_signature_size() const {
  return signature_.size();
}
inline int Transaction::signature_size() const {
  return _internal_signature_size();
}
inline void Transaction::clear_signature() {
  signature_.Clear();
}
inline std::string* Transaction::add_signature() {
  std::string* _s = _internal_add_signature();
  // @@protoc_insertion_point(field_add_mutable:protocol.Transaction.signature)
  return _s;
}
inline const std::string& Transaction::_internal_signature(int index) const {
  return signature_.Get(index);
}
inline const std::string& Transaction::signature(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.signature)
  return _internal_signature(index);
}
inline std::string* Transaction::mutable_signature(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.signature)
  return signature_.Mutable(index);
}
inline void Transaction::set_signature(int index, const std::string& value) {
  signature_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.signature)
}
inline void Transaction::set_signature(int index, std::string&& value) {
  signature_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.Transaction.signature)
}
inline void Transaction::set_signature(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signature_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.signature)
}
inline void Transaction::set_signature(int index, const void* value, size_t size) {
  signature_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.signature)
}
inline std::string* Transaction::_internal_add_signature() {
  return signature_.Add();
}
inline void Transaction::add_signature(const std::string& value) {
  signature_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.Transaction.signature)
}
inline void Transaction::add_signature(std::string&& value) {
  signature_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.Transaction.signature)
}
inline void Transaction::add_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signature_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.Transaction.signature)
}
inline void Transaction::add_signature(const void* value, size_t size) {
  signature_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.Transaction.signature)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Transaction::signature() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.signature)
  return signature_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Transaction::mutable_signature() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.signature)
  return &signature_;
}

// repeated .protocol.Transaction.Result ret = 5;
inline int Transaction::_internal_ret_size() const {
  return ret_.size();
}
inline int Transaction::ret_size() const {
  return _internal_ret_size();
}
inline void Transaction::clear_ret() {
  ret_.Clear();
}
inline ::protocol::Transaction_Result* Transaction::mutable_ret(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.ret)
  return ret_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Result >*
Transaction::mutable_ret() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.ret)
  return &ret_;
}
inline const ::protocol::Transaction_Result& Transaction::_internal_ret(int index) const {
  return ret_.Get(index);
}
inline const ::protocol::Transaction_Result& Transaction::ret(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.ret)
  return _internal_ret(index);
}
inline ::protocol::Transaction_Result* Transaction::_internal_add_ret() {
  return ret_.Add();
}
inline ::protocol::Transaction_Result* Transaction::add_ret() {
  ::protocol::Transaction_Result* _add = _internal_add_ret();
  // @@protoc_insertion_point(field_add:protocol.Transaction.ret)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction_Result >&
Transaction::ret() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.ret)
  return ret_;
}

// -------------------------------------------------------------------

// TransactionInfo_Log

// bytes address = 1;
inline void TransactionInfo_Log::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& TransactionInfo_Log::address() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.Log.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionInfo_Log::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.Log.address)
}
inline std::string* TransactionInfo_Log::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfo.Log.address)
  return _s;
}
inline const std::string& TransactionInfo_Log::_internal_address() const {
  return address_.Get();
}
inline void TransactionInfo_Log::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionInfo_Log::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionInfo_Log::release_address() {
  // @@protoc_insertion_point(field_release:protocol.TransactionInfo.Log.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionInfo_Log::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionInfo.Log.address)
}

// repeated bytes topics = 2;
inline int TransactionInfo_Log::_internal_topics_size() const {
  return topics_.size();
}
inline int TransactionInfo_Log::topics_size() const {
  return _internal_topics_size();
}
inline void TransactionInfo_Log::clear_topics() {
  topics_.Clear();
}
inline std::string* TransactionInfo_Log::add_topics() {
  std::string* _s = _internal_add_topics();
  // @@protoc_insertion_point(field_add_mutable:protocol.TransactionInfo.Log.topics)
  return _s;
}
inline const std::string& TransactionInfo_Log::_internal_topics(int index) const {
  return topics_.Get(index);
}
inline const std::string& TransactionInfo_Log::topics(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.Log.topics)
  return _internal_topics(index);
}
inline std::string* TransactionInfo_Log::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfo.Log.topics)
  return topics_.Mutable(index);
}
inline void TransactionInfo_Log::set_topics(int index, const std::string& value) {
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.Log.topics)
}
inline void TransactionInfo_Log::set_topics(int index, std::string&& value) {
  topics_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.Log.topics)
}
inline void TransactionInfo_Log::set_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.TransactionInfo.Log.topics)
}
inline void TransactionInfo_Log::set_topics(int index, const void* value, size_t size) {
  topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.TransactionInfo.Log.topics)
}
inline std::string* TransactionInfo_Log::_internal_add_topics() {
  return topics_.Add();
}
inline void TransactionInfo_Log::add_topics(const std::string& value) {
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.TransactionInfo.Log.topics)
}
inline void TransactionInfo_Log::add_topics(std::string&& value) {
  topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.TransactionInfo.Log.topics)
}
inline void TransactionInfo_Log::add_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.TransactionInfo.Log.topics)
}
inline void TransactionInfo_Log::add_topics(const void* value, size_t size) {
  topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.TransactionInfo.Log.topics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransactionInfo_Log::topics() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionInfo.Log.topics)
  return topics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransactionInfo_Log::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionInfo.Log.topics)
  return &topics_;
}

// bytes data = 3;
inline void TransactionInfo_Log::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& TransactionInfo_Log::data() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.Log.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionInfo_Log::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.Log.data)
}
inline std::string* TransactionInfo_Log::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfo.Log.data)
  return _s;
}
inline const std::string& TransactionInfo_Log::_internal_data() const {
  return data_.Get();
}
inline void TransactionInfo_Log::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionInfo_Log::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionInfo_Log::release_data() {
  // @@protoc_insertion_point(field_release:protocol.TransactionInfo.Log.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionInfo_Log::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionInfo.Log.data)
}

// -------------------------------------------------------------------

// TransactionInfo

// bytes id = 1;
inline void TransactionInfo::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& TransactionInfo::id() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionInfo::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.id)
}
inline std::string* TransactionInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfo.id)
  return _s;
}
inline const std::string& TransactionInfo::_internal_id() const {
  return id_.Get();
}
inline void TransactionInfo::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionInfo::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionInfo::release_id() {
  // @@protoc_insertion_point(field_release:protocol.TransactionInfo.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionInfo.id)
}

// int64 fee = 2;
inline void TransactionInfo::clear_fee() {
  fee_ = int64_t{0};
}
inline int64_t TransactionInfo::_internal_fee() const {
  return fee_;
}
inline int64_t TransactionInfo::fee() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.fee)
  return _internal_fee();
}
inline void TransactionInfo::_internal_set_fee(int64_t value) {
  
  fee_ = value;
}
inline void TransactionInfo::set_fee(int64_t value) {
  _internal_set_fee(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.fee)
}

// int64 blockNumber = 3;
inline void TransactionInfo::clear_blocknumber() {
  blocknumber_ = int64_t{0};
}
inline int64_t TransactionInfo::_internal_blocknumber() const {
  return blocknumber_;
}
inline int64_t TransactionInfo::blocknumber() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.blockNumber)
  return _internal_blocknumber();
}
inline void TransactionInfo::_internal_set_blocknumber(int64_t value) {
  
  blocknumber_ = value;
}
inline void TransactionInfo::set_blocknumber(int64_t value) {
  _internal_set_blocknumber(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.blockNumber)
}

// int64 blockTimeStamp = 4;
inline void TransactionInfo::clear_blocktimestamp() {
  blocktimestamp_ = int64_t{0};
}
inline int64_t TransactionInfo::_internal_blocktimestamp() const {
  return blocktimestamp_;
}
inline int64_t TransactionInfo::blocktimestamp() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.blockTimeStamp)
  return _internal_blocktimestamp();
}
inline void TransactionInfo::_internal_set_blocktimestamp(int64_t value) {
  
  blocktimestamp_ = value;
}
inline void TransactionInfo::set_blocktimestamp(int64_t value) {
  _internal_set_blocktimestamp(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.blockTimeStamp)
}

// repeated bytes contractResult = 5;
inline int TransactionInfo::_internal_contractresult_size() const {
  return contractresult_.size();
}
inline int TransactionInfo::contractresult_size() const {
  return _internal_contractresult_size();
}
inline void TransactionInfo::clear_contractresult() {
  contractresult_.Clear();
}
inline std::string* TransactionInfo::add_contractresult() {
  std::string* _s = _internal_add_contractresult();
  // @@protoc_insertion_point(field_add_mutable:protocol.TransactionInfo.contractResult)
  return _s;
}
inline const std::string& TransactionInfo::_internal_contractresult(int index) const {
  return contractresult_.Get(index);
}
inline const std::string& TransactionInfo::contractresult(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.contractResult)
  return _internal_contractresult(index);
}
inline std::string* TransactionInfo::mutable_contractresult(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfo.contractResult)
  return contractresult_.Mutable(index);
}
inline void TransactionInfo::set_contractresult(int index, const std::string& value) {
  contractresult_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.contractResult)
}
inline void TransactionInfo::set_contractresult(int index, std::string&& value) {
  contractresult_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.contractResult)
}
inline void TransactionInfo::set_contractresult(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  contractresult_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.TransactionInfo.contractResult)
}
inline void TransactionInfo::set_contractresult(int index, const void* value, size_t size) {
  contractresult_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.TransactionInfo.contractResult)
}
inline std::string* TransactionInfo::_internal_add_contractresult() {
  return contractresult_.Add();
}
inline void TransactionInfo::add_contractresult(const std::string& value) {
  contractresult_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.TransactionInfo.contractResult)
}
inline void TransactionInfo::add_contractresult(std::string&& value) {
  contractresult_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.TransactionInfo.contractResult)
}
inline void TransactionInfo::add_contractresult(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  contractresult_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.TransactionInfo.contractResult)
}
inline void TransactionInfo::add_contractresult(const void* value, size_t size) {
  contractresult_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.TransactionInfo.contractResult)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransactionInfo::contractresult() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionInfo.contractResult)
  return contractresult_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransactionInfo::mutable_contractresult() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionInfo.contractResult)
  return &contractresult_;
}

// bytes contract_address = 6;
inline void TransactionInfo::clear_contract_address() {
  contract_address_.ClearToEmpty();
}
inline const std::string& TransactionInfo::contract_address() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.contract_address)
  return _internal_contract_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionInfo::set_contract_address(ArgT0&& arg0, ArgT... args) {
 
 contract_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.contract_address)
}
inline std::string* TransactionInfo::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfo.contract_address)
  return _s;
}
inline const std::string& TransactionInfo::_internal_contract_address() const {
  return contract_address_.Get();
}
inline void TransactionInfo::_internal_set_contract_address(const std::string& value) {
  
  contract_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionInfo::_internal_mutable_contract_address() {
  
  return contract_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionInfo::release_contract_address() {
  // @@protoc_insertion_point(field_release:protocol.TransactionInfo.contract_address)
  return contract_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionInfo::set_allocated_contract_address(std::string* contract_address) {
  if (contract_address != nullptr) {
    
  } else {
    
  }
  contract_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contract_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contract_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contract_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionInfo.contract_address)
}

// .protocol.ResourceReceipt receipt = 7;
inline bool TransactionInfo::_internal_has_receipt() const {
  return this != internal_default_instance() && receipt_ != nullptr;
}
inline bool TransactionInfo::has_receipt() const {
  return _internal_has_receipt();
}
inline void TransactionInfo::clear_receipt() {
  if (GetArenaForAllocation() == nullptr && receipt_ != nullptr) {
    delete receipt_;
  }
  receipt_ = nullptr;
}
inline const ::protocol::ResourceReceipt& TransactionInfo::_internal_receipt() const {
  const ::protocol::ResourceReceipt* p = receipt_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::ResourceReceipt&>(
      ::protocol::_ResourceReceipt_default_instance_);
}
inline const ::protocol::ResourceReceipt& TransactionInfo::receipt() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.receipt)
  return _internal_receipt();
}
inline void TransactionInfo::unsafe_arena_set_allocated_receipt(
    ::protocol::ResourceReceipt* receipt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(receipt_);
  }
  receipt_ = receipt;
  if (receipt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TransactionInfo.receipt)
}
inline ::protocol::ResourceReceipt* TransactionInfo::release_receipt() {
  
  ::protocol::ResourceReceipt* temp = receipt_;
  receipt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::ResourceReceipt* TransactionInfo::unsafe_arena_release_receipt() {
  // @@protoc_insertion_point(field_release:protocol.TransactionInfo.receipt)
  
  ::protocol::ResourceReceipt* temp = receipt_;
  receipt_ = nullptr;
  return temp;
}
inline ::protocol::ResourceReceipt* TransactionInfo::_internal_mutable_receipt() {
  
  if (receipt_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::ResourceReceipt>(GetArenaForAllocation());
    receipt_ = p;
  }
  return receipt_;
}
inline ::protocol::ResourceReceipt* TransactionInfo::mutable_receipt() {
  ::protocol::ResourceReceipt* _msg = _internal_mutable_receipt();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfo.receipt)
  return _msg;
}
inline void TransactionInfo::set_allocated_receipt(::protocol::ResourceReceipt* receipt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete receipt_;
  }
  if (receipt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::ResourceReceipt>::GetOwningArena(receipt);
    if (message_arena != submessage_arena) {
      receipt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receipt, submessage_arena);
    }
    
  } else {
    
  }
  receipt_ = receipt;
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionInfo.receipt)
}

// repeated .protocol.TransactionInfo.Log log = 8;
inline int TransactionInfo::_internal_log_size() const {
  return log_.size();
}
inline int TransactionInfo::log_size() const {
  return _internal_log_size();
}
inline void TransactionInfo::clear_log() {
  log_.Clear();
}
inline ::protocol::TransactionInfo_Log* TransactionInfo::mutable_log(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfo.log)
  return log_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo_Log >*
TransactionInfo::mutable_log() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionInfo.log)
  return &log_;
}
inline const ::protocol::TransactionInfo_Log& TransactionInfo::_internal_log(int index) const {
  return log_.Get(index);
}
inline const ::protocol::TransactionInfo_Log& TransactionInfo::log(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.log)
  return _internal_log(index);
}
inline ::protocol::TransactionInfo_Log* TransactionInfo::_internal_add_log() {
  return log_.Add();
}
inline ::protocol::TransactionInfo_Log* TransactionInfo::add_log() {
  ::protocol::TransactionInfo_Log* _add = _internal_add_log();
  // @@protoc_insertion_point(field_add:protocol.TransactionInfo.log)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo_Log >&
TransactionInfo::log() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionInfo.log)
  return log_;
}

// .protocol.TransactionInfo.code result = 9;
inline void TransactionInfo::clear_result() {
  result_ = 0;
}
inline ::protocol::TransactionInfo_code TransactionInfo::_internal_result() const {
  return static_cast< ::protocol::TransactionInfo_code >(result_);
}
inline ::protocol::TransactionInfo_code TransactionInfo::result() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.result)
  return _internal_result();
}
inline void TransactionInfo::_internal_set_result(::protocol::TransactionInfo_code value) {
  
  result_ = value;
}
inline void TransactionInfo::set_result(::protocol::TransactionInfo_code value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.result)
}

// bytes resMessage = 10;
inline void TransactionInfo::clear_resmessage() {
  resmessage_.ClearToEmpty();
}
inline const std::string& TransactionInfo::resmessage() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.resMessage)
  return _internal_resmessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionInfo::set_resmessage(ArgT0&& arg0, ArgT... args) {
 
 resmessage_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.resMessage)
}
inline std::string* TransactionInfo::mutable_resmessage() {
  std::string* _s = _internal_mutable_resmessage();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfo.resMessage)
  return _s;
}
inline const std::string& TransactionInfo::_internal_resmessage() const {
  return resmessage_.Get();
}
inline void TransactionInfo::_internal_set_resmessage(const std::string& value) {
  
  resmessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionInfo::_internal_mutable_resmessage() {
  
  return resmessage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionInfo::release_resmessage() {
  // @@protoc_insertion_point(field_release:protocol.TransactionInfo.resMessage)
  return resmessage_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionInfo::set_allocated_resmessage(std::string* resmessage) {
  if (resmessage != nullptr) {
    
  } else {
    
  }
  resmessage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resmessage,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resmessage_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    resmessage_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionInfo.resMessage)
}

// string assetIssueID = 14;
inline void TransactionInfo::clear_assetissueid() {
  assetissueid_.ClearToEmpty();
}
inline const std::string& TransactionInfo::assetissueid() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.assetIssueID)
  return _internal_assetissueid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionInfo::set_assetissueid(ArgT0&& arg0, ArgT... args) {
 
 assetissueid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.assetIssueID)
}
inline std::string* TransactionInfo::mutable_assetissueid() {
  std::string* _s = _internal_mutable_assetissueid();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfo.assetIssueID)
  return _s;
}
inline const std::string& TransactionInfo::_internal_assetissueid() const {
  return assetissueid_.Get();
}
inline void TransactionInfo::_internal_set_assetissueid(const std::string& value) {
  
  assetissueid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionInfo::_internal_mutable_assetissueid() {
  
  return assetissueid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionInfo::release_assetissueid() {
  // @@protoc_insertion_point(field_release:protocol.TransactionInfo.assetIssueID)
  return assetissueid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionInfo::set_allocated_assetissueid(std::string* assetissueid) {
  if (assetissueid != nullptr) {
    
  } else {
    
  }
  assetissueid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assetissueid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (assetissueid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    assetissueid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionInfo.assetIssueID)
}

// int64 withdraw_amount = 15;
inline void TransactionInfo::clear_withdraw_amount() {
  withdraw_amount_ = int64_t{0};
}
inline int64_t TransactionInfo::_internal_withdraw_amount() const {
  return withdraw_amount_;
}
inline int64_t TransactionInfo::withdraw_amount() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.withdraw_amount)
  return _internal_withdraw_amount();
}
inline void TransactionInfo::_internal_set_withdraw_amount(int64_t value) {
  
  withdraw_amount_ = value;
}
inline void TransactionInfo::set_withdraw_amount(int64_t value) {
  _internal_set_withdraw_amount(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.withdraw_amount)
}

// int64 unfreeze_amount = 16;
inline void TransactionInfo::clear_unfreeze_amount() {
  unfreeze_amount_ = int64_t{0};
}
inline int64_t TransactionInfo::_internal_unfreeze_amount() const {
  return unfreeze_amount_;
}
inline int64_t TransactionInfo::unfreeze_amount() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.unfreeze_amount)
  return _internal_unfreeze_amount();
}
inline void TransactionInfo::_internal_set_unfreeze_amount(int64_t value) {
  
  unfreeze_amount_ = value;
}
inline void TransactionInfo::set_unfreeze_amount(int64_t value) {
  _internal_set_unfreeze_amount(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.unfreeze_amount)
}

// repeated .protocol.InternalTransaction internal_transactions = 17;
inline int TransactionInfo::_internal_internal_transactions_size() const {
  return internal_transactions_.size();
}
inline int TransactionInfo::internal_transactions_size() const {
  return _internal_internal_transactions_size();
}
inline void TransactionInfo::clear_internal_transactions() {
  internal_transactions_.Clear();
}
inline ::protocol::InternalTransaction* TransactionInfo::mutable_internal_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfo.internal_transactions)
  return internal_transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::InternalTransaction >*
TransactionInfo::mutable_internal_transactions() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionInfo.internal_transactions)
  return &internal_transactions_;
}
inline const ::protocol::InternalTransaction& TransactionInfo::_internal_internal_transactions(int index) const {
  return internal_transactions_.Get(index);
}
inline const ::protocol::InternalTransaction& TransactionInfo::internal_transactions(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.internal_transactions)
  return _internal_internal_transactions(index);
}
inline ::protocol::InternalTransaction* TransactionInfo::_internal_add_internal_transactions() {
  return internal_transactions_.Add();
}
inline ::protocol::InternalTransaction* TransactionInfo::add_internal_transactions() {
  ::protocol::InternalTransaction* _add = _internal_add_internal_transactions();
  // @@protoc_insertion_point(field_add:protocol.TransactionInfo.internal_transactions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::InternalTransaction >&
TransactionInfo::internal_transactions() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionInfo.internal_transactions)
  return internal_transactions_;
}

// int64 exchange_received_amount = 18;
inline void TransactionInfo::clear_exchange_received_amount() {
  exchange_received_amount_ = int64_t{0};
}
inline int64_t TransactionInfo::_internal_exchange_received_amount() const {
  return exchange_received_amount_;
}
inline int64_t TransactionInfo::exchange_received_amount() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.exchange_received_amount)
  return _internal_exchange_received_amount();
}
inline void TransactionInfo::_internal_set_exchange_received_amount(int64_t value) {
  
  exchange_received_amount_ = value;
}
inline void TransactionInfo::set_exchange_received_amount(int64_t value) {
  _internal_set_exchange_received_amount(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.exchange_received_amount)
}

// int64 exchange_inject_another_amount = 19;
inline void TransactionInfo::clear_exchange_inject_another_amount() {
  exchange_inject_another_amount_ = int64_t{0};
}
inline int64_t TransactionInfo::_internal_exchange_inject_another_amount() const {
  return exchange_inject_another_amount_;
}
inline int64_t TransactionInfo::exchange_inject_another_amount() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.exchange_inject_another_amount)
  return _internal_exchange_inject_another_amount();
}
inline void TransactionInfo::_internal_set_exchange_inject_another_amount(int64_t value) {
  
  exchange_inject_another_amount_ = value;
}
inline void TransactionInfo::set_exchange_inject_another_amount(int64_t value) {
  _internal_set_exchange_inject_another_amount(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.exchange_inject_another_amount)
}

// int64 exchange_withdraw_another_amount = 20;
inline void TransactionInfo::clear_exchange_withdraw_another_amount() {
  exchange_withdraw_another_amount_ = int64_t{0};
}
inline int64_t TransactionInfo::_internal_exchange_withdraw_another_amount() const {
  return exchange_withdraw_another_amount_;
}
inline int64_t TransactionInfo::exchange_withdraw_another_amount() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.exchange_withdraw_another_amount)
  return _internal_exchange_withdraw_another_amount();
}
inline void TransactionInfo::_internal_set_exchange_withdraw_another_amount(int64_t value) {
  
  exchange_withdraw_another_amount_ = value;
}
inline void TransactionInfo::set_exchange_withdraw_another_amount(int64_t value) {
  _internal_set_exchange_withdraw_another_amount(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.exchange_withdraw_another_amount)
}

// int64 exchange_id = 21;
inline void TransactionInfo::clear_exchange_id() {
  exchange_id_ = int64_t{0};
}
inline int64_t TransactionInfo::_internal_exchange_id() const {
  return exchange_id_;
}
inline int64_t TransactionInfo::exchange_id() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.exchange_id)
  return _internal_exchange_id();
}
inline void TransactionInfo::_internal_set_exchange_id(int64_t value) {
  
  exchange_id_ = value;
}
inline void TransactionInfo::set_exchange_id(int64_t value) {
  _internal_set_exchange_id(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.exchange_id)
}

// int64 shielded_transaction_fee = 22;
inline void TransactionInfo::clear_shielded_transaction_fee() {
  shielded_transaction_fee_ = int64_t{0};
}
inline int64_t TransactionInfo::_internal_shielded_transaction_fee() const {
  return shielded_transaction_fee_;
}
inline int64_t TransactionInfo::shielded_transaction_fee() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.shielded_transaction_fee)
  return _internal_shielded_transaction_fee();
}
inline void TransactionInfo::_internal_set_shielded_transaction_fee(int64_t value) {
  
  shielded_transaction_fee_ = value;
}
inline void TransactionInfo::set_shielded_transaction_fee(int64_t value) {
  _internal_set_shielded_transaction_fee(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.shielded_transaction_fee)
}

// bytes orderId = 25;
inline void TransactionInfo::clear_orderid() {
  orderid_.ClearToEmpty();
}
inline const std::string& TransactionInfo::orderid() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.orderId)
  return _internal_orderid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionInfo::set_orderid(ArgT0&& arg0, ArgT... args) {
 
 orderid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.orderId)
}
inline std::string* TransactionInfo::mutable_orderid() {
  std::string* _s = _internal_mutable_orderid();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfo.orderId)
  return _s;
}
inline const std::string& TransactionInfo::_internal_orderid() const {
  return orderid_.Get();
}
inline void TransactionInfo::_internal_set_orderid(const std::string& value) {
  
  orderid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionInfo::_internal_mutable_orderid() {
  
  return orderid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionInfo::release_orderid() {
  // @@protoc_insertion_point(field_release:protocol.TransactionInfo.orderId)
  return orderid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionInfo::set_allocated_orderid(std::string* orderid) {
  if (orderid != nullptr) {
    
  } else {
    
  }
  orderid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), orderid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (orderid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    orderid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionInfo.orderId)
}

// repeated .protocol.MarketOrderDetail orderDetails = 26;
inline int TransactionInfo::_internal_orderdetails_size() const {
  return orderdetails_.size();
}
inline int TransactionInfo::orderdetails_size() const {
  return _internal_orderdetails_size();
}
inline void TransactionInfo::clear_orderdetails() {
  orderdetails_.Clear();
}
inline ::protocol::MarketOrderDetail* TransactionInfo::mutable_orderdetails(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionInfo.orderDetails)
  return orderdetails_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail >*
TransactionInfo::mutable_orderdetails() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionInfo.orderDetails)
  return &orderdetails_;
}
inline const ::protocol::MarketOrderDetail& TransactionInfo::_internal_orderdetails(int index) const {
  return orderdetails_.Get(index);
}
inline const ::protocol::MarketOrderDetail& TransactionInfo::orderdetails(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.orderDetails)
  return _internal_orderdetails(index);
}
inline ::protocol::MarketOrderDetail* TransactionInfo::_internal_add_orderdetails() {
  return orderdetails_.Add();
}
inline ::protocol::MarketOrderDetail* TransactionInfo::add_orderdetails() {
  ::protocol::MarketOrderDetail* _add = _internal_add_orderdetails();
  // @@protoc_insertion_point(field_add:protocol.TransactionInfo.orderDetails)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MarketOrderDetail >&
TransactionInfo::orderdetails() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionInfo.orderDetails)
  return orderdetails_;
}

// int64 packingFee = 27;
inline void TransactionInfo::clear_packingfee() {
  packingfee_ = int64_t{0};
}
inline int64_t TransactionInfo::_internal_packingfee() const {
  return packingfee_;
}
inline int64_t TransactionInfo::packingfee() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionInfo.packingFee)
  return _internal_packingfee();
}
inline void TransactionInfo::_internal_set_packingfee(int64_t value) {
  
  packingfee_ = value;
}
inline void TransactionInfo::set_packingfee(int64_t value) {
  _internal_set_packingfee(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionInfo.packingFee)
}

// -------------------------------------------------------------------

// TransactionRet

// int64 blockNumber = 1;
inline void TransactionRet::clear_blocknumber() {
  blocknumber_ = int64_t{0};
}
inline int64_t TransactionRet::_internal_blocknumber() const {
  return blocknumber_;
}
inline int64_t TransactionRet::blocknumber() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionRet.blockNumber)
  return _internal_blocknumber();
}
inline void TransactionRet::_internal_set_blocknumber(int64_t value) {
  
  blocknumber_ = value;
}
inline void TransactionRet::set_blocknumber(int64_t value) {
  _internal_set_blocknumber(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionRet.blockNumber)
}

// int64 blockTimeStamp = 2;
inline void TransactionRet::clear_blocktimestamp() {
  blocktimestamp_ = int64_t{0};
}
inline int64_t TransactionRet::_internal_blocktimestamp() const {
  return blocktimestamp_;
}
inline int64_t TransactionRet::blocktimestamp() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionRet.blockTimeStamp)
  return _internal_blocktimestamp();
}
inline void TransactionRet::_internal_set_blocktimestamp(int64_t value) {
  
  blocktimestamp_ = value;
}
inline void TransactionRet::set_blocktimestamp(int64_t value) {
  _internal_set_blocktimestamp(value);
  // @@protoc_insertion_point(field_set:protocol.TransactionRet.blockTimeStamp)
}

// repeated .protocol.TransactionInfo transactioninfo = 3;
inline int TransactionRet::_internal_transactioninfo_size() const {
  return transactioninfo_.size();
}
inline int TransactionRet::transactioninfo_size() const {
  return _internal_transactioninfo_size();
}
inline void TransactionRet::clear_transactioninfo() {
  transactioninfo_.Clear();
}
inline ::protocol::TransactionInfo* TransactionRet::mutable_transactioninfo(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionRet.transactioninfo)
  return transactioninfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo >*
TransactionRet::mutable_transactioninfo() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionRet.transactioninfo)
  return &transactioninfo_;
}
inline const ::protocol::TransactionInfo& TransactionRet::_internal_transactioninfo(int index) const {
  return transactioninfo_.Get(index);
}
inline const ::protocol::TransactionInfo& TransactionRet::transactioninfo(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionRet.transactioninfo)
  return _internal_transactioninfo(index);
}
inline ::protocol::TransactionInfo* TransactionRet::_internal_add_transactioninfo() {
  return transactioninfo_.Add();
}
inline ::protocol::TransactionInfo* TransactionRet::add_transactioninfo() {
  ::protocol::TransactionInfo* _add = _internal_add_transactioninfo();
  // @@protoc_insertion_point(field_add:protocol.TransactionRet.transactioninfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TransactionInfo >&
TransactionRet::transactioninfo() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionRet.transactioninfo)
  return transactioninfo_;
}

// -------------------------------------------------------------------

// Transactions

// repeated .protocol.Transaction transactions = 1;
inline int Transactions::_internal_transactions_size() const {
  return transactions_.size();
}
inline int Transactions::transactions_size() const {
  return _internal_transactions_size();
}
inline void Transactions::clear_transactions() {
  transactions_.Clear();
}
inline ::protocol::Transaction* Transactions::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transactions.transactions)
  return transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >*
Transactions::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transactions.transactions)
  return &transactions_;
}
inline const ::protocol::Transaction& Transactions::_internal_transactions(int index) const {
  return transactions_.Get(index);
}
inline const ::protocol::Transaction& Transactions::transactions(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transactions.transactions)
  return _internal_transactions(index);
}
inline ::protocol::Transaction* Transactions::_internal_add_transactions() {
  return transactions_.Add();
}
inline ::protocol::Transaction* Transactions::add_transactions() {
  ::protocol::Transaction* _add = _internal_add_transactions();
  // @@protoc_insertion_point(field_add:protocol.Transactions.transactions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >&
Transactions::transactions() const {
  // @@protoc_insertion_point(field_list:protocol.Transactions.transactions)
  return transactions_;
}

// -------------------------------------------------------------------

// TransactionSign

// .protocol.Transaction transaction = 1;
inline bool TransactionSign::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool TransactionSign::has_transaction() const {
  return _internal_has_transaction();
}
inline void TransactionSign::clear_transaction() {
  if (GetArenaForAllocation() == nullptr && transaction_ != nullptr) {
    delete transaction_;
  }
  transaction_ = nullptr;
}
inline const ::protocol::Transaction& TransactionSign::_internal_transaction() const {
  const ::protocol::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Transaction&>(
      ::protocol::_Transaction_default_instance_);
}
inline const ::protocol::Transaction& TransactionSign::transaction() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionSign.transaction)
  return _internal_transaction();
}
inline void TransactionSign::unsafe_arena_set_allocated_transaction(
    ::protocol::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TransactionSign.transaction)
}
inline ::protocol::Transaction* TransactionSign::release_transaction() {
  
  ::protocol::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Transaction* TransactionSign::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:protocol.TransactionSign.transaction)
  
  ::protocol::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::protocol::Transaction* TransactionSign::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::protocol::Transaction* TransactionSign::mutable_transaction() {
  ::protocol::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionSign.transaction)
  return _msg;
}
inline void TransactionSign::set_allocated_transaction(::protocol::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transaction_;
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::Transaction>::GetOwningArena(transaction);
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionSign.transaction)
}

// bytes privateKey = 2;
inline void TransactionSign::clear_privatekey() {
  privatekey_.ClearToEmpty();
}
inline const std::string& TransactionSign::privatekey() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionSign.privateKey)
  return _internal_privatekey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionSign::set_privatekey(ArgT0&& arg0, ArgT... args) {
 
 privatekey_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.TransactionSign.privateKey)
}
inline std::string* TransactionSign::mutable_privatekey() {
  std::string* _s = _internal_mutable_privatekey();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionSign.privateKey)
  return _s;
}
inline const std::string& TransactionSign::_internal_privatekey() const {
  return privatekey_.Get();
}
inline void TransactionSign::_internal_set_privatekey(const std::string& value) {
  
  privatekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionSign::_internal_mutable_privatekey() {
  
  return privatekey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionSign::release_privatekey() {
  // @@protoc_insertion_point(field_release:protocol.TransactionSign.privateKey)
  return privatekey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionSign::set_allocated_privatekey(std::string* privatekey) {
  if (privatekey != nullptr) {
    
  } else {
    
  }
  privatekey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), privatekey,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (privatekey_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    privatekey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionSign.privateKey)
}

// -------------------------------------------------------------------

// BlockHeader_raw

// int64 timestamp = 1;
inline void BlockHeader_raw::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t BlockHeader_raw::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t BlockHeader_raw::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.timestamp)
  return _internal_timestamp();
}
inline void BlockHeader_raw::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void BlockHeader_raw::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.timestamp)
}

// bytes txTrieRoot = 2;
inline void BlockHeader_raw::clear_txtrieroot() {
  txtrieroot_.ClearToEmpty();
}
inline const std::string& BlockHeader_raw::txtrieroot() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.txTrieRoot)
  return _internal_txtrieroot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader_raw::set_txtrieroot(ArgT0&& arg0, ArgT... args) {
 
 txtrieroot_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.txTrieRoot)
}
inline std::string* BlockHeader_raw::mutable_txtrieroot() {
  std::string* _s = _internal_mutable_txtrieroot();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.txTrieRoot)
  return _s;
}
inline const std::string& BlockHeader_raw::_internal_txtrieroot() const {
  return txtrieroot_.Get();
}
inline void BlockHeader_raw::_internal_set_txtrieroot(const std::string& value) {
  
  txtrieroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::_internal_mutable_txtrieroot() {
  
  return txtrieroot_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::release_txtrieroot() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.txTrieRoot)
  return txtrieroot_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockHeader_raw::set_allocated_txtrieroot(std::string* txtrieroot) {
  if (txtrieroot != nullptr) {
    
  } else {
    
  }
  txtrieroot_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), txtrieroot,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (txtrieroot_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    txtrieroot_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.txTrieRoot)
}

// bytes parentHash = 3;
inline void BlockHeader_raw::clear_parenthash() {
  parenthash_.ClearToEmpty();
}
inline const std::string& BlockHeader_raw::parenthash() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.parentHash)
  return _internal_parenthash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader_raw::set_parenthash(ArgT0&& arg0, ArgT... args) {
 
 parenthash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.parentHash)
}
inline std::string* BlockHeader_raw::mutable_parenthash() {
  std::string* _s = _internal_mutable_parenthash();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.parentHash)
  return _s;
}
inline const std::string& BlockHeader_raw::_internal_parenthash() const {
  return parenthash_.Get();
}
inline void BlockHeader_raw::_internal_set_parenthash(const std::string& value) {
  
  parenthash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::_internal_mutable_parenthash() {
  
  return parenthash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::release_parenthash() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.parentHash)
  return parenthash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockHeader_raw::set_allocated_parenthash(std::string* parenthash) {
  if (parenthash != nullptr) {
    
  } else {
    
  }
  parenthash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parenthash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parenthash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    parenthash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.parentHash)
}

// int64 number = 7;
inline void BlockHeader_raw::clear_number() {
  number_ = int64_t{0};
}
inline int64_t BlockHeader_raw::_internal_number() const {
  return number_;
}
inline int64_t BlockHeader_raw::number() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.number)
  return _internal_number();
}
inline void BlockHeader_raw::_internal_set_number(int64_t value) {
  
  number_ = value;
}
inline void BlockHeader_raw::set_number(int64_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.number)
}

// int64 witness_id = 8;
inline void BlockHeader_raw::clear_witness_id() {
  witness_id_ = int64_t{0};
}
inline int64_t BlockHeader_raw::_internal_witness_id() const {
  return witness_id_;
}
inline int64_t BlockHeader_raw::witness_id() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.witness_id)
  return _internal_witness_id();
}
inline void BlockHeader_raw::_internal_set_witness_id(int64_t value) {
  
  witness_id_ = value;
}
inline void BlockHeader_raw::set_witness_id(int64_t value) {
  _internal_set_witness_id(value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.witness_id)
}

// bytes witness_address = 9;
inline void BlockHeader_raw::clear_witness_address() {
  witness_address_.ClearToEmpty();
}
inline const std::string& BlockHeader_raw::witness_address() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.witness_address)
  return _internal_witness_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader_raw::set_witness_address(ArgT0&& arg0, ArgT... args) {
 
 witness_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.witness_address)
}
inline std::string* BlockHeader_raw::mutable_witness_address() {
  std::string* _s = _internal_mutable_witness_address();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.witness_address)
  return _s;
}
inline const std::string& BlockHeader_raw::_internal_witness_address() const {
  return witness_address_.Get();
}
inline void BlockHeader_raw::_internal_set_witness_address(const std::string& value) {
  
  witness_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::_internal_mutable_witness_address() {
  
  return witness_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::release_witness_address() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.witness_address)
  return witness_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockHeader_raw::set_allocated_witness_address(std::string* witness_address) {
  if (witness_address != nullptr) {
    
  } else {
    
  }
  witness_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), witness_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (witness_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    witness_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.witness_address)
}

// int32 version = 10;
inline void BlockHeader_raw::clear_version() {
  version_ = 0;
}
inline int32_t BlockHeader_raw::_internal_version() const {
  return version_;
}
inline int32_t BlockHeader_raw::version() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.version)
  return _internal_version();
}
inline void BlockHeader_raw::_internal_set_version(int32_t value) {
  
  version_ = value;
}
inline void BlockHeader_raw::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.version)
}

// bytes accountStateRoot = 11;
inline void BlockHeader_raw::clear_accountstateroot() {
  accountstateroot_.ClearToEmpty();
}
inline const std::string& BlockHeader_raw::accountstateroot() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.accountStateRoot)
  return _internal_accountstateroot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader_raw::set_accountstateroot(ArgT0&& arg0, ArgT... args) {
 
 accountstateroot_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.accountStateRoot)
}
inline std::string* BlockHeader_raw::mutable_accountstateroot() {
  std::string* _s = _internal_mutable_accountstateroot();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.accountStateRoot)
  return _s;
}
inline const std::string& BlockHeader_raw::_internal_accountstateroot() const {
  return accountstateroot_.Get();
}
inline void BlockHeader_raw::_internal_set_accountstateroot(const std::string& value) {
  
  accountstateroot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::_internal_mutable_accountstateroot() {
  
  return accountstateroot_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockHeader_raw::release_accountstateroot() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.accountStateRoot)
  return accountstateroot_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockHeader_raw::set_allocated_accountstateroot(std::string* accountstateroot) {
  if (accountstateroot != nullptr) {
    
  } else {
    
  }
  accountstateroot_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), accountstateroot,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (accountstateroot_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    accountstateroot_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.accountStateRoot)
}

// -------------------------------------------------------------------

// BlockHeader

// .protocol.BlockHeader.raw raw_data = 1;
inline bool BlockHeader::_internal_has_raw_data() const {
  return this != internal_default_instance() && raw_data_ != nullptr;
}
inline bool BlockHeader::has_raw_data() const {
  return _internal_has_raw_data();
}
inline void BlockHeader::clear_raw_data() {
  if (GetArenaForAllocation() == nullptr && raw_data_ != nullptr) {
    delete raw_data_;
  }
  raw_data_ = nullptr;
}
inline const ::protocol::BlockHeader_raw& BlockHeader::_internal_raw_data() const {
  const ::protocol::BlockHeader_raw* p = raw_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::BlockHeader_raw&>(
      ::protocol::_BlockHeader_raw_default_instance_);
}
inline const ::protocol::BlockHeader_raw& BlockHeader::raw_data() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw_data)
  return _internal_raw_data();
}
inline void BlockHeader::unsafe_arena_set_allocated_raw_data(
    ::protocol::BlockHeader_raw* raw_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_data_);
  }
  raw_data_ = raw_data;
  if (raw_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.BlockHeader.raw_data)
}
inline ::protocol::BlockHeader_raw* BlockHeader::release_raw_data() {
  
  ::protocol::BlockHeader_raw* temp = raw_data_;
  raw_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::BlockHeader_raw* BlockHeader::unsafe_arena_release_raw_data() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw_data)
  
  ::protocol::BlockHeader_raw* temp = raw_data_;
  raw_data_ = nullptr;
  return temp;
}
inline ::protocol::BlockHeader_raw* BlockHeader::_internal_mutable_raw_data() {
  
  if (raw_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::BlockHeader_raw>(GetArenaForAllocation());
    raw_data_ = p;
  }
  return raw_data_;
}
inline ::protocol::BlockHeader_raw* BlockHeader::mutable_raw_data() {
  ::protocol::BlockHeader_raw* _msg = _internal_mutable_raw_data();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw_data)
  return _msg;
}
inline void BlockHeader::set_allocated_raw_data(::protocol::BlockHeader_raw* raw_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete raw_data_;
  }
  if (raw_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::BlockHeader_raw>::GetOwningArena(raw_data);
    if (message_arena != submessage_arena) {
      raw_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    
  } else {
    
  }
  raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw_data)
}

// bytes witness_signature = 2;
inline void BlockHeader::clear_witness_signature() {
  witness_signature_.ClearToEmpty();
}
inline const std::string& BlockHeader::witness_signature() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.witness_signature)
  return _internal_witness_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader::set_witness_signature(ArgT0&& arg0, ArgT... args) {
 
 witness_signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.witness_signature)
}
inline std::string* BlockHeader::mutable_witness_signature() {
  std::string* _s = _internal_mutable_witness_signature();
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.witness_signature)
  return _s;
}
inline const std::string& BlockHeader::_internal_witness_signature() const {
  return witness_signature_.Get();
}
inline void BlockHeader::_internal_set_witness_signature(const std::string& value) {
  
  witness_signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockHeader::_internal_mutable_witness_signature() {
  
  return witness_signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockHeader::release_witness_signature() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.witness_signature)
  return witness_signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockHeader::set_allocated_witness_signature(std::string* witness_signature) {
  if (witness_signature != nullptr) {
    
  } else {
    
  }
  witness_signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), witness_signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (witness_signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    witness_signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.witness_signature)
}

// -------------------------------------------------------------------

// Block

// repeated .protocol.Transaction transactions = 1;
inline int Block::_internal_transactions_size() const {
  return transactions_.size();
}
inline int Block::transactions_size() const {
  return _internal_transactions_size();
}
inline void Block::clear_transactions() {
  transactions_.Clear();
}
inline ::protocol::Transaction* Block::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Block.transactions)
  return transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >*
Block::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Block.transactions)
  return &transactions_;
}
inline const ::protocol::Transaction& Block::_internal_transactions(int index) const {
  return transactions_.Get(index);
}
inline const ::protocol::Transaction& Block::transactions(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Block.transactions)
  return _internal_transactions(index);
}
inline ::protocol::Transaction* Block::_internal_add_transactions() {
  return transactions_.Add();
}
inline ::protocol::Transaction* Block::add_transactions() {
  ::protocol::Transaction* _add = _internal_add_transactions();
  // @@protoc_insertion_point(field_add:protocol.Block.transactions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >&
Block::transactions() const {
  // @@protoc_insertion_point(field_list:protocol.Block.transactions)
  return transactions_;
}

// .protocol.BlockHeader block_header = 2;
inline bool Block::_internal_has_block_header() const {
  return this != internal_default_instance() && block_header_ != nullptr;
}
inline bool Block::has_block_header() const {
  return _internal_has_block_header();
}
inline void Block::clear_block_header() {
  if (GetArenaForAllocation() == nullptr && block_header_ != nullptr) {
    delete block_header_;
  }
  block_header_ = nullptr;
}
inline const ::protocol::BlockHeader& Block::_internal_block_header() const {
  const ::protocol::BlockHeader* p = block_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::BlockHeader&>(
      ::protocol::_BlockHeader_default_instance_);
}
inline const ::protocol::BlockHeader& Block::block_header() const {
  // @@protoc_insertion_point(field_get:protocol.Block.block_header)
  return _internal_block_header();
}
inline void Block::unsafe_arena_set_allocated_block_header(
    ::protocol::BlockHeader* block_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_header_);
  }
  block_header_ = block_header;
  if (block_header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.Block.block_header)
}
inline ::protocol::BlockHeader* Block::release_block_header() {
  
  ::protocol::BlockHeader* temp = block_header_;
  block_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::BlockHeader* Block::unsafe_arena_release_block_header() {
  // @@protoc_insertion_point(field_release:protocol.Block.block_header)
  
  ::protocol::BlockHeader* temp = block_header_;
  block_header_ = nullptr;
  return temp;
}
inline ::protocol::BlockHeader* Block::_internal_mutable_block_header() {
  
  if (block_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::BlockHeader>(GetArenaForAllocation());
    block_header_ = p;
  }
  return block_header_;
}
inline ::protocol::BlockHeader* Block::mutable_block_header() {
  ::protocol::BlockHeader* _msg = _internal_mutable_block_header();
  // @@protoc_insertion_point(field_mutable:protocol.Block.block_header)
  return _msg;
}
inline void Block::set_allocated_block_header(::protocol::BlockHeader* block_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete block_header_;
  }
  if (block_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::BlockHeader>::GetOwningArena(block_header);
    if (message_arena != submessage_arena) {
      block_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_header, submessage_arena);
    }
    
  } else {
    
  }
  block_header_ = block_header;
  // @@protoc_insertion_point(field_set_allocated:protocol.Block.block_header)
}

// -------------------------------------------------------------------

// ChainInventory_BlockId

// bytes hash = 1;
inline void ChainInventory_BlockId::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& ChainInventory_BlockId::hash() const {
  // @@protoc_insertion_point(field_get:protocol.ChainInventory.BlockId.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChainInventory_BlockId::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.ChainInventory.BlockId.hash)
}
inline std::string* ChainInventory_BlockId::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:protocol.ChainInventory.BlockId.hash)
  return _s;
}
inline const std::string& ChainInventory_BlockId::_internal_hash() const {
  return hash_.Get();
}
inline void ChainInventory_BlockId::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChainInventory_BlockId::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChainInventory_BlockId::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.ChainInventory.BlockId.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChainInventory_BlockId::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainInventory.BlockId.hash)
}

// int64 number = 2;
inline void ChainInventory_BlockId::clear_number() {
  number_ = int64_t{0};
}
inline int64_t ChainInventory_BlockId::_internal_number() const {
  return number_;
}
inline int64_t ChainInventory_BlockId::number() const {
  // @@protoc_insertion_point(field_get:protocol.ChainInventory.BlockId.number)
  return _internal_number();
}
inline void ChainInventory_BlockId::_internal_set_number(int64_t value) {
  
  number_ = value;
}
inline void ChainInventory_BlockId::set_number(int64_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:protocol.ChainInventory.BlockId.number)
}

// -------------------------------------------------------------------

// ChainInventory

// repeated .protocol.ChainInventory.BlockId ids = 1;
inline int ChainInventory::_internal_ids_size() const {
  return ids_.size();
}
inline int ChainInventory::ids_size() const {
  return _internal_ids_size();
}
inline void ChainInventory::clear_ids() {
  ids_.Clear();
}
inline ::protocol::ChainInventory_BlockId* ChainInventory::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ChainInventory.ids)
  return ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ChainInventory_BlockId >*
ChainInventory::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ChainInventory.ids)
  return &ids_;
}
inline const ::protocol::ChainInventory_BlockId& ChainInventory::_internal_ids(int index) const {
  return ids_.Get(index);
}
inline const ::protocol::ChainInventory_BlockId& ChainInventory::ids(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ChainInventory.ids)
  return _internal_ids(index);
}
inline ::protocol::ChainInventory_BlockId* ChainInventory::_internal_add_ids() {
  return ids_.Add();
}
inline ::protocol::ChainInventory_BlockId* ChainInventory::add_ids() {
  ::protocol::ChainInventory_BlockId* _add = _internal_add_ids();
  // @@protoc_insertion_point(field_add:protocol.ChainInventory.ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ChainInventory_BlockId >&
ChainInventory::ids() const {
  // @@protoc_insertion_point(field_list:protocol.ChainInventory.ids)
  return ids_;
}

// int64 remain_num = 2;
inline void ChainInventory::clear_remain_num() {
  remain_num_ = int64_t{0};
}
inline int64_t ChainInventory::_internal_remain_num() const {
  return remain_num_;
}
inline int64_t ChainInventory::remain_num() const {
  // @@protoc_insertion_point(field_get:protocol.ChainInventory.remain_num)
  return _internal_remain_num();
}
inline void ChainInventory::_internal_set_remain_num(int64_t value) {
  
  remain_num_ = value;
}
inline void ChainInventory::set_remain_num(int64_t value) {
  _internal_set_remain_num(value);
  // @@protoc_insertion_point(field_set:protocol.ChainInventory.remain_num)
}

// -------------------------------------------------------------------

// BlockInventory_BlockId

// bytes hash = 1;
inline void BlockInventory_BlockId::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& BlockInventory_BlockId::hash() const {
  // @@protoc_insertion_point(field_get:protocol.BlockInventory.BlockId.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockInventory_BlockId::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.BlockInventory.BlockId.hash)
}
inline std::string* BlockInventory_BlockId::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:protocol.BlockInventory.BlockId.hash)
  return _s;
}
inline const std::string& BlockInventory_BlockId::_internal_hash() const {
  return hash_.Get();
}
inline void BlockInventory_BlockId::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockInventory_BlockId::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockInventory_BlockId::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.BlockInventory.BlockId.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockInventory_BlockId::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockInventory.BlockId.hash)
}

// int64 number = 2;
inline void BlockInventory_BlockId::clear_number() {
  number_ = int64_t{0};
}
inline int64_t BlockInventory_BlockId::_internal_number() const {
  return number_;
}
inline int64_t BlockInventory_BlockId::number() const {
  // @@protoc_insertion_point(field_get:protocol.BlockInventory.BlockId.number)
  return _internal_number();
}
inline void BlockInventory_BlockId::_internal_set_number(int64_t value) {
  
  number_ = value;
}
inline void BlockInventory_BlockId::set_number(int64_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:protocol.BlockInventory.BlockId.number)
}

// -------------------------------------------------------------------

// BlockInventory

// repeated .protocol.BlockInventory.BlockId ids = 1;
inline int BlockInventory::_internal_ids_size() const {
  return ids_.size();
}
inline int BlockInventory::ids_size() const {
  return _internal_ids_size();
}
inline void BlockInventory::clear_ids() {
  ids_.Clear();
}
inline ::protocol::BlockInventory_BlockId* BlockInventory::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.BlockInventory.ids)
  return ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockInventory_BlockId >*
BlockInventory::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:protocol.BlockInventory.ids)
  return &ids_;
}
inline const ::protocol::BlockInventory_BlockId& BlockInventory::_internal_ids(int index) const {
  return ids_.Get(index);
}
inline const ::protocol::BlockInventory_BlockId& BlockInventory::ids(int index) const {
  // @@protoc_insertion_point(field_get:protocol.BlockInventory.ids)
  return _internal_ids(index);
}
inline ::protocol::BlockInventory_BlockId* BlockInventory::_internal_add_ids() {
  return ids_.Add();
}
inline ::protocol::BlockInventory_BlockId* BlockInventory::add_ids() {
  ::protocol::BlockInventory_BlockId* _add = _internal_add_ids();
  // @@protoc_insertion_point(field_add:protocol.BlockInventory.ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockInventory_BlockId >&
BlockInventory::ids() const {
  // @@protoc_insertion_point(field_list:protocol.BlockInventory.ids)
  return ids_;
}

// .protocol.BlockInventory.Type type = 2;
inline void BlockInventory::clear_type() {
  type_ = 0;
}
inline ::protocol::BlockInventory_Type BlockInventory::_internal_type() const {
  return static_cast< ::protocol::BlockInventory_Type >(type_);
}
inline ::protocol::BlockInventory_Type BlockInventory::type() const {
  // @@protoc_insertion_point(field_get:protocol.BlockInventory.type)
  return _internal_type();
}
inline void BlockInventory::_internal_set_type(::protocol::BlockInventory_Type value) {
  
  type_ = value;
}
inline void BlockInventory::set_type(::protocol::BlockInventory_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.BlockInventory.type)
}

// -------------------------------------------------------------------

// Inventory

// .protocol.Inventory.InventoryType type = 1;
inline void Inventory::clear_type() {
  type_ = 0;
}
inline ::protocol::Inventory_InventoryType Inventory::_internal_type() const {
  return static_cast< ::protocol::Inventory_InventoryType >(type_);
}
inline ::protocol::Inventory_InventoryType Inventory::type() const {
  // @@protoc_insertion_point(field_get:protocol.Inventory.type)
  return _internal_type();
}
inline void Inventory::_internal_set_type(::protocol::Inventory_InventoryType value) {
  
  type_ = value;
}
inline void Inventory::set_type(::protocol::Inventory_InventoryType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.Inventory.type)
}

// repeated bytes ids = 2;
inline int Inventory::_internal_ids_size() const {
  return ids_.size();
}
inline int Inventory::ids_size() const {
  return _internal_ids_size();
}
inline void Inventory::clear_ids() {
  ids_.Clear();
}
inline std::string* Inventory::add_ids() {
  std::string* _s = _internal_add_ids();
  // @@protoc_insertion_point(field_add_mutable:protocol.Inventory.ids)
  return _s;
}
inline const std::string& Inventory::_internal_ids(int index) const {
  return ids_.Get(index);
}
inline const std::string& Inventory::ids(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Inventory.ids)
  return _internal_ids(index);
}
inline std::string* Inventory::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Inventory.ids)
  return ids_.Mutable(index);
}
inline void Inventory::set_ids(int index, const std::string& value) {
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.Inventory.ids)
}
inline void Inventory::set_ids(int index, std::string&& value) {
  ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.Inventory.ids)
}
inline void Inventory::set_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.Inventory.ids)
}
inline void Inventory::set_ids(int index, const void* value, size_t size) {
  ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.Inventory.ids)
}
inline std::string* Inventory::_internal_add_ids() {
  return ids_.Add();
}
inline void Inventory::add_ids(const std::string& value) {
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.Inventory.ids)
}
inline void Inventory::add_ids(std::string&& value) {
  ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.Inventory.ids)
}
inline void Inventory::add_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.Inventory.ids)
}
inline void Inventory::add_ids(const void* value, size_t size) {
  ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.Inventory.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Inventory::ids() const {
  // @@protoc_insertion_point(field_list:protocol.Inventory.ids)
  return ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Inventory::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Inventory.ids)
  return &ids_;
}

// -------------------------------------------------------------------

// Items

// .protocol.Items.ItemType type = 1;
inline void Items::clear_type() {
  type_ = 0;
}
inline ::protocol::Items_ItemType Items::_internal_type() const {
  return static_cast< ::protocol::Items_ItemType >(type_);
}
inline ::protocol::Items_ItemType Items::type() const {
  // @@protoc_insertion_point(field_get:protocol.Items.type)
  return _internal_type();
}
inline void Items::_internal_set_type(::protocol::Items_ItemType value) {
  
  type_ = value;
}
inline void Items::set_type(::protocol::Items_ItemType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.Items.type)
}

// repeated .protocol.Block blocks = 2;
inline int Items::_internal_blocks_size() const {
  return blocks_.size();
}
inline int Items::blocks_size() const {
  return _internal_blocks_size();
}
inline void Items::clear_blocks() {
  blocks_.Clear();
}
inline ::protocol::Block* Items::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Items.blocks)
  return blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Block >*
Items::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Items.blocks)
  return &blocks_;
}
inline const ::protocol::Block& Items::_internal_blocks(int index) const {
  return blocks_.Get(index);
}
inline const ::protocol::Block& Items::blocks(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Items.blocks)
  return _internal_blocks(index);
}
inline ::protocol::Block* Items::_internal_add_blocks() {
  return blocks_.Add();
}
inline ::protocol::Block* Items::add_blocks() {
  ::protocol::Block* _add = _internal_add_blocks();
  // @@protoc_insertion_point(field_add:protocol.Items.blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Block >&
Items::blocks() const {
  // @@protoc_insertion_point(field_list:protocol.Items.blocks)
  return blocks_;
}

// repeated .protocol.BlockHeader block_headers = 3;
inline int Items::_internal_block_headers_size() const {
  return block_headers_.size();
}
inline int Items::block_headers_size() const {
  return _internal_block_headers_size();
}
inline void Items::clear_block_headers() {
  block_headers_.Clear();
}
inline ::protocol::BlockHeader* Items::mutable_block_headers(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Items.block_headers)
  return block_headers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockHeader >*
Items::mutable_block_headers() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Items.block_headers)
  return &block_headers_;
}
inline const ::protocol::BlockHeader& Items::_internal_block_headers(int index) const {
  return block_headers_.Get(index);
}
inline const ::protocol::BlockHeader& Items::block_headers(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Items.block_headers)
  return _internal_block_headers(index);
}
inline ::protocol::BlockHeader* Items::_internal_add_block_headers() {
  return block_headers_.Add();
}
inline ::protocol::BlockHeader* Items::add_block_headers() {
  ::protocol::BlockHeader* _add = _internal_add_block_headers();
  // @@protoc_insertion_point(field_add:protocol.Items.block_headers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::BlockHeader >&
Items::block_headers() const {
  // @@protoc_insertion_point(field_list:protocol.Items.block_headers)
  return block_headers_;
}

// repeated .protocol.Transaction transactions = 4;
inline int Items::_internal_transactions_size() const {
  return transactions_.size();
}
inline int Items::transactions_size() const {
  return _internal_transactions_size();
}
inline void Items::clear_transactions() {
  transactions_.Clear();
}
inline ::protocol::Transaction* Items::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Items.transactions)
  return transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >*
Items::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Items.transactions)
  return &transactions_;
}
inline const ::protocol::Transaction& Items::_internal_transactions(int index) const {
  return transactions_.Get(index);
}
inline const ::protocol::Transaction& Items::transactions(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Items.transactions)
  return _internal_transactions(index);
}
inline ::protocol::Transaction* Items::_internal_add_transactions() {
  return transactions_.Add();
}
inline ::protocol::Transaction* Items::add_transactions() {
  ::protocol::Transaction* _add = _internal_add_transactions();
  // @@protoc_insertion_point(field_add:protocol.Items.transactions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::Transaction >&
Items::transactions() const {
  // @@protoc_insertion_point(field_list:protocol.Items.transactions)
  return transactions_;
}

// -------------------------------------------------------------------

// DynamicProperties

// int64 last_solidity_block_num = 1;
inline void DynamicProperties::clear_last_solidity_block_num() {
  last_solidity_block_num_ = int64_t{0};
}
inline int64_t DynamicProperties::_internal_last_solidity_block_num() const {
  return last_solidity_block_num_;
}
inline int64_t DynamicProperties::last_solidity_block_num() const {
  // @@protoc_insertion_point(field_get:protocol.DynamicProperties.last_solidity_block_num)
  return _internal_last_solidity_block_num();
}
inline void DynamicProperties::_internal_set_last_solidity_block_num(int64_t value) {
  
  last_solidity_block_num_ = value;
}
inline void DynamicProperties::set_last_solidity_block_num(int64_t value) {
  _internal_set_last_solidity_block_num(value);
  // @@protoc_insertion_point(field_set:protocol.DynamicProperties.last_solidity_block_num)
}

// -------------------------------------------------------------------

// DisconnectMessage

// .protocol.ReasonCode reason = 1;
inline void DisconnectMessage::clear_reason() {
  reason_ = 0;
}
inline ::protocol::ReasonCode DisconnectMessage::_internal_reason() const {
  return static_cast< ::protocol::ReasonCode >(reason_);
}
inline ::protocol::ReasonCode DisconnectMessage::reason() const {
  // @@protoc_insertion_point(field_get:protocol.DisconnectMessage.reason)
  return _internal_reason();
}
inline void DisconnectMessage::_internal_set_reason(::protocol::ReasonCode value) {
  
  reason_ = value;
}
inline void DisconnectMessage::set_reason(::protocol::ReasonCode value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:protocol.DisconnectMessage.reason)
}

// -------------------------------------------------------------------

// HelloMessage_BlockId

// bytes hash = 1;
inline void HelloMessage_BlockId::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& HelloMessage_BlockId::hash() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.BlockId.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloMessage_BlockId::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.HelloMessage.BlockId.hash)
}
inline std::string* HelloMessage_BlockId::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:protocol.HelloMessage.BlockId.hash)
  return _s;
}
inline const std::string& HelloMessage_BlockId::_internal_hash() const {
  return hash_.Get();
}
inline void HelloMessage_BlockId::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HelloMessage_BlockId::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HelloMessage_BlockId::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.HelloMessage.BlockId.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HelloMessage_BlockId::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.HelloMessage.BlockId.hash)
}

// int64 number = 2;
inline void HelloMessage_BlockId::clear_number() {
  number_ = int64_t{0};
}
inline int64_t HelloMessage_BlockId::_internal_number() const {
  return number_;
}
inline int64_t HelloMessage_BlockId::number() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.BlockId.number)
  return _internal_number();
}
inline void HelloMessage_BlockId::_internal_set_number(int64_t value) {
  
  number_ = value;
}
inline void HelloMessage_BlockId::set_number(int64_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:protocol.HelloMessage.BlockId.number)
}

// -------------------------------------------------------------------

// HelloMessage

// .protocol.Endpoint from = 1;
inline bool HelloMessage::_internal_has_from() const {
  return this != internal_default_instance() && from_ != nullptr;
}
inline bool HelloMessage::has_from() const {
  return _internal_has_from();
}
inline const ::protocol::Endpoint& HelloMessage::_internal_from() const {
  const ::protocol::Endpoint* p = from_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::Endpoint&>(
      ::protocol::_Endpoint_default_instance_);
}
inline const ::protocol::Endpoint& HelloMessage::from() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.from)
  return _internal_from();
}
inline void HelloMessage::unsafe_arena_set_allocated_from(
    ::protocol::Endpoint* from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from_);
  }
  from_ = from;
  if (from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.HelloMessage.from)
}
inline ::protocol::Endpoint* HelloMessage::release_from() {
  
  ::protocol::Endpoint* temp = from_;
  from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::Endpoint* HelloMessage::unsafe_arena_release_from() {
  // @@protoc_insertion_point(field_release:protocol.HelloMessage.from)
  
  ::protocol::Endpoint* temp = from_;
  from_ = nullptr;
  return temp;
}
inline ::protocol::Endpoint* HelloMessage::_internal_mutable_from() {
  
  if (from_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Endpoint>(GetArenaForAllocation());
    from_ = p;
  }
  return from_;
}
inline ::protocol::Endpoint* HelloMessage::mutable_from() {
  ::protocol::Endpoint* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:protocol.HelloMessage.from)
  return _msg;
}
inline void HelloMessage::set_allocated_from(::protocol::Endpoint* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(from_);
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from));
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  from_ = from;
  // @@protoc_insertion_point(field_set_allocated:protocol.HelloMessage.from)
}

// int32 version = 2;
inline void HelloMessage::clear_version() {
  version_ = 0;
}
inline int32_t HelloMessage::_internal_version() const {
  return version_;
}
inline int32_t HelloMessage::version() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.version)
  return _internal_version();
}
inline void HelloMessage::_internal_set_version(int32_t value) {
  
  version_ = value;
}
inline void HelloMessage::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:protocol.HelloMessage.version)
}

// int64 timestamp = 3;
inline void HelloMessage::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t HelloMessage::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t HelloMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.timestamp)
  return _internal_timestamp();
}
inline void HelloMessage::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void HelloMessage::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:protocol.HelloMessage.timestamp)
}

// .protocol.HelloMessage.BlockId genesisBlockId = 4;
inline bool HelloMessage::_internal_has_genesisblockid() const {
  return this != internal_default_instance() && genesisblockid_ != nullptr;
}
inline bool HelloMessage::has_genesisblockid() const {
  return _internal_has_genesisblockid();
}
inline void HelloMessage::clear_genesisblockid() {
  if (GetArenaForAllocation() == nullptr && genesisblockid_ != nullptr) {
    delete genesisblockid_;
  }
  genesisblockid_ = nullptr;
}
inline const ::protocol::HelloMessage_BlockId& HelloMessage::_internal_genesisblockid() const {
  const ::protocol::HelloMessage_BlockId* p = genesisblockid_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::HelloMessage_BlockId&>(
      ::protocol::_HelloMessage_BlockId_default_instance_);
}
inline const ::protocol::HelloMessage_BlockId& HelloMessage::genesisblockid() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.genesisBlockId)
  return _internal_genesisblockid();
}
inline void HelloMessage::unsafe_arena_set_allocated_genesisblockid(
    ::protocol::HelloMessage_BlockId* genesisblockid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(genesisblockid_);
  }
  genesisblockid_ = genesisblockid;
  if (genesisblockid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.HelloMessage.genesisBlockId)
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::release_genesisblockid() {
  
  ::protocol::HelloMessage_BlockId* temp = genesisblockid_;
  genesisblockid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::unsafe_arena_release_genesisblockid() {
  // @@protoc_insertion_point(field_release:protocol.HelloMessage.genesisBlockId)
  
  ::protocol::HelloMessage_BlockId* temp = genesisblockid_;
  genesisblockid_ = nullptr;
  return temp;
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::_internal_mutable_genesisblockid() {
  
  if (genesisblockid_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::HelloMessage_BlockId>(GetArenaForAllocation());
    genesisblockid_ = p;
  }
  return genesisblockid_;
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::mutable_genesisblockid() {
  ::protocol::HelloMessage_BlockId* _msg = _internal_mutable_genesisblockid();
  // @@protoc_insertion_point(field_mutable:protocol.HelloMessage.genesisBlockId)
  return _msg;
}
inline void HelloMessage::set_allocated_genesisblockid(::protocol::HelloMessage_BlockId* genesisblockid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete genesisblockid_;
  }
  if (genesisblockid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::HelloMessage_BlockId>::GetOwningArena(genesisblockid);
    if (message_arena != submessage_arena) {
      genesisblockid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, genesisblockid, submessage_arena);
    }
    
  } else {
    
  }
  genesisblockid_ = genesisblockid;
  // @@protoc_insertion_point(field_set_allocated:protocol.HelloMessage.genesisBlockId)
}

// .protocol.HelloMessage.BlockId solidBlockId = 5;
inline bool HelloMessage::_internal_has_solidblockid() const {
  return this != internal_default_instance() && solidblockid_ != nullptr;
}
inline bool HelloMessage::has_solidblockid() const {
  return _internal_has_solidblockid();
}
inline void HelloMessage::clear_solidblockid() {
  if (GetArenaForAllocation() == nullptr && solidblockid_ != nullptr) {
    delete solidblockid_;
  }
  solidblockid_ = nullptr;
}
inline const ::protocol::HelloMessage_BlockId& HelloMessage::_internal_solidblockid() const {
  const ::protocol::HelloMessage_BlockId* p = solidblockid_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::HelloMessage_BlockId&>(
      ::protocol::_HelloMessage_BlockId_default_instance_);
}
inline const ::protocol::HelloMessage_BlockId& HelloMessage::solidblockid() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.solidBlockId)
  return _internal_solidblockid();
}
inline void HelloMessage::unsafe_arena_set_allocated_solidblockid(
    ::protocol::HelloMessage_BlockId* solidblockid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(solidblockid_);
  }
  solidblockid_ = solidblockid;
  if (solidblockid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.HelloMessage.solidBlockId)
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::release_solidblockid() {
  
  ::protocol::HelloMessage_BlockId* temp = solidblockid_;
  solidblockid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::unsafe_arena_release_solidblockid() {
  // @@protoc_insertion_point(field_release:protocol.HelloMessage.solidBlockId)
  
  ::protocol::HelloMessage_BlockId* temp = solidblockid_;
  solidblockid_ = nullptr;
  return temp;
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::_internal_mutable_solidblockid() {
  
  if (solidblockid_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::HelloMessage_BlockId>(GetArenaForAllocation());
    solidblockid_ = p;
  }
  return solidblockid_;
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::mutable_solidblockid() {
  ::protocol::HelloMessage_BlockId* _msg = _internal_mutable_solidblockid();
  // @@protoc_insertion_point(field_mutable:protocol.HelloMessage.solidBlockId)
  return _msg;
}
inline void HelloMessage::set_allocated_solidblockid(::protocol::HelloMessage_BlockId* solidblockid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete solidblockid_;
  }
  if (solidblockid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::HelloMessage_BlockId>::GetOwningArena(solidblockid);
    if (message_arena != submessage_arena) {
      solidblockid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, solidblockid, submessage_arena);
    }
    
  } else {
    
  }
  solidblockid_ = solidblockid;
  // @@protoc_insertion_point(field_set_allocated:protocol.HelloMessage.solidBlockId)
}

// .protocol.HelloMessage.BlockId headBlockId = 6;
inline bool HelloMessage::_internal_has_headblockid() const {
  return this != internal_default_instance() && headblockid_ != nullptr;
}
inline bool HelloMessage::has_headblockid() const {
  return _internal_has_headblockid();
}
inline void HelloMessage::clear_headblockid() {
  if (GetArenaForAllocation() == nullptr && headblockid_ != nullptr) {
    delete headblockid_;
  }
  headblockid_ = nullptr;
}
inline const ::protocol::HelloMessage_BlockId& HelloMessage::_internal_headblockid() const {
  const ::protocol::HelloMessage_BlockId* p = headblockid_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::HelloMessage_BlockId&>(
      ::protocol::_HelloMessage_BlockId_default_instance_);
}
inline const ::protocol::HelloMessage_BlockId& HelloMessage::headblockid() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.headBlockId)
  return _internal_headblockid();
}
inline void HelloMessage::unsafe_arena_set_allocated_headblockid(
    ::protocol::HelloMessage_BlockId* headblockid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(headblockid_);
  }
  headblockid_ = headblockid;
  if (headblockid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.HelloMessage.headBlockId)
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::release_headblockid() {
  
  ::protocol::HelloMessage_BlockId* temp = headblockid_;
  headblockid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::unsafe_arena_release_headblockid() {
  // @@protoc_insertion_point(field_release:protocol.HelloMessage.headBlockId)
  
  ::protocol::HelloMessage_BlockId* temp = headblockid_;
  headblockid_ = nullptr;
  return temp;
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::_internal_mutable_headblockid() {
  
  if (headblockid_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::HelloMessage_BlockId>(GetArenaForAllocation());
    headblockid_ = p;
  }
  return headblockid_;
}
inline ::protocol::HelloMessage_BlockId* HelloMessage::mutable_headblockid() {
  ::protocol::HelloMessage_BlockId* _msg = _internal_mutable_headblockid();
  // @@protoc_insertion_point(field_mutable:protocol.HelloMessage.headBlockId)
  return _msg;
}
inline void HelloMessage::set_allocated_headblockid(::protocol::HelloMessage_BlockId* headblockid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete headblockid_;
  }
  if (headblockid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::HelloMessage_BlockId>::GetOwningArena(headblockid);
    if (message_arena != submessage_arena) {
      headblockid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, headblockid, submessage_arena);
    }
    
  } else {
    
  }
  headblockid_ = headblockid;
  // @@protoc_insertion_point(field_set_allocated:protocol.HelloMessage.headBlockId)
}

// bytes address = 7;
inline void HelloMessage::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& HelloMessage::address() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloMessage::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.HelloMessage.address)
}
inline std::string* HelloMessage::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.HelloMessage.address)
  return _s;
}
inline const std::string& HelloMessage::_internal_address() const {
  return address_.Get();
}
inline void HelloMessage::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HelloMessage::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HelloMessage::release_address() {
  // @@protoc_insertion_point(field_release:protocol.HelloMessage.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HelloMessage::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.HelloMessage.address)
}

// bytes signature = 8;
inline void HelloMessage::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& HelloMessage::signature() const {
  // @@protoc_insertion_point(field_get:protocol.HelloMessage.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloMessage::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.HelloMessage.signature)
}
inline std::string* HelloMessage::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:protocol.HelloMessage.signature)
  return _s;
}
inline const std::string& HelloMessage::_internal_signature() const {
  return signature_.Get();
}
inline void HelloMessage::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HelloMessage::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HelloMessage::release_signature() {
  // @@protoc_insertion_point(field_release:protocol.HelloMessage.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HelloMessage::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.HelloMessage.signature)
}

// -------------------------------------------------------------------

// InternalTransaction_CallValueInfo

// int64 callValue = 1;
inline void InternalTransaction_CallValueInfo::clear_callvalue() {
  callvalue_ = int64_t{0};
}
inline int64_t InternalTransaction_CallValueInfo::_internal_callvalue() const {
  return callvalue_;
}
inline int64_t InternalTransaction_CallValueInfo::callvalue() const {
  // @@protoc_insertion_point(field_get:protocol.InternalTransaction.CallValueInfo.callValue)
  return _internal_callvalue();
}
inline void InternalTransaction_CallValueInfo::_internal_set_callvalue(int64_t value) {
  
  callvalue_ = value;
}
inline void InternalTransaction_CallValueInfo::set_callvalue(int64_t value) {
  _internal_set_callvalue(value);
  // @@protoc_insertion_point(field_set:protocol.InternalTransaction.CallValueInfo.callValue)
}

// string tokenId = 2;
inline void InternalTransaction_CallValueInfo::clear_tokenid() {
  tokenid_.ClearToEmpty();
}
inline const std::string& InternalTransaction_CallValueInfo::tokenid() const {
  // @@protoc_insertion_point(field_get:protocol.InternalTransaction.CallValueInfo.tokenId)
  return _internal_tokenid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalTransaction_CallValueInfo::set_tokenid(ArgT0&& arg0, ArgT... args) {
 
 tokenid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.InternalTransaction.CallValueInfo.tokenId)
}
inline std::string* InternalTransaction_CallValueInfo::mutable_tokenid() {
  std::string* _s = _internal_mutable_tokenid();
  // @@protoc_insertion_point(field_mutable:protocol.InternalTransaction.CallValueInfo.tokenId)
  return _s;
}
inline const std::string& InternalTransaction_CallValueInfo::_internal_tokenid() const {
  return tokenid_.Get();
}
inline void InternalTransaction_CallValueInfo::_internal_set_tokenid(const std::string& value) {
  
  tokenid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InternalTransaction_CallValueInfo::_internal_mutable_tokenid() {
  
  return tokenid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InternalTransaction_CallValueInfo::release_tokenid() {
  // @@protoc_insertion_point(field_release:protocol.InternalTransaction.CallValueInfo.tokenId)
  return tokenid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InternalTransaction_CallValueInfo::set_allocated_tokenid(std::string* tokenid) {
  if (tokenid != nullptr) {
    
  } else {
    
  }
  tokenid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tokenid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tokenid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tokenid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.InternalTransaction.CallValueInfo.tokenId)
}

// -------------------------------------------------------------------

// InternalTransaction

// bytes hash = 1;
inline void InternalTransaction::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& InternalTransaction::hash() const {
  // @@protoc_insertion_point(field_get:protocol.InternalTransaction.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalTransaction::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.InternalTransaction.hash)
}
inline std::string* InternalTransaction::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:protocol.InternalTransaction.hash)
  return _s;
}
inline const std::string& InternalTransaction::_internal_hash() const {
  return hash_.Get();
}
inline void InternalTransaction::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InternalTransaction::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InternalTransaction::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.InternalTransaction.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InternalTransaction::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.InternalTransaction.hash)
}

// bytes caller_address = 2;
inline void InternalTransaction::clear_caller_address() {
  caller_address_.ClearToEmpty();
}
inline const std::string& InternalTransaction::caller_address() const {
  // @@protoc_insertion_point(field_get:protocol.InternalTransaction.caller_address)
  return _internal_caller_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalTransaction::set_caller_address(ArgT0&& arg0, ArgT... args) {
 
 caller_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.InternalTransaction.caller_address)
}
inline std::string* InternalTransaction::mutable_caller_address() {
  std::string* _s = _internal_mutable_caller_address();
  // @@protoc_insertion_point(field_mutable:protocol.InternalTransaction.caller_address)
  return _s;
}
inline const std::string& InternalTransaction::_internal_caller_address() const {
  return caller_address_.Get();
}
inline void InternalTransaction::_internal_set_caller_address(const std::string& value) {
  
  caller_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InternalTransaction::_internal_mutable_caller_address() {
  
  return caller_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InternalTransaction::release_caller_address() {
  // @@protoc_insertion_point(field_release:protocol.InternalTransaction.caller_address)
  return caller_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InternalTransaction::set_allocated_caller_address(std::string* caller_address) {
  if (caller_address != nullptr) {
    
  } else {
    
  }
  caller_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), caller_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (caller_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    caller_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.InternalTransaction.caller_address)
}

// bytes transferTo_address = 3;
inline void InternalTransaction::clear_transferto_address() {
  transferto_address_.ClearToEmpty();
}
inline const std::string& InternalTransaction::transferto_address() const {
  // @@protoc_insertion_point(field_get:protocol.InternalTransaction.transferTo_address)
  return _internal_transferto_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalTransaction::set_transferto_address(ArgT0&& arg0, ArgT... args) {
 
 transferto_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.InternalTransaction.transferTo_address)
}
inline std::string* InternalTransaction::mutable_transferto_address() {
  std::string* _s = _internal_mutable_transferto_address();
  // @@protoc_insertion_point(field_mutable:protocol.InternalTransaction.transferTo_address)
  return _s;
}
inline const std::string& InternalTransaction::_internal_transferto_address() const {
  return transferto_address_.Get();
}
inline void InternalTransaction::_internal_set_transferto_address(const std::string& value) {
  
  transferto_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InternalTransaction::_internal_mutable_transferto_address() {
  
  return transferto_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InternalTransaction::release_transferto_address() {
  // @@protoc_insertion_point(field_release:protocol.InternalTransaction.transferTo_address)
  return transferto_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InternalTransaction::set_allocated_transferto_address(std::string* transferto_address) {
  if (transferto_address != nullptr) {
    
  } else {
    
  }
  transferto_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transferto_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transferto_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    transferto_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.InternalTransaction.transferTo_address)
}

// repeated .protocol.InternalTransaction.CallValueInfo callValueInfo = 4;
inline int InternalTransaction::_internal_callvalueinfo_size() const {
  return callvalueinfo_.size();
}
inline int InternalTransaction::callvalueinfo_size() const {
  return _internal_callvalueinfo_size();
}
inline void InternalTransaction::clear_callvalueinfo() {
  callvalueinfo_.Clear();
}
inline ::protocol::InternalTransaction_CallValueInfo* InternalTransaction::mutable_callvalueinfo(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.InternalTransaction.callValueInfo)
  return callvalueinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::InternalTransaction_CallValueInfo >*
InternalTransaction::mutable_callvalueinfo() {
  // @@protoc_insertion_point(field_mutable_list:protocol.InternalTransaction.callValueInfo)
  return &callvalueinfo_;
}
inline const ::protocol::InternalTransaction_CallValueInfo& InternalTransaction::_internal_callvalueinfo(int index) const {
  return callvalueinfo_.Get(index);
}
inline const ::protocol::InternalTransaction_CallValueInfo& InternalTransaction::callvalueinfo(int index) const {
  // @@protoc_insertion_point(field_get:protocol.InternalTransaction.callValueInfo)
  return _internal_callvalueinfo(index);
}
inline ::protocol::InternalTransaction_CallValueInfo* InternalTransaction::_internal_add_callvalueinfo() {
  return callvalueinfo_.Add();
}
inline ::protocol::InternalTransaction_CallValueInfo* InternalTransaction::add_callvalueinfo() {
  ::protocol::InternalTransaction_CallValueInfo* _add = _internal_add_callvalueinfo();
  // @@protoc_insertion_point(field_add:protocol.InternalTransaction.callValueInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::InternalTransaction_CallValueInfo >&
InternalTransaction::callvalueinfo() const {
  // @@protoc_insertion_point(field_list:protocol.InternalTransaction.callValueInfo)
  return callvalueinfo_;
}

// bytes note = 5;
inline void InternalTransaction::clear_note() {
  note_.ClearToEmpty();
}
inline const std::string& InternalTransaction::note() const {
  // @@protoc_insertion_point(field_get:protocol.InternalTransaction.note)
  return _internal_note();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalTransaction::set_note(ArgT0&& arg0, ArgT... args) {
 
 note_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.InternalTransaction.note)
}
inline std::string* InternalTransaction::mutable_note() {
  std::string* _s = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:protocol.InternalTransaction.note)
  return _s;
}
inline const std::string& InternalTransaction::_internal_note() const {
  return note_.Get();
}
inline void InternalTransaction::_internal_set_note(const std::string& value) {
  
  note_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InternalTransaction::_internal_mutable_note() {
  
  return note_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InternalTransaction::release_note() {
  // @@protoc_insertion_point(field_release:protocol.InternalTransaction.note)
  return note_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InternalTransaction::set_allocated_note(std::string* note) {
  if (note != nullptr) {
    
  } else {
    
  }
  note_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), note,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (note_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    note_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.InternalTransaction.note)
}

// bool rejected = 6;
inline void InternalTransaction::clear_rejected() {
  rejected_ = false;
}
inline bool InternalTransaction::_internal_rejected() const {
  return rejected_;
}
inline bool InternalTransaction::rejected() const {
  // @@protoc_insertion_point(field_get:protocol.InternalTransaction.rejected)
  return _internal_rejected();
}
inline void InternalTransaction::_internal_set_rejected(bool value) {
  
  rejected_ = value;
}
inline void InternalTransaction::set_rejected(bool value) {
  _internal_set_rejected(value);
  // @@protoc_insertion_point(field_set:protocol.InternalTransaction.rejected)
}

// string extra = 7;
inline void InternalTransaction::clear_extra() {
  extra_.ClearToEmpty();
}
inline const std::string& InternalTransaction::extra() const {
  // @@protoc_insertion_point(field_get:protocol.InternalTransaction.extra)
  return _internal_extra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternalTransaction::set_extra(ArgT0&& arg0, ArgT... args) {
 
 extra_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.InternalTransaction.extra)
}
inline std::string* InternalTransaction::mutable_extra() {
  std::string* _s = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:protocol.InternalTransaction.extra)
  return _s;
}
inline const std::string& InternalTransaction::_internal_extra() const {
  return extra_.Get();
}
inline void InternalTransaction::_internal_set_extra(const std::string& value) {
  
  extra_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InternalTransaction::_internal_mutable_extra() {
  
  return extra_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InternalTransaction::release_extra() {
  // @@protoc_insertion_point(field_release:protocol.InternalTransaction.extra)
  return extra_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InternalTransaction::set_allocated_extra(std::string* extra) {
  if (extra != nullptr) {
    
  } else {
    
  }
  extra_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extra,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    extra_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.InternalTransaction.extra)
}

// -------------------------------------------------------------------

// DelegatedResourceAccountIndex

// bytes account = 1;
inline void DelegatedResourceAccountIndex::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& DelegatedResourceAccountIndex::account() const {
  // @@protoc_insertion_point(field_get:protocol.DelegatedResourceAccountIndex.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelegatedResourceAccountIndex::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.DelegatedResourceAccountIndex.account)
}
inline std::string* DelegatedResourceAccountIndex::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:protocol.DelegatedResourceAccountIndex.account)
  return _s;
}
inline const std::string& DelegatedResourceAccountIndex::_internal_account() const {
  return account_.Get();
}
inline void DelegatedResourceAccountIndex::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DelegatedResourceAccountIndex::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DelegatedResourceAccountIndex::release_account() {
  // @@protoc_insertion_point(field_release:protocol.DelegatedResourceAccountIndex.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DelegatedResourceAccountIndex::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.DelegatedResourceAccountIndex.account)
}

// repeated bytes fromAccounts = 2;
inline int DelegatedResourceAccountIndex::_internal_fromaccounts_size() const {
  return fromaccounts_.size();
}
inline int DelegatedResourceAccountIndex::fromaccounts_size() const {
  return _internal_fromaccounts_size();
}
inline void DelegatedResourceAccountIndex::clear_fromaccounts() {
  fromaccounts_.Clear();
}
inline std::string* DelegatedResourceAccountIndex::add_fromaccounts() {
  std::string* _s = _internal_add_fromaccounts();
  // @@protoc_insertion_point(field_add_mutable:protocol.DelegatedResourceAccountIndex.fromAccounts)
  return _s;
}
inline const std::string& DelegatedResourceAccountIndex::_internal_fromaccounts(int index) const {
  return fromaccounts_.Get(index);
}
inline const std::string& DelegatedResourceAccountIndex::fromaccounts(int index) const {
  // @@protoc_insertion_point(field_get:protocol.DelegatedResourceAccountIndex.fromAccounts)
  return _internal_fromaccounts(index);
}
inline std::string* DelegatedResourceAccountIndex::mutable_fromaccounts(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.DelegatedResourceAccountIndex.fromAccounts)
  return fromaccounts_.Mutable(index);
}
inline void DelegatedResourceAccountIndex::set_fromaccounts(int index, const std::string& value) {
  fromaccounts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.DelegatedResourceAccountIndex.fromAccounts)
}
inline void DelegatedResourceAccountIndex::set_fromaccounts(int index, std::string&& value) {
  fromaccounts_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.DelegatedResourceAccountIndex.fromAccounts)
}
inline void DelegatedResourceAccountIndex::set_fromaccounts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fromaccounts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.DelegatedResourceAccountIndex.fromAccounts)
}
inline void DelegatedResourceAccountIndex::set_fromaccounts(int index, const void* value, size_t size) {
  fromaccounts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.DelegatedResourceAccountIndex.fromAccounts)
}
inline std::string* DelegatedResourceAccountIndex::_internal_add_fromaccounts() {
  return fromaccounts_.Add();
}
inline void DelegatedResourceAccountIndex::add_fromaccounts(const std::string& value) {
  fromaccounts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.DelegatedResourceAccountIndex.fromAccounts)
}
inline void DelegatedResourceAccountIndex::add_fromaccounts(std::string&& value) {
  fromaccounts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.DelegatedResourceAccountIndex.fromAccounts)
}
inline void DelegatedResourceAccountIndex::add_fromaccounts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fromaccounts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.DelegatedResourceAccountIndex.fromAccounts)
}
inline void DelegatedResourceAccountIndex::add_fromaccounts(const void* value, size_t size) {
  fromaccounts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.DelegatedResourceAccountIndex.fromAccounts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DelegatedResourceAccountIndex::fromaccounts() const {
  // @@protoc_insertion_point(field_list:protocol.DelegatedResourceAccountIndex.fromAccounts)
  return fromaccounts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DelegatedResourceAccountIndex::mutable_fromaccounts() {
  // @@protoc_insertion_point(field_mutable_list:protocol.DelegatedResourceAccountIndex.fromAccounts)
  return &fromaccounts_;
}

// repeated bytes toAccounts = 3;
inline int DelegatedResourceAccountIndex::_internal_toaccounts_size() const {
  return toaccounts_.size();
}
inline int DelegatedResourceAccountIndex::toaccounts_size() const {
  return _internal_toaccounts_size();
}
inline void DelegatedResourceAccountIndex::clear_toaccounts() {
  toaccounts_.Clear();
}
inline std::string* DelegatedResourceAccountIndex::add_toaccounts() {
  std::string* _s = _internal_add_toaccounts();
  // @@protoc_insertion_point(field_add_mutable:protocol.DelegatedResourceAccountIndex.toAccounts)
  return _s;
}
inline const std::string& DelegatedResourceAccountIndex::_internal_toaccounts(int index) const {
  return toaccounts_.Get(index);
}
inline const std::string& DelegatedResourceAccountIndex::toaccounts(int index) const {
  // @@protoc_insertion_point(field_get:protocol.DelegatedResourceAccountIndex.toAccounts)
  return _internal_toaccounts(index);
}
inline std::string* DelegatedResourceAccountIndex::mutable_toaccounts(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.DelegatedResourceAccountIndex.toAccounts)
  return toaccounts_.Mutable(index);
}
inline void DelegatedResourceAccountIndex::set_toaccounts(int index, const std::string& value) {
  toaccounts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.DelegatedResourceAccountIndex.toAccounts)
}
inline void DelegatedResourceAccountIndex::set_toaccounts(int index, std::string&& value) {
  toaccounts_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.DelegatedResourceAccountIndex.toAccounts)
}
inline void DelegatedResourceAccountIndex::set_toaccounts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  toaccounts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.DelegatedResourceAccountIndex.toAccounts)
}
inline void DelegatedResourceAccountIndex::set_toaccounts(int index, const void* value, size_t size) {
  toaccounts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.DelegatedResourceAccountIndex.toAccounts)
}
inline std::string* DelegatedResourceAccountIndex::_internal_add_toaccounts() {
  return toaccounts_.Add();
}
inline void DelegatedResourceAccountIndex::add_toaccounts(const std::string& value) {
  toaccounts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.DelegatedResourceAccountIndex.toAccounts)
}
inline void DelegatedResourceAccountIndex::add_toaccounts(std::string&& value) {
  toaccounts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.DelegatedResourceAccountIndex.toAccounts)
}
inline void DelegatedResourceAccountIndex::add_toaccounts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  toaccounts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.DelegatedResourceAccountIndex.toAccounts)
}
inline void DelegatedResourceAccountIndex::add_toaccounts(const void* value, size_t size) {
  toaccounts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.DelegatedResourceAccountIndex.toAccounts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DelegatedResourceAccountIndex::toaccounts() const {
  // @@protoc_insertion_point(field_list:protocol.DelegatedResourceAccountIndex.toAccounts)
  return toaccounts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DelegatedResourceAccountIndex::mutable_toaccounts() {
  // @@protoc_insertion_point(field_mutable_list:protocol.DelegatedResourceAccountIndex.toAccounts)
  return &toaccounts_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NodeInfo_PeerInfo

// string lastSyncBlock = 1;
inline void NodeInfo_PeerInfo::clear_lastsyncblock() {
  lastsyncblock_.ClearToEmpty();
}
inline const std::string& NodeInfo_PeerInfo::lastsyncblock() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.lastSyncBlock)
  return _internal_lastsyncblock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_PeerInfo::set_lastsyncblock(ArgT0&& arg0, ArgT... args) {
 
 lastsyncblock_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.lastSyncBlock)
}
inline std::string* NodeInfo_PeerInfo::mutable_lastsyncblock() {
  std::string* _s = _internal_mutable_lastsyncblock();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.PeerInfo.lastSyncBlock)
  return _s;
}
inline const std::string& NodeInfo_PeerInfo::_internal_lastsyncblock() const {
  return lastsyncblock_.Get();
}
inline void NodeInfo_PeerInfo::_internal_set_lastsyncblock(const std::string& value) {
  
  lastsyncblock_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_PeerInfo::_internal_mutable_lastsyncblock() {
  
  return lastsyncblock_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_PeerInfo::release_lastsyncblock() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.PeerInfo.lastSyncBlock)
  return lastsyncblock_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_PeerInfo::set_allocated_lastsyncblock(std::string* lastsyncblock) {
  if (lastsyncblock != nullptr) {
    
  } else {
    
  }
  lastsyncblock_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lastsyncblock,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (lastsyncblock_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    lastsyncblock_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.PeerInfo.lastSyncBlock)
}

// int64 remainNum = 2;
inline void NodeInfo_PeerInfo::clear_remainnum() {
  remainnum_ = int64_t{0};
}
inline int64_t NodeInfo_PeerInfo::_internal_remainnum() const {
  return remainnum_;
}
inline int64_t NodeInfo_PeerInfo::remainnum() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.remainNum)
  return _internal_remainnum();
}
inline void NodeInfo_PeerInfo::_internal_set_remainnum(int64_t value) {
  
  remainnum_ = value;
}
inline void NodeInfo_PeerInfo::set_remainnum(int64_t value) {
  _internal_set_remainnum(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.remainNum)
}

// int64 lastBlockUpdateTime = 3;
inline void NodeInfo_PeerInfo::clear_lastblockupdatetime() {
  lastblockupdatetime_ = int64_t{0};
}
inline int64_t NodeInfo_PeerInfo::_internal_lastblockupdatetime() const {
  return lastblockupdatetime_;
}
inline int64_t NodeInfo_PeerInfo::lastblockupdatetime() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.lastBlockUpdateTime)
  return _internal_lastblockupdatetime();
}
inline void NodeInfo_PeerInfo::_internal_set_lastblockupdatetime(int64_t value) {
  
  lastblockupdatetime_ = value;
}
inline void NodeInfo_PeerInfo::set_lastblockupdatetime(int64_t value) {
  _internal_set_lastblockupdatetime(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.lastBlockUpdateTime)
}

// bool syncFlag = 4;
inline void NodeInfo_PeerInfo::clear_syncflag() {
  syncflag_ = false;
}
inline bool NodeInfo_PeerInfo::_internal_syncflag() const {
  return syncflag_;
}
inline bool NodeInfo_PeerInfo::syncflag() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.syncFlag)
  return _internal_syncflag();
}
inline void NodeInfo_PeerInfo::_internal_set_syncflag(bool value) {
  
  syncflag_ = value;
}
inline void NodeInfo_PeerInfo::set_syncflag(bool value) {
  _internal_set_syncflag(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.syncFlag)
}

// int64 headBlockTimeWeBothHave = 5;
inline void NodeInfo_PeerInfo::clear_headblocktimewebothhave() {
  headblocktimewebothhave_ = int64_t{0};
}
inline int64_t NodeInfo_PeerInfo::_internal_headblocktimewebothhave() const {
  return headblocktimewebothhave_;
}
inline int64_t NodeInfo_PeerInfo::headblocktimewebothhave() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.headBlockTimeWeBothHave)
  return _internal_headblocktimewebothhave();
}
inline void NodeInfo_PeerInfo::_internal_set_headblocktimewebothhave(int64_t value) {
  
  headblocktimewebothhave_ = value;
}
inline void NodeInfo_PeerInfo::set_headblocktimewebothhave(int64_t value) {
  _internal_set_headblocktimewebothhave(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.headBlockTimeWeBothHave)
}

// bool needSyncFromPeer = 6;
inline void NodeInfo_PeerInfo::clear_needsyncfrompeer() {
  needsyncfrompeer_ = false;
}
inline bool NodeInfo_PeerInfo::_internal_needsyncfrompeer() const {
  return needsyncfrompeer_;
}
inline bool NodeInfo_PeerInfo::needsyncfrompeer() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.needSyncFromPeer)
  return _internal_needsyncfrompeer();
}
inline void NodeInfo_PeerInfo::_internal_set_needsyncfrompeer(bool value) {
  
  needsyncfrompeer_ = value;
}
inline void NodeInfo_PeerInfo::set_needsyncfrompeer(bool value) {
  _internal_set_needsyncfrompeer(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.needSyncFromPeer)
}

// bool needSyncFromUs = 7;
inline void NodeInfo_PeerInfo::clear_needsyncfromus() {
  needsyncfromus_ = false;
}
inline bool NodeInfo_PeerInfo::_internal_needsyncfromus() const {
  return needsyncfromus_;
}
inline bool NodeInfo_PeerInfo::needsyncfromus() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.needSyncFromUs)
  return _internal_needsyncfromus();
}
inline void NodeInfo_PeerInfo::_internal_set_needsyncfromus(bool value) {
  
  needsyncfromus_ = value;
}
inline void NodeInfo_PeerInfo::set_needsyncfromus(bool value) {
  _internal_set_needsyncfromus(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.needSyncFromUs)
}

// string host = 8;
inline void NodeInfo_PeerInfo::clear_host() {
  host_.ClearToEmpty();
}
inline const std::string& NodeInfo_PeerInfo::host() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_PeerInfo::set_host(ArgT0&& arg0, ArgT... args) {
 
 host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.host)
}
inline std::string* NodeInfo_PeerInfo::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.PeerInfo.host)
  return _s;
}
inline const std::string& NodeInfo_PeerInfo::_internal_host() const {
  return host_.Get();
}
inline void NodeInfo_PeerInfo::_internal_set_host(const std::string& value) {
  
  host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_PeerInfo::_internal_mutable_host() {
  
  return host_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_PeerInfo::release_host() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.PeerInfo.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_PeerInfo::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (host_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.PeerInfo.host)
}

// int32 port = 9;
inline void NodeInfo_PeerInfo::clear_port() {
  port_ = 0;
}
inline int32_t NodeInfo_PeerInfo::_internal_port() const {
  return port_;
}
inline int32_t NodeInfo_PeerInfo::port() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.port)
  return _internal_port();
}
inline void NodeInfo_PeerInfo::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void NodeInfo_PeerInfo::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.port)
}

// string nodeId = 10;
inline void NodeInfo_PeerInfo::clear_nodeid() {
  nodeid_.ClearToEmpty();
}
inline const std::string& NodeInfo_PeerInfo::nodeid() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.nodeId)
  return _internal_nodeid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_PeerInfo::set_nodeid(ArgT0&& arg0, ArgT... args) {
 
 nodeid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.nodeId)
}
inline std::string* NodeInfo_PeerInfo::mutable_nodeid() {
  std::string* _s = _internal_mutable_nodeid();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.PeerInfo.nodeId)
  return _s;
}
inline const std::string& NodeInfo_PeerInfo::_internal_nodeid() const {
  return nodeid_.Get();
}
inline void NodeInfo_PeerInfo::_internal_set_nodeid(const std::string& value) {
  
  nodeid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_PeerInfo::_internal_mutable_nodeid() {
  
  return nodeid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_PeerInfo::release_nodeid() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.PeerInfo.nodeId)
  return nodeid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_PeerInfo::set_allocated_nodeid(std::string* nodeid) {
  if (nodeid != nullptr) {
    
  } else {
    
  }
  nodeid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodeid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nodeid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nodeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.PeerInfo.nodeId)
}

// int64 connectTime = 11;
inline void NodeInfo_PeerInfo::clear_connecttime() {
  connecttime_ = int64_t{0};
}
inline int64_t NodeInfo_PeerInfo::_internal_connecttime() const {
  return connecttime_;
}
inline int64_t NodeInfo_PeerInfo::connecttime() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.connectTime)
  return _internal_connecttime();
}
inline void NodeInfo_PeerInfo::_internal_set_connecttime(int64_t value) {
  
  connecttime_ = value;
}
inline void NodeInfo_PeerInfo::set_connecttime(int64_t value) {
  _internal_set_connecttime(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.connectTime)
}

// double avgLatency = 12;
inline void NodeInfo_PeerInfo::clear_avglatency() {
  avglatency_ = 0;
}
inline double NodeInfo_PeerInfo::_internal_avglatency() const {
  return avglatency_;
}
inline double NodeInfo_PeerInfo::avglatency() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.avgLatency)
  return _internal_avglatency();
}
inline void NodeInfo_PeerInfo::_internal_set_avglatency(double value) {
  
  avglatency_ = value;
}
inline void NodeInfo_PeerInfo::set_avglatency(double value) {
  _internal_set_avglatency(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.avgLatency)
}

// int32 syncToFetchSize = 13;
inline void NodeInfo_PeerInfo::clear_synctofetchsize() {
  synctofetchsize_ = 0;
}
inline int32_t NodeInfo_PeerInfo::_internal_synctofetchsize() const {
  return synctofetchsize_;
}
inline int32_t NodeInfo_PeerInfo::synctofetchsize() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.syncToFetchSize)
  return _internal_synctofetchsize();
}
inline void NodeInfo_PeerInfo::_internal_set_synctofetchsize(int32_t value) {
  
  synctofetchsize_ = value;
}
inline void NodeInfo_PeerInfo::set_synctofetchsize(int32_t value) {
  _internal_set_synctofetchsize(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.syncToFetchSize)
}

// int64 syncToFetchSizePeekNum = 14;
inline void NodeInfo_PeerInfo::clear_synctofetchsizepeeknum() {
  synctofetchsizepeeknum_ = int64_t{0};
}
inline int64_t NodeInfo_PeerInfo::_internal_synctofetchsizepeeknum() const {
  return synctofetchsizepeeknum_;
}
inline int64_t NodeInfo_PeerInfo::synctofetchsizepeeknum() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.syncToFetchSizePeekNum)
  return _internal_synctofetchsizepeeknum();
}
inline void NodeInfo_PeerInfo::_internal_set_synctofetchsizepeeknum(int64_t value) {
  
  synctofetchsizepeeknum_ = value;
}
inline void NodeInfo_PeerInfo::set_synctofetchsizepeeknum(int64_t value) {
  _internal_set_synctofetchsizepeeknum(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.syncToFetchSizePeekNum)
}

// int32 syncBlockRequestedSize = 15;
inline void NodeInfo_PeerInfo::clear_syncblockrequestedsize() {
  syncblockrequestedsize_ = 0;
}
inline int32_t NodeInfo_PeerInfo::_internal_syncblockrequestedsize() const {
  return syncblockrequestedsize_;
}
inline int32_t NodeInfo_PeerInfo::syncblockrequestedsize() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.syncBlockRequestedSize)
  return _internal_syncblockrequestedsize();
}
inline void NodeInfo_PeerInfo::_internal_set_syncblockrequestedsize(int32_t value) {
  
  syncblockrequestedsize_ = value;
}
inline void NodeInfo_PeerInfo::set_syncblockrequestedsize(int32_t value) {
  _internal_set_syncblockrequestedsize(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.syncBlockRequestedSize)
}

// int64 unFetchSynNum = 16;
inline void NodeInfo_PeerInfo::clear_unfetchsynnum() {
  unfetchsynnum_ = int64_t{0};
}
inline int64_t NodeInfo_PeerInfo::_internal_unfetchsynnum() const {
  return unfetchsynnum_;
}
inline int64_t NodeInfo_PeerInfo::unfetchsynnum() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.unFetchSynNum)
  return _internal_unfetchsynnum();
}
inline void NodeInfo_PeerInfo::_internal_set_unfetchsynnum(int64_t value) {
  
  unfetchsynnum_ = value;
}
inline void NodeInfo_PeerInfo::set_unfetchsynnum(int64_t value) {
  _internal_set_unfetchsynnum(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.unFetchSynNum)
}

// int32 blockInPorcSize = 17;
inline void NodeInfo_PeerInfo::clear_blockinporcsize() {
  blockinporcsize_ = 0;
}
inline int32_t NodeInfo_PeerInfo::_internal_blockinporcsize() const {
  return blockinporcsize_;
}
inline int32_t NodeInfo_PeerInfo::blockinporcsize() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.blockInPorcSize)
  return _internal_blockinporcsize();
}
inline void NodeInfo_PeerInfo::_internal_set_blockinporcsize(int32_t value) {
  
  blockinporcsize_ = value;
}
inline void NodeInfo_PeerInfo::set_blockinporcsize(int32_t value) {
  _internal_set_blockinporcsize(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.blockInPorcSize)
}

// string headBlockWeBothHave = 18;
inline void NodeInfo_PeerInfo::clear_headblockwebothhave() {
  headblockwebothhave_.ClearToEmpty();
}
inline const std::string& NodeInfo_PeerInfo::headblockwebothhave() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.headBlockWeBothHave)
  return _internal_headblockwebothhave();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_PeerInfo::set_headblockwebothhave(ArgT0&& arg0, ArgT... args) {
 
 headblockwebothhave_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.headBlockWeBothHave)
}
inline std::string* NodeInfo_PeerInfo::mutable_headblockwebothhave() {
  std::string* _s = _internal_mutable_headblockwebothhave();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.PeerInfo.headBlockWeBothHave)
  return _s;
}
inline const std::string& NodeInfo_PeerInfo::_internal_headblockwebothhave() const {
  return headblockwebothhave_.Get();
}
inline void NodeInfo_PeerInfo::_internal_set_headblockwebothhave(const std::string& value) {
  
  headblockwebothhave_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_PeerInfo::_internal_mutable_headblockwebothhave() {
  
  return headblockwebothhave_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_PeerInfo::release_headblockwebothhave() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.PeerInfo.headBlockWeBothHave)
  return headblockwebothhave_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_PeerInfo::set_allocated_headblockwebothhave(std::string* headblockwebothhave) {
  if (headblockwebothhave != nullptr) {
    
  } else {
    
  }
  headblockwebothhave_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), headblockwebothhave,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (headblockwebothhave_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    headblockwebothhave_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.PeerInfo.headBlockWeBothHave)
}

// bool isActive = 19;
inline void NodeInfo_PeerInfo::clear_isactive() {
  isactive_ = false;
}
inline bool NodeInfo_PeerInfo::_internal_isactive() const {
  return isactive_;
}
inline bool NodeInfo_PeerInfo::isactive() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.isActive)
  return _internal_isactive();
}
inline void NodeInfo_PeerInfo::_internal_set_isactive(bool value) {
  
  isactive_ = value;
}
inline void NodeInfo_PeerInfo::set_isactive(bool value) {
  _internal_set_isactive(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.isActive)
}

// int32 score = 20;
inline void NodeInfo_PeerInfo::clear_score() {
  score_ = 0;
}
inline int32_t NodeInfo_PeerInfo::_internal_score() const {
  return score_;
}
inline int32_t NodeInfo_PeerInfo::score() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.score)
  return _internal_score();
}
inline void NodeInfo_PeerInfo::_internal_set_score(int32_t value) {
  
  score_ = value;
}
inline void NodeInfo_PeerInfo::set_score(int32_t value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.score)
}

// int32 nodeCount = 21;
inline void NodeInfo_PeerInfo::clear_nodecount() {
  nodecount_ = 0;
}
inline int32_t NodeInfo_PeerInfo::_internal_nodecount() const {
  return nodecount_;
}
inline int32_t NodeInfo_PeerInfo::nodecount() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.nodeCount)
  return _internal_nodecount();
}
inline void NodeInfo_PeerInfo::_internal_set_nodecount(int32_t value) {
  
  nodecount_ = value;
}
inline void NodeInfo_PeerInfo::set_nodecount(int32_t value) {
  _internal_set_nodecount(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.nodeCount)
}

// int64 inFlow = 22;
inline void NodeInfo_PeerInfo::clear_inflow() {
  inflow_ = int64_t{0};
}
inline int64_t NodeInfo_PeerInfo::_internal_inflow() const {
  return inflow_;
}
inline int64_t NodeInfo_PeerInfo::inflow() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.inFlow)
  return _internal_inflow();
}
inline void NodeInfo_PeerInfo::_internal_set_inflow(int64_t value) {
  
  inflow_ = value;
}
inline void NodeInfo_PeerInfo::set_inflow(int64_t value) {
  _internal_set_inflow(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.inFlow)
}

// int32 disconnectTimes = 23;
inline void NodeInfo_PeerInfo::clear_disconnecttimes() {
  disconnecttimes_ = 0;
}
inline int32_t NodeInfo_PeerInfo::_internal_disconnecttimes() const {
  return disconnecttimes_;
}
inline int32_t NodeInfo_PeerInfo::disconnecttimes() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.disconnectTimes)
  return _internal_disconnecttimes();
}
inline void NodeInfo_PeerInfo::_internal_set_disconnecttimes(int32_t value) {
  
  disconnecttimes_ = value;
}
inline void NodeInfo_PeerInfo::set_disconnecttimes(int32_t value) {
  _internal_set_disconnecttimes(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.disconnectTimes)
}

// string localDisconnectReason = 24;
inline void NodeInfo_PeerInfo::clear_localdisconnectreason() {
  localdisconnectreason_.ClearToEmpty();
}
inline const std::string& NodeInfo_PeerInfo::localdisconnectreason() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.localDisconnectReason)
  return _internal_localdisconnectreason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_PeerInfo::set_localdisconnectreason(ArgT0&& arg0, ArgT... args) {
 
 localdisconnectreason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.localDisconnectReason)
}
inline std::string* NodeInfo_PeerInfo::mutable_localdisconnectreason() {
  std::string* _s = _internal_mutable_localdisconnectreason();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.PeerInfo.localDisconnectReason)
  return _s;
}
inline const std::string& NodeInfo_PeerInfo::_internal_localdisconnectreason() const {
  return localdisconnectreason_.Get();
}
inline void NodeInfo_PeerInfo::_internal_set_localdisconnectreason(const std::string& value) {
  
  localdisconnectreason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_PeerInfo::_internal_mutable_localdisconnectreason() {
  
  return localdisconnectreason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_PeerInfo::release_localdisconnectreason() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.PeerInfo.localDisconnectReason)
  return localdisconnectreason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_PeerInfo::set_allocated_localdisconnectreason(std::string* localdisconnectreason) {
  if (localdisconnectreason != nullptr) {
    
  } else {
    
  }
  localdisconnectreason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), localdisconnectreason,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (localdisconnectreason_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    localdisconnectreason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.PeerInfo.localDisconnectReason)
}

// string remoteDisconnectReason = 25;
inline void NodeInfo_PeerInfo::clear_remotedisconnectreason() {
  remotedisconnectreason_.ClearToEmpty();
}
inline const std::string& NodeInfo_PeerInfo::remotedisconnectreason() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.PeerInfo.remoteDisconnectReason)
  return _internal_remotedisconnectreason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_PeerInfo::set_remotedisconnectreason(ArgT0&& arg0, ArgT... args) {
 
 remotedisconnectreason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.PeerInfo.remoteDisconnectReason)
}
inline std::string* NodeInfo_PeerInfo::mutable_remotedisconnectreason() {
  std::string* _s = _internal_mutable_remotedisconnectreason();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.PeerInfo.remoteDisconnectReason)
  return _s;
}
inline const std::string& NodeInfo_PeerInfo::_internal_remotedisconnectreason() const {
  return remotedisconnectreason_.Get();
}
inline void NodeInfo_PeerInfo::_internal_set_remotedisconnectreason(const std::string& value) {
  
  remotedisconnectreason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_PeerInfo::_internal_mutable_remotedisconnectreason() {
  
  return remotedisconnectreason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_PeerInfo::release_remotedisconnectreason() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.PeerInfo.remoteDisconnectReason)
  return remotedisconnectreason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_PeerInfo::set_allocated_remotedisconnectreason(std::string* remotedisconnectreason) {
  if (remotedisconnectreason != nullptr) {
    
  } else {
    
  }
  remotedisconnectreason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remotedisconnectreason,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remotedisconnectreason_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    remotedisconnectreason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.PeerInfo.remoteDisconnectReason)
}

// -------------------------------------------------------------------

// NodeInfo_ConfigNodeInfo

// string codeVersion = 1;
inline void NodeInfo_ConfigNodeInfo::clear_codeversion() {
  codeversion_.ClearToEmpty();
}
inline const std::string& NodeInfo_ConfigNodeInfo::codeversion() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.codeVersion)
  return _internal_codeversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_ConfigNodeInfo::set_codeversion(ArgT0&& arg0, ArgT... args) {
 
 codeversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.codeVersion)
}
inline std::string* NodeInfo_ConfigNodeInfo::mutable_codeversion() {
  std::string* _s = _internal_mutable_codeversion();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.ConfigNodeInfo.codeVersion)
  return _s;
}
inline const std::string& NodeInfo_ConfigNodeInfo::_internal_codeversion() const {
  return codeversion_.Get();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_codeversion(const std::string& value) {
  
  codeversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_ConfigNodeInfo::_internal_mutable_codeversion() {
  
  return codeversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_ConfigNodeInfo::release_codeversion() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.ConfigNodeInfo.codeVersion)
  return codeversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_ConfigNodeInfo::set_allocated_codeversion(std::string* codeversion) {
  if (codeversion != nullptr) {
    
  } else {
    
  }
  codeversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), codeversion,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (codeversion_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    codeversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.ConfigNodeInfo.codeVersion)
}

// string p2pVersion = 2;
inline void NodeInfo_ConfigNodeInfo::clear_p2pversion() {
  p2pversion_.ClearToEmpty();
}
inline const std::string& NodeInfo_ConfigNodeInfo::p2pversion() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.p2pVersion)
  return _internal_p2pversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_ConfigNodeInfo::set_p2pversion(ArgT0&& arg0, ArgT... args) {
 
 p2pversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.p2pVersion)
}
inline std::string* NodeInfo_ConfigNodeInfo::mutable_p2pversion() {
  std::string* _s = _internal_mutable_p2pversion();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.ConfigNodeInfo.p2pVersion)
  return _s;
}
inline const std::string& NodeInfo_ConfigNodeInfo::_internal_p2pversion() const {
  return p2pversion_.Get();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_p2pversion(const std::string& value) {
  
  p2pversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_ConfigNodeInfo::_internal_mutable_p2pversion() {
  
  return p2pversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_ConfigNodeInfo::release_p2pversion() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.ConfigNodeInfo.p2pVersion)
  return p2pversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_ConfigNodeInfo::set_allocated_p2pversion(std::string* p2pversion) {
  if (p2pversion != nullptr) {
    
  } else {
    
  }
  p2pversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), p2pversion,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (p2pversion_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    p2pversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.ConfigNodeInfo.p2pVersion)
}

// int32 listenPort = 3;
inline void NodeInfo_ConfigNodeInfo::clear_listenport() {
  listenport_ = 0;
}
inline int32_t NodeInfo_ConfigNodeInfo::_internal_listenport() const {
  return listenport_;
}
inline int32_t NodeInfo_ConfigNodeInfo::listenport() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.listenPort)
  return _internal_listenport();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_listenport(int32_t value) {
  
  listenport_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_listenport(int32_t value) {
  _internal_set_listenport(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.listenPort)
}

// bool discoverEnable = 4;
inline void NodeInfo_ConfigNodeInfo::clear_discoverenable() {
  discoverenable_ = false;
}
inline bool NodeInfo_ConfigNodeInfo::_internal_discoverenable() const {
  return discoverenable_;
}
inline bool NodeInfo_ConfigNodeInfo::discoverenable() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.discoverEnable)
  return _internal_discoverenable();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_discoverenable(bool value) {
  
  discoverenable_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_discoverenable(bool value) {
  _internal_set_discoverenable(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.discoverEnable)
}

// int32 activeNodeSize = 5;
inline void NodeInfo_ConfigNodeInfo::clear_activenodesize() {
  activenodesize_ = 0;
}
inline int32_t NodeInfo_ConfigNodeInfo::_internal_activenodesize() const {
  return activenodesize_;
}
inline int32_t NodeInfo_ConfigNodeInfo::activenodesize() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.activeNodeSize)
  return _internal_activenodesize();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_activenodesize(int32_t value) {
  
  activenodesize_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_activenodesize(int32_t value) {
  _internal_set_activenodesize(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.activeNodeSize)
}

// int32 passiveNodeSize = 6;
inline void NodeInfo_ConfigNodeInfo::clear_passivenodesize() {
  passivenodesize_ = 0;
}
inline int32_t NodeInfo_ConfigNodeInfo::_internal_passivenodesize() const {
  return passivenodesize_;
}
inline int32_t NodeInfo_ConfigNodeInfo::passivenodesize() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.passiveNodeSize)
  return _internal_passivenodesize();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_passivenodesize(int32_t value) {
  
  passivenodesize_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_passivenodesize(int32_t value) {
  _internal_set_passivenodesize(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.passiveNodeSize)
}

// int32 sendNodeSize = 7;
inline void NodeInfo_ConfigNodeInfo::clear_sendnodesize() {
  sendnodesize_ = 0;
}
inline int32_t NodeInfo_ConfigNodeInfo::_internal_sendnodesize() const {
  return sendnodesize_;
}
inline int32_t NodeInfo_ConfigNodeInfo::sendnodesize() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.sendNodeSize)
  return _internal_sendnodesize();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_sendnodesize(int32_t value) {
  
  sendnodesize_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_sendnodesize(int32_t value) {
  _internal_set_sendnodesize(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.sendNodeSize)
}

// int32 maxConnectCount = 8;
inline void NodeInfo_ConfigNodeInfo::clear_maxconnectcount() {
  maxconnectcount_ = 0;
}
inline int32_t NodeInfo_ConfigNodeInfo::_internal_maxconnectcount() const {
  return maxconnectcount_;
}
inline int32_t NodeInfo_ConfigNodeInfo::maxconnectcount() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.maxConnectCount)
  return _internal_maxconnectcount();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_maxconnectcount(int32_t value) {
  
  maxconnectcount_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_maxconnectcount(int32_t value) {
  _internal_set_maxconnectcount(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.maxConnectCount)
}

// int32 sameIpMaxConnectCount = 9;
inline void NodeInfo_ConfigNodeInfo::clear_sameipmaxconnectcount() {
  sameipmaxconnectcount_ = 0;
}
inline int32_t NodeInfo_ConfigNodeInfo::_internal_sameipmaxconnectcount() const {
  return sameipmaxconnectcount_;
}
inline int32_t NodeInfo_ConfigNodeInfo::sameipmaxconnectcount() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.sameIpMaxConnectCount)
  return _internal_sameipmaxconnectcount();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_sameipmaxconnectcount(int32_t value) {
  
  sameipmaxconnectcount_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_sameipmaxconnectcount(int32_t value) {
  _internal_set_sameipmaxconnectcount(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.sameIpMaxConnectCount)
}

// int32 backupListenPort = 10;
inline void NodeInfo_ConfigNodeInfo::clear_backuplistenport() {
  backuplistenport_ = 0;
}
inline int32_t NodeInfo_ConfigNodeInfo::_internal_backuplistenport() const {
  return backuplistenport_;
}
inline int32_t NodeInfo_ConfigNodeInfo::backuplistenport() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.backupListenPort)
  return _internal_backuplistenport();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_backuplistenport(int32_t value) {
  
  backuplistenport_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_backuplistenport(int32_t value) {
  _internal_set_backuplistenport(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.backupListenPort)
}

// int32 backupMemberSize = 11;
inline void NodeInfo_ConfigNodeInfo::clear_backupmembersize() {
  backupmembersize_ = 0;
}
inline int32_t NodeInfo_ConfigNodeInfo::_internal_backupmembersize() const {
  return backupmembersize_;
}
inline int32_t NodeInfo_ConfigNodeInfo::backupmembersize() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.backupMemberSize)
  return _internal_backupmembersize();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_backupmembersize(int32_t value) {
  
  backupmembersize_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_backupmembersize(int32_t value) {
  _internal_set_backupmembersize(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.backupMemberSize)
}

// int32 backupPriority = 12;
inline void NodeInfo_ConfigNodeInfo::clear_backuppriority() {
  backuppriority_ = 0;
}
inline int32_t NodeInfo_ConfigNodeInfo::_internal_backuppriority() const {
  return backuppriority_;
}
inline int32_t NodeInfo_ConfigNodeInfo::backuppriority() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.backupPriority)
  return _internal_backuppriority();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_backuppriority(int32_t value) {
  
  backuppriority_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_backuppriority(int32_t value) {
  _internal_set_backuppriority(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.backupPriority)
}

// int32 dbVersion = 13;
inline void NodeInfo_ConfigNodeInfo::clear_dbversion() {
  dbversion_ = 0;
}
inline int32_t NodeInfo_ConfigNodeInfo::_internal_dbversion() const {
  return dbversion_;
}
inline int32_t NodeInfo_ConfigNodeInfo::dbversion() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.dbVersion)
  return _internal_dbversion();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_dbversion(int32_t value) {
  
  dbversion_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_dbversion(int32_t value) {
  _internal_set_dbversion(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.dbVersion)
}

// int32 minParticipationRate = 14;
inline void NodeInfo_ConfigNodeInfo::clear_minparticipationrate() {
  minparticipationrate_ = 0;
}
inline int32_t NodeInfo_ConfigNodeInfo::_internal_minparticipationrate() const {
  return minparticipationrate_;
}
inline int32_t NodeInfo_ConfigNodeInfo::minparticipationrate() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.minParticipationRate)
  return _internal_minparticipationrate();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_minparticipationrate(int32_t value) {
  
  minparticipationrate_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_minparticipationrate(int32_t value) {
  _internal_set_minparticipationrate(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.minParticipationRate)
}

// bool supportConstant = 15;
inline void NodeInfo_ConfigNodeInfo::clear_supportconstant() {
  supportconstant_ = false;
}
inline bool NodeInfo_ConfigNodeInfo::_internal_supportconstant() const {
  return supportconstant_;
}
inline bool NodeInfo_ConfigNodeInfo::supportconstant() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.supportConstant)
  return _internal_supportconstant();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_supportconstant(bool value) {
  
  supportconstant_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_supportconstant(bool value) {
  _internal_set_supportconstant(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.supportConstant)
}

// double minTimeRatio = 16;
inline void NodeInfo_ConfigNodeInfo::clear_mintimeratio() {
  mintimeratio_ = 0;
}
inline double NodeInfo_ConfigNodeInfo::_internal_mintimeratio() const {
  return mintimeratio_;
}
inline double NodeInfo_ConfigNodeInfo::mintimeratio() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.minTimeRatio)
  return _internal_mintimeratio();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_mintimeratio(double value) {
  
  mintimeratio_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_mintimeratio(double value) {
  _internal_set_mintimeratio(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.minTimeRatio)
}

// double maxTimeRatio = 17;
inline void NodeInfo_ConfigNodeInfo::clear_maxtimeratio() {
  maxtimeratio_ = 0;
}
inline double NodeInfo_ConfigNodeInfo::_internal_maxtimeratio() const {
  return maxtimeratio_;
}
inline double NodeInfo_ConfigNodeInfo::maxtimeratio() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.maxTimeRatio)
  return _internal_maxtimeratio();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_maxtimeratio(double value) {
  
  maxtimeratio_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_maxtimeratio(double value) {
  _internal_set_maxtimeratio(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.maxTimeRatio)
}

// int64 allowCreationOfContracts = 18;
inline void NodeInfo_ConfigNodeInfo::clear_allowcreationofcontracts() {
  allowcreationofcontracts_ = int64_t{0};
}
inline int64_t NodeInfo_ConfigNodeInfo::_internal_allowcreationofcontracts() const {
  return allowcreationofcontracts_;
}
inline int64_t NodeInfo_ConfigNodeInfo::allowcreationofcontracts() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.allowCreationOfContracts)
  return _internal_allowcreationofcontracts();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_allowcreationofcontracts(int64_t value) {
  
  allowcreationofcontracts_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_allowcreationofcontracts(int64_t value) {
  _internal_set_allowcreationofcontracts(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.allowCreationOfContracts)
}

// int64 allowAdaptiveEnergy = 19;
inline void NodeInfo_ConfigNodeInfo::clear_allowadaptiveenergy() {
  allowadaptiveenergy_ = int64_t{0};
}
inline int64_t NodeInfo_ConfigNodeInfo::_internal_allowadaptiveenergy() const {
  return allowadaptiveenergy_;
}
inline int64_t NodeInfo_ConfigNodeInfo::allowadaptiveenergy() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.ConfigNodeInfo.allowAdaptiveEnergy)
  return _internal_allowadaptiveenergy();
}
inline void NodeInfo_ConfigNodeInfo::_internal_set_allowadaptiveenergy(int64_t value) {
  
  allowadaptiveenergy_ = value;
}
inline void NodeInfo_ConfigNodeInfo::set_allowadaptiveenergy(int64_t value) {
  _internal_set_allowadaptiveenergy(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.ConfigNodeInfo.allowAdaptiveEnergy)
}

// -------------------------------------------------------------------

// NodeInfo_MachineInfo_MemoryDescInfo

// string name = 1;
inline void NodeInfo_MachineInfo_MemoryDescInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& NodeInfo_MachineInfo_MemoryDescInfo::name() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.MemoryDescInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_MachineInfo_MemoryDescInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.MemoryDescInfo.name)
}
inline std::string* NodeInfo_MachineInfo_MemoryDescInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.MachineInfo.MemoryDescInfo.name)
  return _s;
}
inline const std::string& NodeInfo_MachineInfo_MemoryDescInfo::_internal_name() const {
  return name_.Get();
}
inline void NodeInfo_MachineInfo_MemoryDescInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo_MemoryDescInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo_MemoryDescInfo::release_name() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.MachineInfo.MemoryDescInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_MachineInfo_MemoryDescInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.MachineInfo.MemoryDescInfo.name)
}

// int64 initSize = 2;
inline void NodeInfo_MachineInfo_MemoryDescInfo::clear_initsize() {
  initsize_ = int64_t{0};
}
inline int64_t NodeInfo_MachineInfo_MemoryDescInfo::_internal_initsize() const {
  return initsize_;
}
inline int64_t NodeInfo_MachineInfo_MemoryDescInfo::initsize() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.MemoryDescInfo.initSize)
  return _internal_initsize();
}
inline void NodeInfo_MachineInfo_MemoryDescInfo::_internal_set_initsize(int64_t value) {
  
  initsize_ = value;
}
inline void NodeInfo_MachineInfo_MemoryDescInfo::set_initsize(int64_t value) {
  _internal_set_initsize(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.MemoryDescInfo.initSize)
}

// int64 useSize = 3;
inline void NodeInfo_MachineInfo_MemoryDescInfo::clear_usesize() {
  usesize_ = int64_t{0};
}
inline int64_t NodeInfo_MachineInfo_MemoryDescInfo::_internal_usesize() const {
  return usesize_;
}
inline int64_t NodeInfo_MachineInfo_MemoryDescInfo::usesize() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.MemoryDescInfo.useSize)
  return _internal_usesize();
}
inline void NodeInfo_MachineInfo_MemoryDescInfo::_internal_set_usesize(int64_t value) {
  
  usesize_ = value;
}
inline void NodeInfo_MachineInfo_MemoryDescInfo::set_usesize(int64_t value) {
  _internal_set_usesize(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.MemoryDescInfo.useSize)
}

// int64 maxSize = 4;
inline void NodeInfo_MachineInfo_MemoryDescInfo::clear_maxsize() {
  maxsize_ = int64_t{0};
}
inline int64_t NodeInfo_MachineInfo_MemoryDescInfo::_internal_maxsize() const {
  return maxsize_;
}
inline int64_t NodeInfo_MachineInfo_MemoryDescInfo::maxsize() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.MemoryDescInfo.maxSize)
  return _internal_maxsize();
}
inline void NodeInfo_MachineInfo_MemoryDescInfo::_internal_set_maxsize(int64_t value) {
  
  maxsize_ = value;
}
inline void NodeInfo_MachineInfo_MemoryDescInfo::set_maxsize(int64_t value) {
  _internal_set_maxsize(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.MemoryDescInfo.maxSize)
}

// double useRate = 5;
inline void NodeInfo_MachineInfo_MemoryDescInfo::clear_userate() {
  userate_ = 0;
}
inline double NodeInfo_MachineInfo_MemoryDescInfo::_internal_userate() const {
  return userate_;
}
inline double NodeInfo_MachineInfo_MemoryDescInfo::userate() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.MemoryDescInfo.useRate)
  return _internal_userate();
}
inline void NodeInfo_MachineInfo_MemoryDescInfo::_internal_set_userate(double value) {
  
  userate_ = value;
}
inline void NodeInfo_MachineInfo_MemoryDescInfo::set_userate(double value) {
  _internal_set_userate(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.MemoryDescInfo.useRate)
}

// -------------------------------------------------------------------

// NodeInfo_MachineInfo_DeadLockThreadInfo

// string name = 1;
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& NodeInfo_MachineInfo_DeadLockThreadInfo::name() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_MachineInfo_DeadLockThreadInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.name)
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.name)
  return _s;
}
inline const std::string& NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_name() const {
  return name_.Get();
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::release_name() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.name)
}

// string lockName = 2;
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::clear_lockname() {
  lockname_.ClearToEmpty();
}
inline const std::string& NodeInfo_MachineInfo_DeadLockThreadInfo::lockname() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.lockName)
  return _internal_lockname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_MachineInfo_DeadLockThreadInfo::set_lockname(ArgT0&& arg0, ArgT... args) {
 
 lockname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.lockName)
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::mutable_lockname() {
  std::string* _s = _internal_mutable_lockname();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.lockName)
  return _s;
}
inline const std::string& NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_lockname() const {
  return lockname_.Get();
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_set_lockname(const std::string& value) {
  
  lockname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_mutable_lockname() {
  
  return lockname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::release_lockname() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.lockName)
  return lockname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::set_allocated_lockname(std::string* lockname) {
  if (lockname != nullptr) {
    
  } else {
    
  }
  lockname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lockname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (lockname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    lockname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.lockName)
}

// string lockOwner = 3;
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::clear_lockowner() {
  lockowner_.ClearToEmpty();
}
inline const std::string& NodeInfo_MachineInfo_DeadLockThreadInfo::lockowner() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.lockOwner)
  return _internal_lockowner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_MachineInfo_DeadLockThreadInfo::set_lockowner(ArgT0&& arg0, ArgT... args) {
 
 lockowner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.lockOwner)
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::mutable_lockowner() {
  std::string* _s = _internal_mutable_lockowner();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.lockOwner)
  return _s;
}
inline const std::string& NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_lockowner() const {
  return lockowner_.Get();
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_set_lockowner(const std::string& value) {
  
  lockowner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_mutable_lockowner() {
  
  return lockowner_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::release_lockowner() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.lockOwner)
  return lockowner_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::set_allocated_lockowner(std::string* lockowner) {
  if (lockowner != nullptr) {
    
  } else {
    
  }
  lockowner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lockowner,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (lockowner_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    lockowner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.lockOwner)
}

// string state = 4;
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::clear_state() {
  state_.ClearToEmpty();
}
inline const std::string& NodeInfo_MachineInfo_DeadLockThreadInfo::state() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_MachineInfo_DeadLockThreadInfo::set_state(ArgT0&& arg0, ArgT... args) {
 
 state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.state)
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.state)
  return _s;
}
inline const std::string& NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_state() const {
  return state_.Get();
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_set_state(const std::string& value) {
  
  state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_mutable_state() {
  
  return state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::release_state() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.state)
  return state_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.state)
}

// int64 blockTime = 5;
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::clear_blocktime() {
  blocktime_ = int64_t{0};
}
inline int64_t NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_blocktime() const {
  return blocktime_;
}
inline int64_t NodeInfo_MachineInfo_DeadLockThreadInfo::blocktime() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.blockTime)
  return _internal_blocktime();
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_set_blocktime(int64_t value) {
  
  blocktime_ = value;
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::set_blocktime(int64_t value) {
  _internal_set_blocktime(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.blockTime)
}

// int64 waitTime = 6;
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::clear_waittime() {
  waittime_ = int64_t{0};
}
inline int64_t NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_waittime() const {
  return waittime_;
}
inline int64_t NodeInfo_MachineInfo_DeadLockThreadInfo::waittime() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.waitTime)
  return _internal_waittime();
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_set_waittime(int64_t value) {
  
  waittime_ = value;
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::set_waittime(int64_t value) {
  _internal_set_waittime(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.waitTime)
}

// string stackTrace = 7;
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::clear_stacktrace() {
  stacktrace_.ClearToEmpty();
}
inline const std::string& NodeInfo_MachineInfo_DeadLockThreadInfo::stacktrace() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.stackTrace)
  return _internal_stacktrace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_MachineInfo_DeadLockThreadInfo::set_stacktrace(ArgT0&& arg0, ArgT... args) {
 
 stacktrace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.stackTrace)
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::mutable_stacktrace() {
  std::string* _s = _internal_mutable_stacktrace();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.stackTrace)
  return _s;
}
inline const std::string& NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_stacktrace() const {
  return stacktrace_.Get();
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_set_stacktrace(const std::string& value) {
  
  stacktrace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::_internal_mutable_stacktrace() {
  
  return stacktrace_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo_DeadLockThreadInfo::release_stacktrace() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.stackTrace)
  return stacktrace_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_MachineInfo_DeadLockThreadInfo::set_allocated_stacktrace(std::string* stacktrace) {
  if (stacktrace != nullptr) {
    
  } else {
    
  }
  stacktrace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stacktrace,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stacktrace_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    stacktrace_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.stackTrace)
}

// -------------------------------------------------------------------

// NodeInfo_MachineInfo

// int32 threadCount = 1;
inline void NodeInfo_MachineInfo::clear_threadcount() {
  threadcount_ = 0;
}
inline int32_t NodeInfo_MachineInfo::_internal_threadcount() const {
  return threadcount_;
}
inline int32_t NodeInfo_MachineInfo::threadcount() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.threadCount)
  return _internal_threadcount();
}
inline void NodeInfo_MachineInfo::_internal_set_threadcount(int32_t value) {
  
  threadcount_ = value;
}
inline void NodeInfo_MachineInfo::set_threadcount(int32_t value) {
  _internal_set_threadcount(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.threadCount)
}

// int32 deadLockThreadCount = 2;
inline void NodeInfo_MachineInfo::clear_deadlockthreadcount() {
  deadlockthreadcount_ = 0;
}
inline int32_t NodeInfo_MachineInfo::_internal_deadlockthreadcount() const {
  return deadlockthreadcount_;
}
inline int32_t NodeInfo_MachineInfo::deadlockthreadcount() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.deadLockThreadCount)
  return _internal_deadlockthreadcount();
}
inline void NodeInfo_MachineInfo::_internal_set_deadlockthreadcount(int32_t value) {
  
  deadlockthreadcount_ = value;
}
inline void NodeInfo_MachineInfo::set_deadlockthreadcount(int32_t value) {
  _internal_set_deadlockthreadcount(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.deadLockThreadCount)
}

// int32 cpuCount = 3;
inline void NodeInfo_MachineInfo::clear_cpucount() {
  cpucount_ = 0;
}
inline int32_t NodeInfo_MachineInfo::_internal_cpucount() const {
  return cpucount_;
}
inline int32_t NodeInfo_MachineInfo::cpucount() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.cpuCount)
  return _internal_cpucount();
}
inline void NodeInfo_MachineInfo::_internal_set_cpucount(int32_t value) {
  
  cpucount_ = value;
}
inline void NodeInfo_MachineInfo::set_cpucount(int32_t value) {
  _internal_set_cpucount(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.cpuCount)
}

// int64 totalMemory = 4;
inline void NodeInfo_MachineInfo::clear_totalmemory() {
  totalmemory_ = int64_t{0};
}
inline int64_t NodeInfo_MachineInfo::_internal_totalmemory() const {
  return totalmemory_;
}
inline int64_t NodeInfo_MachineInfo::totalmemory() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.totalMemory)
  return _internal_totalmemory();
}
inline void NodeInfo_MachineInfo::_internal_set_totalmemory(int64_t value) {
  
  totalmemory_ = value;
}
inline void NodeInfo_MachineInfo::set_totalmemory(int64_t value) {
  _internal_set_totalmemory(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.totalMemory)
}

// int64 freeMemory = 5;
inline void NodeInfo_MachineInfo::clear_freememory() {
  freememory_ = int64_t{0};
}
inline int64_t NodeInfo_MachineInfo::_internal_freememory() const {
  return freememory_;
}
inline int64_t NodeInfo_MachineInfo::freememory() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.freeMemory)
  return _internal_freememory();
}
inline void NodeInfo_MachineInfo::_internal_set_freememory(int64_t value) {
  
  freememory_ = value;
}
inline void NodeInfo_MachineInfo::set_freememory(int64_t value) {
  _internal_set_freememory(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.freeMemory)
}

// double cpuRate = 6;
inline void NodeInfo_MachineInfo::clear_cpurate() {
  cpurate_ = 0;
}
inline double NodeInfo_MachineInfo::_internal_cpurate() const {
  return cpurate_;
}
inline double NodeInfo_MachineInfo::cpurate() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.cpuRate)
  return _internal_cpurate();
}
inline void NodeInfo_MachineInfo::_internal_set_cpurate(double value) {
  
  cpurate_ = value;
}
inline void NodeInfo_MachineInfo::set_cpurate(double value) {
  _internal_set_cpurate(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.cpuRate)
}

// string javaVersion = 7;
inline void NodeInfo_MachineInfo::clear_javaversion() {
  javaversion_.ClearToEmpty();
}
inline const std::string& NodeInfo_MachineInfo::javaversion() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.javaVersion)
  return _internal_javaversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_MachineInfo::set_javaversion(ArgT0&& arg0, ArgT... args) {
 
 javaversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.javaVersion)
}
inline std::string* NodeInfo_MachineInfo::mutable_javaversion() {
  std::string* _s = _internal_mutable_javaversion();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.MachineInfo.javaVersion)
  return _s;
}
inline const std::string& NodeInfo_MachineInfo::_internal_javaversion() const {
  return javaversion_.Get();
}
inline void NodeInfo_MachineInfo::_internal_set_javaversion(const std::string& value) {
  
  javaversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo::_internal_mutable_javaversion() {
  
  return javaversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo::release_javaversion() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.MachineInfo.javaVersion)
  return javaversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_MachineInfo::set_allocated_javaversion(std::string* javaversion) {
  if (javaversion != nullptr) {
    
  } else {
    
  }
  javaversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), javaversion,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (javaversion_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    javaversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.MachineInfo.javaVersion)
}

// string osName = 8;
inline void NodeInfo_MachineInfo::clear_osname() {
  osname_.ClearToEmpty();
}
inline const std::string& NodeInfo_MachineInfo::osname() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.osName)
  return _internal_osname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo_MachineInfo::set_osname(ArgT0&& arg0, ArgT... args) {
 
 osname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.osName)
}
inline std::string* NodeInfo_MachineInfo::mutable_osname() {
  std::string* _s = _internal_mutable_osname();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.MachineInfo.osName)
  return _s;
}
inline const std::string& NodeInfo_MachineInfo::_internal_osname() const {
  return osname_.Get();
}
inline void NodeInfo_MachineInfo::_internal_set_osname(const std::string& value) {
  
  osname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo::_internal_mutable_osname() {
  
  return osname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo_MachineInfo::release_osname() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.MachineInfo.osName)
  return osname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo_MachineInfo::set_allocated_osname(std::string* osname) {
  if (osname != nullptr) {
    
  } else {
    
  }
  osname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), osname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (osname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    osname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.MachineInfo.osName)
}

// int64 jvmTotalMemory = 9;
inline void NodeInfo_MachineInfo::clear_jvmtotalmemory() {
  jvmtotalmemory_ = int64_t{0};
}
inline int64_t NodeInfo_MachineInfo::_internal_jvmtotalmemory() const {
  return jvmtotalmemory_;
}
inline int64_t NodeInfo_MachineInfo::jvmtotalmemory() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.jvmTotalMemory)
  return _internal_jvmtotalmemory();
}
inline void NodeInfo_MachineInfo::_internal_set_jvmtotalmemory(int64_t value) {
  
  jvmtotalmemory_ = value;
}
inline void NodeInfo_MachineInfo::set_jvmtotalmemory(int64_t value) {
  _internal_set_jvmtotalmemory(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.jvmTotalMemory)
}

// int64 jvmFreeMemory = 10;
inline void NodeInfo_MachineInfo::clear_jvmfreememory() {
  jvmfreememory_ = int64_t{0};
}
inline int64_t NodeInfo_MachineInfo::_internal_jvmfreememory() const {
  return jvmfreememory_;
}
inline int64_t NodeInfo_MachineInfo::jvmfreememory() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.jvmFreeMemory)
  return _internal_jvmfreememory();
}
inline void NodeInfo_MachineInfo::_internal_set_jvmfreememory(int64_t value) {
  
  jvmfreememory_ = value;
}
inline void NodeInfo_MachineInfo::set_jvmfreememory(int64_t value) {
  _internal_set_jvmfreememory(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.jvmFreeMemory)
}

// double processCpuRate = 11;
inline void NodeInfo_MachineInfo::clear_processcpurate() {
  processcpurate_ = 0;
}
inline double NodeInfo_MachineInfo::_internal_processcpurate() const {
  return processcpurate_;
}
inline double NodeInfo_MachineInfo::processcpurate() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.processCpuRate)
  return _internal_processcpurate();
}
inline void NodeInfo_MachineInfo::_internal_set_processcpurate(double value) {
  
  processcpurate_ = value;
}
inline void NodeInfo_MachineInfo::set_processcpurate(double value) {
  _internal_set_processcpurate(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.MachineInfo.processCpuRate)
}

// repeated .protocol.NodeInfo.MachineInfo.MemoryDescInfo memoryDescInfoList = 12;
inline int NodeInfo_MachineInfo::_internal_memorydescinfolist_size() const {
  return memorydescinfolist_.size();
}
inline int NodeInfo_MachineInfo::memorydescinfolist_size() const {
  return _internal_memorydescinfolist_size();
}
inline void NodeInfo_MachineInfo::clear_memorydescinfolist() {
  memorydescinfolist_.Clear();
}
inline ::protocol::NodeInfo_MachineInfo_MemoryDescInfo* NodeInfo_MachineInfo::mutable_memorydescinfolist(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.MachineInfo.memoryDescInfoList)
  return memorydescinfolist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_MachineInfo_MemoryDescInfo >*
NodeInfo_MachineInfo::mutable_memorydescinfolist() {
  // @@protoc_insertion_point(field_mutable_list:protocol.NodeInfo.MachineInfo.memoryDescInfoList)
  return &memorydescinfolist_;
}
inline const ::protocol::NodeInfo_MachineInfo_MemoryDescInfo& NodeInfo_MachineInfo::_internal_memorydescinfolist(int index) const {
  return memorydescinfolist_.Get(index);
}
inline const ::protocol::NodeInfo_MachineInfo_MemoryDescInfo& NodeInfo_MachineInfo::memorydescinfolist(int index) const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.memoryDescInfoList)
  return _internal_memorydescinfolist(index);
}
inline ::protocol::NodeInfo_MachineInfo_MemoryDescInfo* NodeInfo_MachineInfo::_internal_add_memorydescinfolist() {
  return memorydescinfolist_.Add();
}
inline ::protocol::NodeInfo_MachineInfo_MemoryDescInfo* NodeInfo_MachineInfo::add_memorydescinfolist() {
  ::protocol::NodeInfo_MachineInfo_MemoryDescInfo* _add = _internal_add_memorydescinfolist();
  // @@protoc_insertion_point(field_add:protocol.NodeInfo.MachineInfo.memoryDescInfoList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_MachineInfo_MemoryDescInfo >&
NodeInfo_MachineInfo::memorydescinfolist() const {
  // @@protoc_insertion_point(field_list:protocol.NodeInfo.MachineInfo.memoryDescInfoList)
  return memorydescinfolist_;
}

// repeated .protocol.NodeInfo.MachineInfo.DeadLockThreadInfo deadLockThreadInfoList = 13;
inline int NodeInfo_MachineInfo::_internal_deadlockthreadinfolist_size() const {
  return deadlockthreadinfolist_.size();
}
inline int NodeInfo_MachineInfo::deadlockthreadinfolist_size() const {
  return _internal_deadlockthreadinfolist_size();
}
inline void NodeInfo_MachineInfo::clear_deadlockthreadinfolist() {
  deadlockthreadinfolist_.Clear();
}
inline ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo* NodeInfo_MachineInfo::mutable_deadlockthreadinfolist(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.MachineInfo.deadLockThreadInfoList)
  return deadlockthreadinfolist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo >*
NodeInfo_MachineInfo::mutable_deadlockthreadinfolist() {
  // @@protoc_insertion_point(field_mutable_list:protocol.NodeInfo.MachineInfo.deadLockThreadInfoList)
  return &deadlockthreadinfolist_;
}
inline const ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo& NodeInfo_MachineInfo::_internal_deadlockthreadinfolist(int index) const {
  return deadlockthreadinfolist_.Get(index);
}
inline const ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo& NodeInfo_MachineInfo::deadlockthreadinfolist(int index) const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.MachineInfo.deadLockThreadInfoList)
  return _internal_deadlockthreadinfolist(index);
}
inline ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo* NodeInfo_MachineInfo::_internal_add_deadlockthreadinfolist() {
  return deadlockthreadinfolist_.Add();
}
inline ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo* NodeInfo_MachineInfo::add_deadlockthreadinfolist() {
  ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo* _add = _internal_add_deadlockthreadinfolist();
  // @@protoc_insertion_point(field_add:protocol.NodeInfo.MachineInfo.deadLockThreadInfoList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_MachineInfo_DeadLockThreadInfo >&
NodeInfo_MachineInfo::deadlockthreadinfolist() const {
  // @@protoc_insertion_point(field_list:protocol.NodeInfo.MachineInfo.deadLockThreadInfoList)
  return deadlockthreadinfolist_;
}

// -------------------------------------------------------------------

// NodeInfo

// int64 beginSyncNum = 1;
inline void NodeInfo::clear_beginsyncnum() {
  beginsyncnum_ = int64_t{0};
}
inline int64_t NodeInfo::_internal_beginsyncnum() const {
  return beginsyncnum_;
}
inline int64_t NodeInfo::beginsyncnum() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.beginSyncNum)
  return _internal_beginsyncnum();
}
inline void NodeInfo::_internal_set_beginsyncnum(int64_t value) {
  
  beginsyncnum_ = value;
}
inline void NodeInfo::set_beginsyncnum(int64_t value) {
  _internal_set_beginsyncnum(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.beginSyncNum)
}

// string block = 2;
inline void NodeInfo::clear_block() {
  block_.ClearToEmpty();
}
inline const std::string& NodeInfo::block() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.block)
  return _internal_block();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_block(ArgT0&& arg0, ArgT... args) {
 
 block_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.block)
}
inline std::string* NodeInfo::mutable_block() {
  std::string* _s = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.block)
  return _s;
}
inline const std::string& NodeInfo::_internal_block() const {
  return block_.Get();
}
inline void NodeInfo::_internal_set_block(const std::string& value) {
  
  block_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_block() {
  
  return block_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo::release_block() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.block)
  return block_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo::set_allocated_block(std::string* block) {
  if (block != nullptr) {
    
  } else {
    
  }
  block_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (block_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    block_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.block)
}

// string solidityBlock = 3;
inline void NodeInfo::clear_solidityblock() {
  solidityblock_.ClearToEmpty();
}
inline const std::string& NodeInfo::solidityblock() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.solidityBlock)
  return _internal_solidityblock();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_solidityblock(ArgT0&& arg0, ArgT... args) {
 
 solidityblock_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.solidityBlock)
}
inline std::string* NodeInfo::mutable_solidityblock() {
  std::string* _s = _internal_mutable_solidityblock();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.solidityBlock)
  return _s;
}
inline const std::string& NodeInfo::_internal_solidityblock() const {
  return solidityblock_.Get();
}
inline void NodeInfo::_internal_set_solidityblock(const std::string& value) {
  
  solidityblock_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_solidityblock() {
  
  return solidityblock_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo::release_solidityblock() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.solidityBlock)
  return solidityblock_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo::set_allocated_solidityblock(std::string* solidityblock) {
  if (solidityblock != nullptr) {
    
  } else {
    
  }
  solidityblock_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), solidityblock,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (solidityblock_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    solidityblock_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.solidityBlock)
}

// int32 currentConnectCount = 4;
inline void NodeInfo::clear_currentconnectcount() {
  currentconnectcount_ = 0;
}
inline int32_t NodeInfo::_internal_currentconnectcount() const {
  return currentconnectcount_;
}
inline int32_t NodeInfo::currentconnectcount() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.currentConnectCount)
  return _internal_currentconnectcount();
}
inline void NodeInfo::_internal_set_currentconnectcount(int32_t value) {
  
  currentconnectcount_ = value;
}
inline void NodeInfo::set_currentconnectcount(int32_t value) {
  _internal_set_currentconnectcount(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.currentConnectCount)
}

// int32 activeConnectCount = 5;
inline void NodeInfo::clear_activeconnectcount() {
  activeconnectcount_ = 0;
}
inline int32_t NodeInfo::_internal_activeconnectcount() const {
  return activeconnectcount_;
}
inline int32_t NodeInfo::activeconnectcount() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.activeConnectCount)
  return _internal_activeconnectcount();
}
inline void NodeInfo::_internal_set_activeconnectcount(int32_t value) {
  
  activeconnectcount_ = value;
}
inline void NodeInfo::set_activeconnectcount(int32_t value) {
  _internal_set_activeconnectcount(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.activeConnectCount)
}

// int32 passiveConnectCount = 6;
inline void NodeInfo::clear_passiveconnectcount() {
  passiveconnectcount_ = 0;
}
inline int32_t NodeInfo::_internal_passiveconnectcount() const {
  return passiveconnectcount_;
}
inline int32_t NodeInfo::passiveconnectcount() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.passiveConnectCount)
  return _internal_passiveconnectcount();
}
inline void NodeInfo::_internal_set_passiveconnectcount(int32_t value) {
  
  passiveconnectcount_ = value;
}
inline void NodeInfo::set_passiveconnectcount(int32_t value) {
  _internal_set_passiveconnectcount(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.passiveConnectCount)
}

// int64 totalFlow = 7;
inline void NodeInfo::clear_totalflow() {
  totalflow_ = int64_t{0};
}
inline int64_t NodeInfo::_internal_totalflow() const {
  return totalflow_;
}
inline int64_t NodeInfo::totalflow() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.totalFlow)
  return _internal_totalflow();
}
inline void NodeInfo::_internal_set_totalflow(int64_t value) {
  
  totalflow_ = value;
}
inline void NodeInfo::set_totalflow(int64_t value) {
  _internal_set_totalflow(value);
  // @@protoc_insertion_point(field_set:protocol.NodeInfo.totalFlow)
}

// repeated .protocol.NodeInfo.PeerInfo peerInfoList = 8;
inline int NodeInfo::_internal_peerinfolist_size() const {
  return peerinfolist_.size();
}
inline int NodeInfo::peerinfolist_size() const {
  return _internal_peerinfolist_size();
}
inline void NodeInfo::clear_peerinfolist() {
  peerinfolist_.Clear();
}
inline ::protocol::NodeInfo_PeerInfo* NodeInfo::mutable_peerinfolist(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.peerInfoList)
  return peerinfolist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_PeerInfo >*
NodeInfo::mutable_peerinfolist() {
  // @@protoc_insertion_point(field_mutable_list:protocol.NodeInfo.peerInfoList)
  return &peerinfolist_;
}
inline const ::protocol::NodeInfo_PeerInfo& NodeInfo::_internal_peerinfolist(int index) const {
  return peerinfolist_.Get(index);
}
inline const ::protocol::NodeInfo_PeerInfo& NodeInfo::peerinfolist(int index) const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.peerInfoList)
  return _internal_peerinfolist(index);
}
inline ::protocol::NodeInfo_PeerInfo* NodeInfo::_internal_add_peerinfolist() {
  return peerinfolist_.Add();
}
inline ::protocol::NodeInfo_PeerInfo* NodeInfo::add_peerinfolist() {
  ::protocol::NodeInfo_PeerInfo* _add = _internal_add_peerinfolist();
  // @@protoc_insertion_point(field_add:protocol.NodeInfo.peerInfoList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::NodeInfo_PeerInfo >&
NodeInfo::peerinfolist() const {
  // @@protoc_insertion_point(field_list:protocol.NodeInfo.peerInfoList)
  return peerinfolist_;
}

// .protocol.NodeInfo.ConfigNodeInfo configNodeInfo = 9;
inline bool NodeInfo::_internal_has_confignodeinfo() const {
  return this != internal_default_instance() && confignodeinfo_ != nullptr;
}
inline bool NodeInfo::has_confignodeinfo() const {
  return _internal_has_confignodeinfo();
}
inline void NodeInfo::clear_confignodeinfo() {
  if (GetArenaForAllocation() == nullptr && confignodeinfo_ != nullptr) {
    delete confignodeinfo_;
  }
  confignodeinfo_ = nullptr;
}
inline const ::protocol::NodeInfo_ConfigNodeInfo& NodeInfo::_internal_confignodeinfo() const {
  const ::protocol::NodeInfo_ConfigNodeInfo* p = confignodeinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::NodeInfo_ConfigNodeInfo&>(
      ::protocol::_NodeInfo_ConfigNodeInfo_default_instance_);
}
inline const ::protocol::NodeInfo_ConfigNodeInfo& NodeInfo::confignodeinfo() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.configNodeInfo)
  return _internal_confignodeinfo();
}
inline void NodeInfo::unsafe_arena_set_allocated_confignodeinfo(
    ::protocol::NodeInfo_ConfigNodeInfo* confignodeinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(confignodeinfo_);
  }
  confignodeinfo_ = confignodeinfo;
  if (confignodeinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.NodeInfo.configNodeInfo)
}
inline ::protocol::NodeInfo_ConfigNodeInfo* NodeInfo::release_confignodeinfo() {
  
  ::protocol::NodeInfo_ConfigNodeInfo* temp = confignodeinfo_;
  confignodeinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::NodeInfo_ConfigNodeInfo* NodeInfo::unsafe_arena_release_confignodeinfo() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.configNodeInfo)
  
  ::protocol::NodeInfo_ConfigNodeInfo* temp = confignodeinfo_;
  confignodeinfo_ = nullptr;
  return temp;
}
inline ::protocol::NodeInfo_ConfigNodeInfo* NodeInfo::_internal_mutable_confignodeinfo() {
  
  if (confignodeinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::NodeInfo_ConfigNodeInfo>(GetArenaForAllocation());
    confignodeinfo_ = p;
  }
  return confignodeinfo_;
}
inline ::protocol::NodeInfo_ConfigNodeInfo* NodeInfo::mutable_confignodeinfo() {
  ::protocol::NodeInfo_ConfigNodeInfo* _msg = _internal_mutable_confignodeinfo();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.configNodeInfo)
  return _msg;
}
inline void NodeInfo::set_allocated_confignodeinfo(::protocol::NodeInfo_ConfigNodeInfo* confignodeinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete confignodeinfo_;
  }
  if (confignodeinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::NodeInfo_ConfigNodeInfo>::GetOwningArena(confignodeinfo);
    if (message_arena != submessage_arena) {
      confignodeinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, confignodeinfo, submessage_arena);
    }
    
  } else {
    
  }
  confignodeinfo_ = confignodeinfo;
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.configNodeInfo)
}

// .protocol.NodeInfo.MachineInfo machineInfo = 10;
inline bool NodeInfo::_internal_has_machineinfo() const {
  return this != internal_default_instance() && machineinfo_ != nullptr;
}
inline bool NodeInfo::has_machineinfo() const {
  return _internal_has_machineinfo();
}
inline void NodeInfo::clear_machineinfo() {
  if (GetArenaForAllocation() == nullptr && machineinfo_ != nullptr) {
    delete machineinfo_;
  }
  machineinfo_ = nullptr;
}
inline const ::protocol::NodeInfo_MachineInfo& NodeInfo::_internal_machineinfo() const {
  const ::protocol::NodeInfo_MachineInfo* p = machineinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::NodeInfo_MachineInfo&>(
      ::protocol::_NodeInfo_MachineInfo_default_instance_);
}
inline const ::protocol::NodeInfo_MachineInfo& NodeInfo::machineinfo() const {
  // @@protoc_insertion_point(field_get:protocol.NodeInfo.machineInfo)
  return _internal_machineinfo();
}
inline void NodeInfo::unsafe_arena_set_allocated_machineinfo(
    ::protocol::NodeInfo_MachineInfo* machineinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(machineinfo_);
  }
  machineinfo_ = machineinfo;
  if (machineinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.NodeInfo.machineInfo)
}
inline ::protocol::NodeInfo_MachineInfo* NodeInfo::release_machineinfo() {
  
  ::protocol::NodeInfo_MachineInfo* temp = machineinfo_;
  machineinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::NodeInfo_MachineInfo* NodeInfo::unsafe_arena_release_machineinfo() {
  // @@protoc_insertion_point(field_release:protocol.NodeInfo.machineInfo)
  
  ::protocol::NodeInfo_MachineInfo* temp = machineinfo_;
  machineinfo_ = nullptr;
  return temp;
}
inline ::protocol::NodeInfo_MachineInfo* NodeInfo::_internal_mutable_machineinfo() {
  
  if (machineinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::NodeInfo_MachineInfo>(GetArenaForAllocation());
    machineinfo_ = p;
  }
  return machineinfo_;
}
inline ::protocol::NodeInfo_MachineInfo* NodeInfo::mutable_machineinfo() {
  ::protocol::NodeInfo_MachineInfo* _msg = _internal_mutable_machineinfo();
  // @@protoc_insertion_point(field_mutable:protocol.NodeInfo.machineInfo)
  return _msg;
}
inline void NodeInfo::set_allocated_machineinfo(::protocol::NodeInfo_MachineInfo* machineinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete machineinfo_;
  }
  if (machineinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::NodeInfo_MachineInfo>::GetOwningArena(machineinfo);
    if (message_arena != submessage_arena) {
      machineinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, machineinfo, submessage_arena);
    }
    
  } else {
    
  }
  machineinfo_ = machineinfo;
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeInfo.machineInfo)
}

// map<string, string> cheatWitnessInfoMap = 11;
inline int NodeInfo::_internal_cheatwitnessinfomap_size() const {
  return cheatwitnessinfomap_.size();
}
inline int NodeInfo::cheatwitnessinfomap_size() const {
  return _internal_cheatwitnessinfomap_size();
}
inline void NodeInfo::clear_cheatwitnessinfomap() {
  cheatwitnessinfomap_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodeInfo::_internal_cheatwitnessinfomap() const {
  return cheatwitnessinfomap_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodeInfo::cheatwitnessinfomap() const {
  // @@protoc_insertion_point(field_map:protocol.NodeInfo.cheatWitnessInfoMap)
  return _internal_cheatwitnessinfomap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodeInfo::_internal_mutable_cheatwitnessinfomap() {
  return cheatwitnessinfomap_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodeInfo::mutable_cheatwitnessinfomap() {
  // @@protoc_insertion_point(field_mutable_map:protocol.NodeInfo.cheatWitnessInfoMap)
  return _internal_mutable_cheatwitnessinfomap();
}

// -------------------------------------------------------------------

// MetricsInfo_NodeInfo

// string ip = 1;
inline void MetricsInfo_NodeInfo::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& MetricsInfo_NodeInfo::ip() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NodeInfo.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricsInfo_NodeInfo::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NodeInfo.ip)
}
inline std::string* MetricsInfo_NodeInfo::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NodeInfo.ip)
  return _s;
}
inline const std::string& MetricsInfo_NodeInfo::_internal_ip() const {
  return ip_.Get();
}
inline void MetricsInfo_NodeInfo::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetricsInfo_NodeInfo::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetricsInfo_NodeInfo::release_ip() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NodeInfo.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetricsInfo_NodeInfo::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NodeInfo.ip)
}

// int32 nodeType = 2;
inline void MetricsInfo_NodeInfo::clear_nodetype() {
  nodetype_ = 0;
}
inline int32_t MetricsInfo_NodeInfo::_internal_nodetype() const {
  return nodetype_;
}
inline int32_t MetricsInfo_NodeInfo::nodetype() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NodeInfo.nodeType)
  return _internal_nodetype();
}
inline void MetricsInfo_NodeInfo::_internal_set_nodetype(int32_t value) {
  
  nodetype_ = value;
}
inline void MetricsInfo_NodeInfo::set_nodetype(int32_t value) {
  _internal_set_nodetype(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NodeInfo.nodeType)
}

// string version = 3;
inline void MetricsInfo_NodeInfo::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& MetricsInfo_NodeInfo::version() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NodeInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricsInfo_NodeInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NodeInfo.version)
}
inline std::string* MetricsInfo_NodeInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NodeInfo.version)
  return _s;
}
inline const std::string& MetricsInfo_NodeInfo::_internal_version() const {
  return version_.Get();
}
inline void MetricsInfo_NodeInfo::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetricsInfo_NodeInfo::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetricsInfo_NodeInfo::release_version() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NodeInfo.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetricsInfo_NodeInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NodeInfo.version)
}

// int32 backupStatus = 4;
inline void MetricsInfo_NodeInfo::clear_backupstatus() {
  backupstatus_ = 0;
}
inline int32_t MetricsInfo_NodeInfo::_internal_backupstatus() const {
  return backupstatus_;
}
inline int32_t MetricsInfo_NodeInfo::backupstatus() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NodeInfo.backupStatus)
  return _internal_backupstatus();
}
inline void MetricsInfo_NodeInfo::_internal_set_backupstatus(int32_t value) {
  
  backupstatus_ = value;
}
inline void MetricsInfo_NodeInfo::set_backupstatus(int32_t value) {
  _internal_set_backupstatus(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NodeInfo.backupStatus)
}

// -------------------------------------------------------------------

// MetricsInfo_BlockChainInfo_Witness

// string address = 1;
inline void MetricsInfo_BlockChainInfo_Witness::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& MetricsInfo_BlockChainInfo_Witness::address() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.Witness.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricsInfo_BlockChainInfo_Witness::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.BlockChainInfo.Witness.address)
}
inline std::string* MetricsInfo_BlockChainInfo_Witness::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.BlockChainInfo.Witness.address)
  return _s;
}
inline const std::string& MetricsInfo_BlockChainInfo_Witness::_internal_address() const {
  return address_.Get();
}
inline void MetricsInfo_BlockChainInfo_Witness::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetricsInfo_BlockChainInfo_Witness::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetricsInfo_BlockChainInfo_Witness::release_address() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.BlockChainInfo.Witness.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetricsInfo_BlockChainInfo_Witness::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.BlockChainInfo.Witness.address)
}

// int32 version = 2;
inline void MetricsInfo_BlockChainInfo_Witness::clear_version() {
  version_ = 0;
}
inline int32_t MetricsInfo_BlockChainInfo_Witness::_internal_version() const {
  return version_;
}
inline int32_t MetricsInfo_BlockChainInfo_Witness::version() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.Witness.version)
  return _internal_version();
}
inline void MetricsInfo_BlockChainInfo_Witness::_internal_set_version(int32_t value) {
  
  version_ = value;
}
inline void MetricsInfo_BlockChainInfo_Witness::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.BlockChainInfo.Witness.version)
}

// -------------------------------------------------------------------

// MetricsInfo_BlockChainInfo_DupWitness

// string address = 1;
inline void MetricsInfo_BlockChainInfo_DupWitness::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& MetricsInfo_BlockChainInfo_DupWitness::address() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.DupWitness.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricsInfo_BlockChainInfo_DupWitness::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.BlockChainInfo.DupWitness.address)
}
inline std::string* MetricsInfo_BlockChainInfo_DupWitness::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.BlockChainInfo.DupWitness.address)
  return _s;
}
inline const std::string& MetricsInfo_BlockChainInfo_DupWitness::_internal_address() const {
  return address_.Get();
}
inline void MetricsInfo_BlockChainInfo_DupWitness::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetricsInfo_BlockChainInfo_DupWitness::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetricsInfo_BlockChainInfo_DupWitness::release_address() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.BlockChainInfo.DupWitness.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetricsInfo_BlockChainInfo_DupWitness::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.BlockChainInfo.DupWitness.address)
}

// int64 blockNum = 2;
inline void MetricsInfo_BlockChainInfo_DupWitness::clear_blocknum() {
  blocknum_ = int64_t{0};
}
inline int64_t MetricsInfo_BlockChainInfo_DupWitness::_internal_blocknum() const {
  return blocknum_;
}
inline int64_t MetricsInfo_BlockChainInfo_DupWitness::blocknum() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.DupWitness.blockNum)
  return _internal_blocknum();
}
inline void MetricsInfo_BlockChainInfo_DupWitness::_internal_set_blocknum(int64_t value) {
  
  blocknum_ = value;
}
inline void MetricsInfo_BlockChainInfo_DupWitness::set_blocknum(int64_t value) {
  _internal_set_blocknum(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.BlockChainInfo.DupWitness.blockNum)
}

// int32 count = 3;
inline void MetricsInfo_BlockChainInfo_DupWitness::clear_count() {
  count_ = 0;
}
inline int32_t MetricsInfo_BlockChainInfo_DupWitness::_internal_count() const {
  return count_;
}
inline int32_t MetricsInfo_BlockChainInfo_DupWitness::count() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.DupWitness.count)
  return _internal_count();
}
inline void MetricsInfo_BlockChainInfo_DupWitness::_internal_set_count(int32_t value) {
  
  count_ = value;
}
inline void MetricsInfo_BlockChainInfo_DupWitness::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.BlockChainInfo.DupWitness.count)
}

// -------------------------------------------------------------------

// MetricsInfo_BlockChainInfo

// int64 headBlockNum = 1;
inline void MetricsInfo_BlockChainInfo::clear_headblocknum() {
  headblocknum_ = int64_t{0};
}
inline int64_t MetricsInfo_BlockChainInfo::_internal_headblocknum() const {
  return headblocknum_;
}
inline int64_t MetricsInfo_BlockChainInfo::headblocknum() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.headBlockNum)
  return _internal_headblocknum();
}
inline void MetricsInfo_BlockChainInfo::_internal_set_headblocknum(int64_t value) {
  
  headblocknum_ = value;
}
inline void MetricsInfo_BlockChainInfo::set_headblocknum(int64_t value) {
  _internal_set_headblocknum(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.BlockChainInfo.headBlockNum)
}

// int64 headBlockTimestamp = 2;
inline void MetricsInfo_BlockChainInfo::clear_headblocktimestamp() {
  headblocktimestamp_ = int64_t{0};
}
inline int64_t MetricsInfo_BlockChainInfo::_internal_headblocktimestamp() const {
  return headblocktimestamp_;
}
inline int64_t MetricsInfo_BlockChainInfo::headblocktimestamp() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.headBlockTimestamp)
  return _internal_headblocktimestamp();
}
inline void MetricsInfo_BlockChainInfo::_internal_set_headblocktimestamp(int64_t value) {
  
  headblocktimestamp_ = value;
}
inline void MetricsInfo_BlockChainInfo::set_headblocktimestamp(int64_t value) {
  _internal_set_headblocktimestamp(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.BlockChainInfo.headBlockTimestamp)
}

// string headBlockHash = 3;
inline void MetricsInfo_BlockChainInfo::clear_headblockhash() {
  headblockhash_.ClearToEmpty();
}
inline const std::string& MetricsInfo_BlockChainInfo::headblockhash() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.headBlockHash)
  return _internal_headblockhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricsInfo_BlockChainInfo::set_headblockhash(ArgT0&& arg0, ArgT... args) {
 
 headblockhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.BlockChainInfo.headBlockHash)
}
inline std::string* MetricsInfo_BlockChainInfo::mutable_headblockhash() {
  std::string* _s = _internal_mutable_headblockhash();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.BlockChainInfo.headBlockHash)
  return _s;
}
inline const std::string& MetricsInfo_BlockChainInfo::_internal_headblockhash() const {
  return headblockhash_.Get();
}
inline void MetricsInfo_BlockChainInfo::_internal_set_headblockhash(const std::string& value) {
  
  headblockhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetricsInfo_BlockChainInfo::_internal_mutable_headblockhash() {
  
  return headblockhash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetricsInfo_BlockChainInfo::release_headblockhash() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.BlockChainInfo.headBlockHash)
  return headblockhash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetricsInfo_BlockChainInfo::set_allocated_headblockhash(std::string* headblockhash) {
  if (headblockhash != nullptr) {
    
  } else {
    
  }
  headblockhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), headblockhash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (headblockhash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    headblockhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.BlockChainInfo.headBlockHash)
}

// int32 forkCount = 4;
inline void MetricsInfo_BlockChainInfo::clear_forkcount() {
  forkcount_ = 0;
}
inline int32_t MetricsInfo_BlockChainInfo::_internal_forkcount() const {
  return forkcount_;
}
inline int32_t MetricsInfo_BlockChainInfo::forkcount() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.forkCount)
  return _internal_forkcount();
}
inline void MetricsInfo_BlockChainInfo::_internal_set_forkcount(int32_t value) {
  
  forkcount_ = value;
}
inline void MetricsInfo_BlockChainInfo::set_forkcount(int32_t value) {
  _internal_set_forkcount(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.BlockChainInfo.forkCount)
}

// int32 failForkCount = 5;
inline void MetricsInfo_BlockChainInfo::clear_failforkcount() {
  failforkcount_ = 0;
}
inline int32_t MetricsInfo_BlockChainInfo::_internal_failforkcount() const {
  return failforkcount_;
}
inline int32_t MetricsInfo_BlockChainInfo::failforkcount() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.failForkCount)
  return _internal_failforkcount();
}
inline void MetricsInfo_BlockChainInfo::_internal_set_failforkcount(int32_t value) {
  
  failforkcount_ = value;
}
inline void MetricsInfo_BlockChainInfo::set_failforkcount(int32_t value) {
  _internal_set_failforkcount(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.BlockChainInfo.failForkCount)
}

// .protocol.MetricsInfo.RateInfo blockProcessTime = 6;
inline bool MetricsInfo_BlockChainInfo::_internal_has_blockprocesstime() const {
  return this != internal_default_instance() && blockprocesstime_ != nullptr;
}
inline bool MetricsInfo_BlockChainInfo::has_blockprocesstime() const {
  return _internal_has_blockprocesstime();
}
inline void MetricsInfo_BlockChainInfo::clear_blockprocesstime() {
  if (GetArenaForAllocation() == nullptr && blockprocesstime_ != nullptr) {
    delete blockprocesstime_;
  }
  blockprocesstime_ = nullptr;
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_BlockChainInfo::_internal_blockprocesstime() const {
  const ::protocol::MetricsInfo_RateInfo* p = blockprocesstime_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_RateInfo&>(
      ::protocol::_MetricsInfo_RateInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_BlockChainInfo::blockprocesstime() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.blockProcessTime)
  return _internal_blockprocesstime();
}
inline void MetricsInfo_BlockChainInfo::unsafe_arena_set_allocated_blockprocesstime(
    ::protocol::MetricsInfo_RateInfo* blockprocesstime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blockprocesstime_);
  }
  blockprocesstime_ = blockprocesstime;
  if (blockprocesstime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.BlockChainInfo.blockProcessTime)
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_BlockChainInfo::release_blockprocesstime() {
  
  ::protocol::MetricsInfo_RateInfo* temp = blockprocesstime_;
  blockprocesstime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_BlockChainInfo::unsafe_arena_release_blockprocesstime() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.BlockChainInfo.blockProcessTime)
  
  ::protocol::MetricsInfo_RateInfo* temp = blockprocesstime_;
  blockprocesstime_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_BlockChainInfo::_internal_mutable_blockprocesstime() {
  
  if (blockprocesstime_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(GetArenaForAllocation());
    blockprocesstime_ = p;
  }
  return blockprocesstime_;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_BlockChainInfo::mutable_blockprocesstime() {
  ::protocol::MetricsInfo_RateInfo* _msg = _internal_mutable_blockprocesstime();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.BlockChainInfo.blockProcessTime)
  return _msg;
}
inline void MetricsInfo_BlockChainInfo::set_allocated_blockprocesstime(::protocol::MetricsInfo_RateInfo* blockprocesstime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete blockprocesstime_;
  }
  if (blockprocesstime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_RateInfo>::GetOwningArena(blockprocesstime);
    if (message_arena != submessage_arena) {
      blockprocesstime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blockprocesstime, submessage_arena);
    }
    
  } else {
    
  }
  blockprocesstime_ = blockprocesstime;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.BlockChainInfo.blockProcessTime)
}

// .protocol.MetricsInfo.RateInfo tps = 7;
inline bool MetricsInfo_BlockChainInfo::_internal_has_tps() const {
  return this != internal_default_instance() && tps_ != nullptr;
}
inline bool MetricsInfo_BlockChainInfo::has_tps() const {
  return _internal_has_tps();
}
inline void MetricsInfo_BlockChainInfo::clear_tps() {
  if (GetArenaForAllocation() == nullptr && tps_ != nullptr) {
    delete tps_;
  }
  tps_ = nullptr;
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_BlockChainInfo::_internal_tps() const {
  const ::protocol::MetricsInfo_RateInfo* p = tps_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_RateInfo&>(
      ::protocol::_MetricsInfo_RateInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_BlockChainInfo::tps() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.tps)
  return _internal_tps();
}
inline void MetricsInfo_BlockChainInfo::unsafe_arena_set_allocated_tps(
    ::protocol::MetricsInfo_RateInfo* tps) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tps_);
  }
  tps_ = tps;
  if (tps) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.BlockChainInfo.tps)
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_BlockChainInfo::release_tps() {
  
  ::protocol::MetricsInfo_RateInfo* temp = tps_;
  tps_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_BlockChainInfo::unsafe_arena_release_tps() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.BlockChainInfo.tps)
  
  ::protocol::MetricsInfo_RateInfo* temp = tps_;
  tps_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_BlockChainInfo::_internal_mutable_tps() {
  
  if (tps_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(GetArenaForAllocation());
    tps_ = p;
  }
  return tps_;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_BlockChainInfo::mutable_tps() {
  ::protocol::MetricsInfo_RateInfo* _msg = _internal_mutable_tps();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.BlockChainInfo.tps)
  return _msg;
}
inline void MetricsInfo_BlockChainInfo::set_allocated_tps(::protocol::MetricsInfo_RateInfo* tps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tps_;
  }
  if (tps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_RateInfo>::GetOwningArena(tps);
    if (message_arena != submessage_arena) {
      tps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tps, submessage_arena);
    }
    
  } else {
    
  }
  tps_ = tps;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.BlockChainInfo.tps)
}

// int32 transactionCacheSize = 8;
inline void MetricsInfo_BlockChainInfo::clear_transactioncachesize() {
  transactioncachesize_ = 0;
}
inline int32_t MetricsInfo_BlockChainInfo::_internal_transactioncachesize() const {
  return transactioncachesize_;
}
inline int32_t MetricsInfo_BlockChainInfo::transactioncachesize() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.transactionCacheSize)
  return _internal_transactioncachesize();
}
inline void MetricsInfo_BlockChainInfo::_internal_set_transactioncachesize(int32_t value) {
  
  transactioncachesize_ = value;
}
inline void MetricsInfo_BlockChainInfo::set_transactioncachesize(int32_t value) {
  _internal_set_transactioncachesize(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.BlockChainInfo.transactionCacheSize)
}

// .protocol.MetricsInfo.RateInfo missedTransaction = 9;
inline bool MetricsInfo_BlockChainInfo::_internal_has_missedtransaction() const {
  return this != internal_default_instance() && missedtransaction_ != nullptr;
}
inline bool MetricsInfo_BlockChainInfo::has_missedtransaction() const {
  return _internal_has_missedtransaction();
}
inline void MetricsInfo_BlockChainInfo::clear_missedtransaction() {
  if (GetArenaForAllocation() == nullptr && missedtransaction_ != nullptr) {
    delete missedtransaction_;
  }
  missedtransaction_ = nullptr;
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_BlockChainInfo::_internal_missedtransaction() const {
  const ::protocol::MetricsInfo_RateInfo* p = missedtransaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_RateInfo&>(
      ::protocol::_MetricsInfo_RateInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_BlockChainInfo::missedtransaction() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.missedTransaction)
  return _internal_missedtransaction();
}
inline void MetricsInfo_BlockChainInfo::unsafe_arena_set_allocated_missedtransaction(
    ::protocol::MetricsInfo_RateInfo* missedtransaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(missedtransaction_);
  }
  missedtransaction_ = missedtransaction;
  if (missedtransaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.BlockChainInfo.missedTransaction)
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_BlockChainInfo::release_missedtransaction() {
  
  ::protocol::MetricsInfo_RateInfo* temp = missedtransaction_;
  missedtransaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_BlockChainInfo::unsafe_arena_release_missedtransaction() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.BlockChainInfo.missedTransaction)
  
  ::protocol::MetricsInfo_RateInfo* temp = missedtransaction_;
  missedtransaction_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_BlockChainInfo::_internal_mutable_missedtransaction() {
  
  if (missedtransaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(GetArenaForAllocation());
    missedtransaction_ = p;
  }
  return missedtransaction_;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_BlockChainInfo::mutable_missedtransaction() {
  ::protocol::MetricsInfo_RateInfo* _msg = _internal_mutable_missedtransaction();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.BlockChainInfo.missedTransaction)
  return _msg;
}
inline void MetricsInfo_BlockChainInfo::set_allocated_missedtransaction(::protocol::MetricsInfo_RateInfo* missedtransaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete missedtransaction_;
  }
  if (missedtransaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_RateInfo>::GetOwningArena(missedtransaction);
    if (message_arena != submessage_arena) {
      missedtransaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, missedtransaction, submessage_arena);
    }
    
  } else {
    
  }
  missedtransaction_ = missedtransaction;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.BlockChainInfo.missedTransaction)
}

// repeated .protocol.MetricsInfo.BlockChainInfo.Witness witnesses = 10;
inline int MetricsInfo_BlockChainInfo::_internal_witnesses_size() const {
  return witnesses_.size();
}
inline int MetricsInfo_BlockChainInfo::witnesses_size() const {
  return _internal_witnesses_size();
}
inline void MetricsInfo_BlockChainInfo::clear_witnesses() {
  witnesses_.Clear();
}
inline ::protocol::MetricsInfo_BlockChainInfo_Witness* MetricsInfo_BlockChainInfo::mutable_witnesses(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.BlockChainInfo.witnesses)
  return witnesses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_BlockChainInfo_Witness >*
MetricsInfo_BlockChainInfo::mutable_witnesses() {
  // @@protoc_insertion_point(field_mutable_list:protocol.MetricsInfo.BlockChainInfo.witnesses)
  return &witnesses_;
}
inline const ::protocol::MetricsInfo_BlockChainInfo_Witness& MetricsInfo_BlockChainInfo::_internal_witnesses(int index) const {
  return witnesses_.Get(index);
}
inline const ::protocol::MetricsInfo_BlockChainInfo_Witness& MetricsInfo_BlockChainInfo::witnesses(int index) const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.witnesses)
  return _internal_witnesses(index);
}
inline ::protocol::MetricsInfo_BlockChainInfo_Witness* MetricsInfo_BlockChainInfo::_internal_add_witnesses() {
  return witnesses_.Add();
}
inline ::protocol::MetricsInfo_BlockChainInfo_Witness* MetricsInfo_BlockChainInfo::add_witnesses() {
  ::protocol::MetricsInfo_BlockChainInfo_Witness* _add = _internal_add_witnesses();
  // @@protoc_insertion_point(field_add:protocol.MetricsInfo.BlockChainInfo.witnesses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_BlockChainInfo_Witness >&
MetricsInfo_BlockChainInfo::witnesses() const {
  // @@protoc_insertion_point(field_list:protocol.MetricsInfo.BlockChainInfo.witnesses)
  return witnesses_;
}

// int64 failProcessBlockNum = 11;
inline void MetricsInfo_BlockChainInfo::clear_failprocessblocknum() {
  failprocessblocknum_ = int64_t{0};
}
inline int64_t MetricsInfo_BlockChainInfo::_internal_failprocessblocknum() const {
  return failprocessblocknum_;
}
inline int64_t MetricsInfo_BlockChainInfo::failprocessblocknum() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.failProcessBlockNum)
  return _internal_failprocessblocknum();
}
inline void MetricsInfo_BlockChainInfo::_internal_set_failprocessblocknum(int64_t value) {
  
  failprocessblocknum_ = value;
}
inline void MetricsInfo_BlockChainInfo::set_failprocessblocknum(int64_t value) {
  _internal_set_failprocessblocknum(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.BlockChainInfo.failProcessBlockNum)
}

// string failProcessBlockReason = 12;
inline void MetricsInfo_BlockChainInfo::clear_failprocessblockreason() {
  failprocessblockreason_.ClearToEmpty();
}
inline const std::string& MetricsInfo_BlockChainInfo::failprocessblockreason() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.failProcessBlockReason)
  return _internal_failprocessblockreason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricsInfo_BlockChainInfo::set_failprocessblockreason(ArgT0&& arg0, ArgT... args) {
 
 failprocessblockreason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.BlockChainInfo.failProcessBlockReason)
}
inline std::string* MetricsInfo_BlockChainInfo::mutable_failprocessblockreason() {
  std::string* _s = _internal_mutable_failprocessblockreason();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.BlockChainInfo.failProcessBlockReason)
  return _s;
}
inline const std::string& MetricsInfo_BlockChainInfo::_internal_failprocessblockreason() const {
  return failprocessblockreason_.Get();
}
inline void MetricsInfo_BlockChainInfo::_internal_set_failprocessblockreason(const std::string& value) {
  
  failprocessblockreason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetricsInfo_BlockChainInfo::_internal_mutable_failprocessblockreason() {
  
  return failprocessblockreason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetricsInfo_BlockChainInfo::release_failprocessblockreason() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.BlockChainInfo.failProcessBlockReason)
  return failprocessblockreason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetricsInfo_BlockChainInfo::set_allocated_failprocessblockreason(std::string* failprocessblockreason) {
  if (failprocessblockreason != nullptr) {
    
  } else {
    
  }
  failprocessblockreason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), failprocessblockreason,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (failprocessblockreason_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    failprocessblockreason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.BlockChainInfo.failProcessBlockReason)
}

// repeated .protocol.MetricsInfo.BlockChainInfo.DupWitness dupWitness = 13;
inline int MetricsInfo_BlockChainInfo::_internal_dupwitness_size() const {
  return dupwitness_.size();
}
inline int MetricsInfo_BlockChainInfo::dupwitness_size() const {
  return _internal_dupwitness_size();
}
inline void MetricsInfo_BlockChainInfo::clear_dupwitness() {
  dupwitness_.Clear();
}
inline ::protocol::MetricsInfo_BlockChainInfo_DupWitness* MetricsInfo_BlockChainInfo::mutable_dupwitness(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.BlockChainInfo.dupWitness)
  return dupwitness_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_BlockChainInfo_DupWitness >*
MetricsInfo_BlockChainInfo::mutable_dupwitness() {
  // @@protoc_insertion_point(field_mutable_list:protocol.MetricsInfo.BlockChainInfo.dupWitness)
  return &dupwitness_;
}
inline const ::protocol::MetricsInfo_BlockChainInfo_DupWitness& MetricsInfo_BlockChainInfo::_internal_dupwitness(int index) const {
  return dupwitness_.Get(index);
}
inline const ::protocol::MetricsInfo_BlockChainInfo_DupWitness& MetricsInfo_BlockChainInfo::dupwitness(int index) const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.BlockChainInfo.dupWitness)
  return _internal_dupwitness(index);
}
inline ::protocol::MetricsInfo_BlockChainInfo_DupWitness* MetricsInfo_BlockChainInfo::_internal_add_dupwitness() {
  return dupwitness_.Add();
}
inline ::protocol::MetricsInfo_BlockChainInfo_DupWitness* MetricsInfo_BlockChainInfo::add_dupwitness() {
  ::protocol::MetricsInfo_BlockChainInfo_DupWitness* _add = _internal_add_dupwitness();
  // @@protoc_insertion_point(field_add:protocol.MetricsInfo.BlockChainInfo.dupWitness)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_BlockChainInfo_DupWitness >&
MetricsInfo_BlockChainInfo::dupwitness() const {
  // @@protoc_insertion_point(field_list:protocol.MetricsInfo.BlockChainInfo.dupWitness)
  return dupwitness_;
}

// -------------------------------------------------------------------

// MetricsInfo_RateInfo

// int64 count = 1;
inline void MetricsInfo_RateInfo::clear_count() {
  count_ = int64_t{0};
}
inline int64_t MetricsInfo_RateInfo::_internal_count() const {
  return count_;
}
inline int64_t MetricsInfo_RateInfo::count() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.RateInfo.count)
  return _internal_count();
}
inline void MetricsInfo_RateInfo::_internal_set_count(int64_t value) {
  
  count_ = value;
}
inline void MetricsInfo_RateInfo::set_count(int64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.RateInfo.count)
}

// double meanRate = 2;
inline void MetricsInfo_RateInfo::clear_meanrate() {
  meanrate_ = 0;
}
inline double MetricsInfo_RateInfo::_internal_meanrate() const {
  return meanrate_;
}
inline double MetricsInfo_RateInfo::meanrate() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.RateInfo.meanRate)
  return _internal_meanrate();
}
inline void MetricsInfo_RateInfo::_internal_set_meanrate(double value) {
  
  meanrate_ = value;
}
inline void MetricsInfo_RateInfo::set_meanrate(double value) {
  _internal_set_meanrate(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.RateInfo.meanRate)
}

// double oneMinuteRate = 3;
inline void MetricsInfo_RateInfo::clear_oneminuterate() {
  oneminuterate_ = 0;
}
inline double MetricsInfo_RateInfo::_internal_oneminuterate() const {
  return oneminuterate_;
}
inline double MetricsInfo_RateInfo::oneminuterate() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.RateInfo.oneMinuteRate)
  return _internal_oneminuterate();
}
inline void MetricsInfo_RateInfo::_internal_set_oneminuterate(double value) {
  
  oneminuterate_ = value;
}
inline void MetricsInfo_RateInfo::set_oneminuterate(double value) {
  _internal_set_oneminuterate(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.RateInfo.oneMinuteRate)
}

// double fiveMinuteRate = 4;
inline void MetricsInfo_RateInfo::clear_fiveminuterate() {
  fiveminuterate_ = 0;
}
inline double MetricsInfo_RateInfo::_internal_fiveminuterate() const {
  return fiveminuterate_;
}
inline double MetricsInfo_RateInfo::fiveminuterate() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.RateInfo.fiveMinuteRate)
  return _internal_fiveminuterate();
}
inline void MetricsInfo_RateInfo::_internal_set_fiveminuterate(double value) {
  
  fiveminuterate_ = value;
}
inline void MetricsInfo_RateInfo::set_fiveminuterate(double value) {
  _internal_set_fiveminuterate(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.RateInfo.fiveMinuteRate)
}

// double fifteenMinuteRate = 5;
inline void MetricsInfo_RateInfo::clear_fifteenminuterate() {
  fifteenminuterate_ = 0;
}
inline double MetricsInfo_RateInfo::_internal_fifteenminuterate() const {
  return fifteenminuterate_;
}
inline double MetricsInfo_RateInfo::fifteenminuterate() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.RateInfo.fifteenMinuteRate)
  return _internal_fifteenminuterate();
}
inline void MetricsInfo_RateInfo::_internal_set_fifteenminuterate(double value) {
  
  fifteenminuterate_ = value;
}
inline void MetricsInfo_RateInfo::set_fifteenminuterate(double value) {
  _internal_set_fifteenminuterate(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.RateInfo.fifteenMinuteRate)
}

// -------------------------------------------------------------------

// MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo

// string name = 1;
inline void MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::name() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.name)
}
inline std::string* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.name)
  return _s;
}
inline const std::string& MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::_internal_name() const {
  return name_.Get();
}
inline void MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::release_name() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.name)
}

// .protocol.MetricsInfo.RateInfo qps = 2;
inline bool MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::_internal_has_qps() const {
  return this != internal_default_instance() && qps_ != nullptr;
}
inline bool MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::has_qps() const {
  return _internal_has_qps();
}
inline void MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::clear_qps() {
  if (GetArenaForAllocation() == nullptr && qps_ != nullptr) {
    delete qps_;
  }
  qps_ = nullptr;
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::_internal_qps() const {
  const ::protocol::MetricsInfo_RateInfo* p = qps_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_RateInfo&>(
      ::protocol::_MetricsInfo_RateInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::qps() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.qps)
  return _internal_qps();
}
inline void MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::unsafe_arena_set_allocated_qps(
    ::protocol::MetricsInfo_RateInfo* qps) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(qps_);
  }
  qps_ = qps;
  if (qps) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.qps)
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::release_qps() {
  
  ::protocol::MetricsInfo_RateInfo* temp = qps_;
  qps_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::unsafe_arena_release_qps() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.qps)
  
  ::protocol::MetricsInfo_RateInfo* temp = qps_;
  qps_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::_internal_mutable_qps() {
  
  if (qps_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(GetArenaForAllocation());
    qps_ = p;
  }
  return qps_;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::mutable_qps() {
  ::protocol::MetricsInfo_RateInfo* _msg = _internal_mutable_qps();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.qps)
  return _msg;
}
inline void MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::set_allocated_qps(::protocol::MetricsInfo_RateInfo* qps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete qps_;
  }
  if (qps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_RateInfo>::GetOwningArena(qps);
    if (message_arena != submessage_arena) {
      qps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qps, submessage_arena);
    }
    
  } else {
    
  }
  qps_ = qps;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.qps)
}

// .protocol.MetricsInfo.RateInfo failQps = 3;
inline bool MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::_internal_has_failqps() const {
  return this != internal_default_instance() && failqps_ != nullptr;
}
inline bool MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::has_failqps() const {
  return _internal_has_failqps();
}
inline void MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::clear_failqps() {
  if (GetArenaForAllocation() == nullptr && failqps_ != nullptr) {
    delete failqps_;
  }
  failqps_ = nullptr;
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::_internal_failqps() const {
  const ::protocol::MetricsInfo_RateInfo* p = failqps_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_RateInfo&>(
      ::protocol::_MetricsInfo_RateInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::failqps() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.failQps)
  return _internal_failqps();
}
inline void MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::unsafe_arena_set_allocated_failqps(
    ::protocol::MetricsInfo_RateInfo* failqps) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(failqps_);
  }
  failqps_ = failqps;
  if (failqps) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.failQps)
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::release_failqps() {
  
  ::protocol::MetricsInfo_RateInfo* temp = failqps_;
  failqps_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::unsafe_arena_release_failqps() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.failQps)
  
  ::protocol::MetricsInfo_RateInfo* temp = failqps_;
  failqps_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::_internal_mutable_failqps() {
  
  if (failqps_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(GetArenaForAllocation());
    failqps_ = p;
  }
  return failqps_;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::mutable_failqps() {
  ::protocol::MetricsInfo_RateInfo* _msg = _internal_mutable_failqps();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.failQps)
  return _msg;
}
inline void MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::set_allocated_failqps(::protocol::MetricsInfo_RateInfo* failqps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete failqps_;
  }
  if (failqps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_RateInfo>::GetOwningArena(failqps);
    if (message_arena != submessage_arena) {
      failqps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, failqps, submessage_arena);
    }
    
  } else {
    
  }
  failqps_ = failqps;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.failQps)
}

// .protocol.MetricsInfo.RateInfo outTraffic = 4;
inline bool MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::_internal_has_outtraffic() const {
  return this != internal_default_instance() && outtraffic_ != nullptr;
}
inline bool MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::has_outtraffic() const {
  return _internal_has_outtraffic();
}
inline void MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::clear_outtraffic() {
  if (GetArenaForAllocation() == nullptr && outtraffic_ != nullptr) {
    delete outtraffic_;
  }
  outtraffic_ = nullptr;
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::_internal_outtraffic() const {
  const ::protocol::MetricsInfo_RateInfo* p = outtraffic_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_RateInfo&>(
      ::protocol::_MetricsInfo_RateInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::outtraffic() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.outTraffic)
  return _internal_outtraffic();
}
inline void MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::unsafe_arena_set_allocated_outtraffic(
    ::protocol::MetricsInfo_RateInfo* outtraffic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outtraffic_);
  }
  outtraffic_ = outtraffic;
  if (outtraffic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.outTraffic)
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::release_outtraffic() {
  
  ::protocol::MetricsInfo_RateInfo* temp = outtraffic_;
  outtraffic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::unsafe_arena_release_outtraffic() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.outTraffic)
  
  ::protocol::MetricsInfo_RateInfo* temp = outtraffic_;
  outtraffic_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::_internal_mutable_outtraffic() {
  
  if (outtraffic_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(GetArenaForAllocation());
    outtraffic_ = p;
  }
  return outtraffic_;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::mutable_outtraffic() {
  ::protocol::MetricsInfo_RateInfo* _msg = _internal_mutable_outtraffic();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.outTraffic)
  return _msg;
}
inline void MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo::set_allocated_outtraffic(::protocol::MetricsInfo_RateInfo* outtraffic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete outtraffic_;
  }
  if (outtraffic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_RateInfo>::GetOwningArena(outtraffic);
    if (message_arena != submessage_arena) {
      outtraffic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outtraffic, submessage_arena);
    }
    
  } else {
    
  }
  outtraffic_ = outtraffic;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo.outTraffic)
}

// -------------------------------------------------------------------

// MetricsInfo_NetInfo_ApiInfo

// .protocol.MetricsInfo.RateInfo qps = 1;
inline bool MetricsInfo_NetInfo_ApiInfo::_internal_has_qps() const {
  return this != internal_default_instance() && qps_ != nullptr;
}
inline bool MetricsInfo_NetInfo_ApiInfo::has_qps() const {
  return _internal_has_qps();
}
inline void MetricsInfo_NetInfo_ApiInfo::clear_qps() {
  if (GetArenaForAllocation() == nullptr && qps_ != nullptr) {
    delete qps_;
  }
  qps_ = nullptr;
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo_ApiInfo::_internal_qps() const {
  const ::protocol::MetricsInfo_RateInfo* p = qps_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_RateInfo&>(
      ::protocol::_MetricsInfo_RateInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo_ApiInfo::qps() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.ApiInfo.qps)
  return _internal_qps();
}
inline void MetricsInfo_NetInfo_ApiInfo::unsafe_arena_set_allocated_qps(
    ::protocol::MetricsInfo_RateInfo* qps) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(qps_);
  }
  qps_ = qps;
  if (qps) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.NetInfo.ApiInfo.qps)
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo::release_qps() {
  
  ::protocol::MetricsInfo_RateInfo* temp = qps_;
  qps_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo::unsafe_arena_release_qps() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.ApiInfo.qps)
  
  ::protocol::MetricsInfo_RateInfo* temp = qps_;
  qps_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo::_internal_mutable_qps() {
  
  if (qps_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(GetArenaForAllocation());
    qps_ = p;
  }
  return qps_;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo::mutable_qps() {
  ::protocol::MetricsInfo_RateInfo* _msg = _internal_mutable_qps();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.ApiInfo.qps)
  return _msg;
}
inline void MetricsInfo_NetInfo_ApiInfo::set_allocated_qps(::protocol::MetricsInfo_RateInfo* qps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete qps_;
  }
  if (qps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_RateInfo>::GetOwningArena(qps);
    if (message_arena != submessage_arena) {
      qps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qps, submessage_arena);
    }
    
  } else {
    
  }
  qps_ = qps;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.ApiInfo.qps)
}

// .protocol.MetricsInfo.RateInfo failQps = 2;
inline bool MetricsInfo_NetInfo_ApiInfo::_internal_has_failqps() const {
  return this != internal_default_instance() && failqps_ != nullptr;
}
inline bool MetricsInfo_NetInfo_ApiInfo::has_failqps() const {
  return _internal_has_failqps();
}
inline void MetricsInfo_NetInfo_ApiInfo::clear_failqps() {
  if (GetArenaForAllocation() == nullptr && failqps_ != nullptr) {
    delete failqps_;
  }
  failqps_ = nullptr;
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo_ApiInfo::_internal_failqps() const {
  const ::protocol::MetricsInfo_RateInfo* p = failqps_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_RateInfo&>(
      ::protocol::_MetricsInfo_RateInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo_ApiInfo::failqps() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.ApiInfo.failQps)
  return _internal_failqps();
}
inline void MetricsInfo_NetInfo_ApiInfo::unsafe_arena_set_allocated_failqps(
    ::protocol::MetricsInfo_RateInfo* failqps) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(failqps_);
  }
  failqps_ = failqps;
  if (failqps) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.NetInfo.ApiInfo.failQps)
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo::release_failqps() {
  
  ::protocol::MetricsInfo_RateInfo* temp = failqps_;
  failqps_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo::unsafe_arena_release_failqps() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.ApiInfo.failQps)
  
  ::protocol::MetricsInfo_RateInfo* temp = failqps_;
  failqps_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo::_internal_mutable_failqps() {
  
  if (failqps_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(GetArenaForAllocation());
    failqps_ = p;
  }
  return failqps_;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo::mutable_failqps() {
  ::protocol::MetricsInfo_RateInfo* _msg = _internal_mutable_failqps();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.ApiInfo.failQps)
  return _msg;
}
inline void MetricsInfo_NetInfo_ApiInfo::set_allocated_failqps(::protocol::MetricsInfo_RateInfo* failqps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete failqps_;
  }
  if (failqps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_RateInfo>::GetOwningArena(failqps);
    if (message_arena != submessage_arena) {
      failqps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, failqps, submessage_arena);
    }
    
  } else {
    
  }
  failqps_ = failqps;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.ApiInfo.failQps)
}

// .protocol.MetricsInfo.RateInfo outTraffic = 3;
inline bool MetricsInfo_NetInfo_ApiInfo::_internal_has_outtraffic() const {
  return this != internal_default_instance() && outtraffic_ != nullptr;
}
inline bool MetricsInfo_NetInfo_ApiInfo::has_outtraffic() const {
  return _internal_has_outtraffic();
}
inline void MetricsInfo_NetInfo_ApiInfo::clear_outtraffic() {
  if (GetArenaForAllocation() == nullptr && outtraffic_ != nullptr) {
    delete outtraffic_;
  }
  outtraffic_ = nullptr;
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo_ApiInfo::_internal_outtraffic() const {
  const ::protocol::MetricsInfo_RateInfo* p = outtraffic_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_RateInfo&>(
      ::protocol::_MetricsInfo_RateInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo_ApiInfo::outtraffic() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.ApiInfo.outTraffic)
  return _internal_outtraffic();
}
inline void MetricsInfo_NetInfo_ApiInfo::unsafe_arena_set_allocated_outtraffic(
    ::protocol::MetricsInfo_RateInfo* outtraffic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outtraffic_);
  }
  outtraffic_ = outtraffic;
  if (outtraffic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.NetInfo.ApiInfo.outTraffic)
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo::release_outtraffic() {
  
  ::protocol::MetricsInfo_RateInfo* temp = outtraffic_;
  outtraffic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo::unsafe_arena_release_outtraffic() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.ApiInfo.outTraffic)
  
  ::protocol::MetricsInfo_RateInfo* temp = outtraffic_;
  outtraffic_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo::_internal_mutable_outtraffic() {
  
  if (outtraffic_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(GetArenaForAllocation());
    outtraffic_ = p;
  }
  return outtraffic_;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo_ApiInfo::mutable_outtraffic() {
  ::protocol::MetricsInfo_RateInfo* _msg = _internal_mutable_outtraffic();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.ApiInfo.outTraffic)
  return _msg;
}
inline void MetricsInfo_NetInfo_ApiInfo::set_allocated_outtraffic(::protocol::MetricsInfo_RateInfo* outtraffic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete outtraffic_;
  }
  if (outtraffic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_RateInfo>::GetOwningArena(outtraffic);
    if (message_arena != submessage_arena) {
      outtraffic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outtraffic, submessage_arena);
    }
    
  } else {
    
  }
  outtraffic_ = outtraffic;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.ApiInfo.outTraffic)
}

// repeated .protocol.MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo detail = 4;
inline int MetricsInfo_NetInfo_ApiInfo::_internal_detail_size() const {
  return detail_.size();
}
inline int MetricsInfo_NetInfo_ApiInfo::detail_size() const {
  return _internal_detail_size();
}
inline void MetricsInfo_NetInfo_ApiInfo::clear_detail() {
  detail_.Clear();
}
inline ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo* MetricsInfo_NetInfo_ApiInfo::mutable_detail(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.ApiInfo.detail)
  return detail_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo >*
MetricsInfo_NetInfo_ApiInfo::mutable_detail() {
  // @@protoc_insertion_point(field_mutable_list:protocol.MetricsInfo.NetInfo.ApiInfo.detail)
  return &detail_;
}
inline const ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo& MetricsInfo_NetInfo_ApiInfo::_internal_detail(int index) const {
  return detail_.Get(index);
}
inline const ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo& MetricsInfo_NetInfo_ApiInfo::detail(int index) const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.ApiInfo.detail)
  return _internal_detail(index);
}
inline ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo* MetricsInfo_NetInfo_ApiInfo::_internal_add_detail() {
  return detail_.Add();
}
inline ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo* MetricsInfo_NetInfo_ApiInfo::add_detail() {
  ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo* _add = _internal_add_detail();
  // @@protoc_insertion_point(field_add:protocol.MetricsInfo.NetInfo.ApiInfo.detail)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo >&
MetricsInfo_NetInfo_ApiInfo::detail() const {
  // @@protoc_insertion_point(field_list:protocol.MetricsInfo.NetInfo.ApiInfo.detail)
  return detail_;
}

// -------------------------------------------------------------------

// MetricsInfo_NetInfo_DisconnectionDetailInfo

// string reason = 1;
inline void MetricsInfo_NetInfo_DisconnectionDetailInfo::clear_reason() {
  reason_.ClearToEmpty();
}
inline const std::string& MetricsInfo_NetInfo_DisconnectionDetailInfo::reason() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricsInfo_NetInfo_DisconnectionDetailInfo::set_reason(ArgT0&& arg0, ArgT... args) {
 
 reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo.reason)
}
inline std::string* MetricsInfo_NetInfo_DisconnectionDetailInfo::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo.reason)
  return _s;
}
inline const std::string& MetricsInfo_NetInfo_DisconnectionDetailInfo::_internal_reason() const {
  return reason_.Get();
}
inline void MetricsInfo_NetInfo_DisconnectionDetailInfo::_internal_set_reason(const std::string& value) {
  
  reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetricsInfo_NetInfo_DisconnectionDetailInfo::_internal_mutable_reason() {
  
  return reason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetricsInfo_NetInfo_DisconnectionDetailInfo::release_reason() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo.reason)
  return reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetricsInfo_NetInfo_DisconnectionDetailInfo::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reason_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo.reason)
}

// int32 count = 2;
inline void MetricsInfo_NetInfo_DisconnectionDetailInfo::clear_count() {
  count_ = 0;
}
inline int32_t MetricsInfo_NetInfo_DisconnectionDetailInfo::_internal_count() const {
  return count_;
}
inline int32_t MetricsInfo_NetInfo_DisconnectionDetailInfo::count() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo.count)
  return _internal_count();
}
inline void MetricsInfo_NetInfo_DisconnectionDetailInfo::_internal_set_count(int32_t value) {
  
  count_ = value;
}
inline void MetricsInfo_NetInfo_DisconnectionDetailInfo::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo.count)
}

// -------------------------------------------------------------------

// MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo

// string witness = 1;
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::clear_witness() {
  witness_.ClearToEmpty();
}
inline const std::string& MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::witness() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.witness)
  return _internal_witness();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::set_witness(ArgT0&& arg0, ArgT... args) {
 
 witness_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.witness)
}
inline std::string* MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::mutable_witness() {
  std::string* _s = _internal_mutable_witness();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.witness)
  return _s;
}
inline const std::string& MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_witness() const {
  return witness_.Get();
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_set_witness(const std::string& value) {
  
  witness_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_mutable_witness() {
  
  return witness_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::release_witness() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.witness)
  return witness_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::set_allocated_witness(std::string* witness) {
  if (witness != nullptr) {
    
  } else {
    
  }
  witness_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), witness,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (witness_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    witness_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.witness)
}

// int32 top99 = 2;
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::clear_top99() {
  top99_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_top99() const {
  return top99_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::top99() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.top99)
  return _internal_top99();
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_set_top99(int32_t value) {
  
  top99_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::set_top99(int32_t value) {
  _internal_set_top99(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.top99)
}

// int32 top95 = 3;
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::clear_top95() {
  top95_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_top95() const {
  return top95_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::top95() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.top95)
  return _internal_top95();
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_set_top95(int32_t value) {
  
  top95_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::set_top95(int32_t value) {
  _internal_set_top95(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.top95)
}

// int32 top75 = 4;
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::clear_top75() {
  top75_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_top75() const {
  return top75_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::top75() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.top75)
  return _internal_top75();
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_set_top75(int32_t value) {
  
  top75_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::set_top75(int32_t value) {
  _internal_set_top75(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.top75)
}

// int32 count = 5;
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::clear_count() {
  count_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_count() const {
  return count_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::count() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.count)
  return _internal_count();
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_set_count(int32_t value) {
  
  count_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.count)
}

// int32 delay1S = 6;
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::clear_delay1s() {
  delay1s_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_delay1s() const {
  return delay1s_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::delay1s() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.delay1S)
  return _internal_delay1s();
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_set_delay1s(int32_t value) {
  
  delay1s_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::set_delay1s(int32_t value) {
  _internal_set_delay1s(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.delay1S)
}

// int32 delay2S = 7;
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::clear_delay2s() {
  delay2s_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_delay2s() const {
  return delay2s_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::delay2s() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.delay2S)
  return _internal_delay2s();
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_set_delay2s(int32_t value) {
  
  delay2s_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::set_delay2s(int32_t value) {
  _internal_set_delay2s(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.delay2S)
}

// int32 delay3S = 8;
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::clear_delay3s() {
  delay3s_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_delay3s() const {
  return delay3s_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::delay3s() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.delay3S)
  return _internal_delay3s();
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::_internal_set_delay3s(int32_t value) {
  
  delay3s_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo::set_delay3s(int32_t value) {
  _internal_set_delay3s(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo.delay3S)
}

// -------------------------------------------------------------------

// MetricsInfo_NetInfo_LatencyInfo

// int32 top99 = 1;
inline void MetricsInfo_NetInfo_LatencyInfo::clear_top99() {
  top99_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::_internal_top99() const {
  return top99_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::top99() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.top99)
  return _internal_top99();
}
inline void MetricsInfo_NetInfo_LatencyInfo::_internal_set_top99(int32_t value) {
  
  top99_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo::set_top99(int32_t value) {
  _internal_set_top99(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.top99)
}

// int32 top95 = 2;
inline void MetricsInfo_NetInfo_LatencyInfo::clear_top95() {
  top95_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::_internal_top95() const {
  return top95_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::top95() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.top95)
  return _internal_top95();
}
inline void MetricsInfo_NetInfo_LatencyInfo::_internal_set_top95(int32_t value) {
  
  top95_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo::set_top95(int32_t value) {
  _internal_set_top95(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.top95)
}

// int32 top75 = 3;
inline void MetricsInfo_NetInfo_LatencyInfo::clear_top75() {
  top75_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::_internal_top75() const {
  return top75_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::top75() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.top75)
  return _internal_top75();
}
inline void MetricsInfo_NetInfo_LatencyInfo::_internal_set_top75(int32_t value) {
  
  top75_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo::set_top75(int32_t value) {
  _internal_set_top75(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.top75)
}

// int32 totalCount = 4;
inline void MetricsInfo_NetInfo_LatencyInfo::clear_totalcount() {
  totalcount_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::_internal_totalcount() const {
  return totalcount_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::totalcount() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.totalCount)
  return _internal_totalcount();
}
inline void MetricsInfo_NetInfo_LatencyInfo::_internal_set_totalcount(int32_t value) {
  
  totalcount_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo::set_totalcount(int32_t value) {
  _internal_set_totalcount(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.totalCount)
}

// int32 delay1S = 5;
inline void MetricsInfo_NetInfo_LatencyInfo::clear_delay1s() {
  delay1s_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::_internal_delay1s() const {
  return delay1s_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::delay1s() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.delay1S)
  return _internal_delay1s();
}
inline void MetricsInfo_NetInfo_LatencyInfo::_internal_set_delay1s(int32_t value) {
  
  delay1s_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo::set_delay1s(int32_t value) {
  _internal_set_delay1s(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.delay1S)
}

// int32 delay2S = 6;
inline void MetricsInfo_NetInfo_LatencyInfo::clear_delay2s() {
  delay2s_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::_internal_delay2s() const {
  return delay2s_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::delay2s() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.delay2S)
  return _internal_delay2s();
}
inline void MetricsInfo_NetInfo_LatencyInfo::_internal_set_delay2s(int32_t value) {
  
  delay2s_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo::set_delay2s(int32_t value) {
  _internal_set_delay2s(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.delay2S)
}

// int32 delay3S = 7;
inline void MetricsInfo_NetInfo_LatencyInfo::clear_delay3s() {
  delay3s_ = 0;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::_internal_delay3s() const {
  return delay3s_;
}
inline int32_t MetricsInfo_NetInfo_LatencyInfo::delay3s() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.delay3S)
  return _internal_delay3s();
}
inline void MetricsInfo_NetInfo_LatencyInfo::_internal_set_delay3s(int32_t value) {
  
  delay3s_ = value;
}
inline void MetricsInfo_NetInfo_LatencyInfo::set_delay3s(int32_t value) {
  _internal_set_delay3s(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.LatencyInfo.delay3S)
}

// repeated .protocol.MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo detail = 8;
inline int MetricsInfo_NetInfo_LatencyInfo::_internal_detail_size() const {
  return detail_.size();
}
inline int MetricsInfo_NetInfo_LatencyInfo::detail_size() const {
  return _internal_detail_size();
}
inline void MetricsInfo_NetInfo_LatencyInfo::clear_detail() {
  detail_.Clear();
}
inline ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo* MetricsInfo_NetInfo_LatencyInfo::mutable_detail(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.LatencyInfo.detail)
  return detail_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo >*
MetricsInfo_NetInfo_LatencyInfo::mutable_detail() {
  // @@protoc_insertion_point(field_mutable_list:protocol.MetricsInfo.NetInfo.LatencyInfo.detail)
  return &detail_;
}
inline const ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo& MetricsInfo_NetInfo_LatencyInfo::_internal_detail(int index) const {
  return detail_.Get(index);
}
inline const ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo& MetricsInfo_NetInfo_LatencyInfo::detail(int index) const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.LatencyInfo.detail)
  return _internal_detail(index);
}
inline ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo* MetricsInfo_NetInfo_LatencyInfo::_internal_add_detail() {
  return detail_.Add();
}
inline ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo* MetricsInfo_NetInfo_LatencyInfo::add_detail() {
  ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo* _add = _internal_add_detail();
  // @@protoc_insertion_point(field_add:protocol.MetricsInfo.NetInfo.LatencyInfo.detail)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo >&
MetricsInfo_NetInfo_LatencyInfo::detail() const {
  // @@protoc_insertion_point(field_list:protocol.MetricsInfo.NetInfo.LatencyInfo.detail)
  return detail_;
}

// -------------------------------------------------------------------

// MetricsInfo_NetInfo

// int32 errorProtoCount = 1;
inline void MetricsInfo_NetInfo::clear_errorprotocount() {
  errorprotocount_ = 0;
}
inline int32_t MetricsInfo_NetInfo::_internal_errorprotocount() const {
  return errorprotocount_;
}
inline int32_t MetricsInfo_NetInfo::errorprotocount() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.errorProtoCount)
  return _internal_errorprotocount();
}
inline void MetricsInfo_NetInfo::_internal_set_errorprotocount(int32_t value) {
  
  errorprotocount_ = value;
}
inline void MetricsInfo_NetInfo::set_errorprotocount(int32_t value) {
  _internal_set_errorprotocount(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.errorProtoCount)
}

// .protocol.MetricsInfo.NetInfo.ApiInfo api = 2;
inline bool MetricsInfo_NetInfo::_internal_has_api() const {
  return this != internal_default_instance() && api_ != nullptr;
}
inline bool MetricsInfo_NetInfo::has_api() const {
  return _internal_has_api();
}
inline void MetricsInfo_NetInfo::clear_api() {
  if (GetArenaForAllocation() == nullptr && api_ != nullptr) {
    delete api_;
  }
  api_ = nullptr;
}
inline const ::protocol::MetricsInfo_NetInfo_ApiInfo& MetricsInfo_NetInfo::_internal_api() const {
  const ::protocol::MetricsInfo_NetInfo_ApiInfo* p = api_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_NetInfo_ApiInfo&>(
      ::protocol::_MetricsInfo_NetInfo_ApiInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_NetInfo_ApiInfo& MetricsInfo_NetInfo::api() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.api)
  return _internal_api();
}
inline void MetricsInfo_NetInfo::unsafe_arena_set_allocated_api(
    ::protocol::MetricsInfo_NetInfo_ApiInfo* api) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_);
  }
  api_ = api;
  if (api) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.NetInfo.api)
}
inline ::protocol::MetricsInfo_NetInfo_ApiInfo* MetricsInfo_NetInfo::release_api() {
  
  ::protocol::MetricsInfo_NetInfo_ApiInfo* temp = api_;
  api_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_NetInfo_ApiInfo* MetricsInfo_NetInfo::unsafe_arena_release_api() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.api)
  
  ::protocol::MetricsInfo_NetInfo_ApiInfo* temp = api_;
  api_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_NetInfo_ApiInfo* MetricsInfo_NetInfo::_internal_mutable_api() {
  
  if (api_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_NetInfo_ApiInfo>(GetArenaForAllocation());
    api_ = p;
  }
  return api_;
}
inline ::protocol::MetricsInfo_NetInfo_ApiInfo* MetricsInfo_NetInfo::mutable_api() {
  ::protocol::MetricsInfo_NetInfo_ApiInfo* _msg = _internal_mutable_api();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.api)
  return _msg;
}
inline void MetricsInfo_NetInfo::set_allocated_api(::protocol::MetricsInfo_NetInfo_ApiInfo* api) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete api_;
  }
  if (api) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_NetInfo_ApiInfo>::GetOwningArena(api);
    if (message_arena != submessage_arena) {
      api = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, api, submessage_arena);
    }
    
  } else {
    
  }
  api_ = api;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.api)
}

// int32 connectionCount = 3;
inline void MetricsInfo_NetInfo::clear_connectioncount() {
  connectioncount_ = 0;
}
inline int32_t MetricsInfo_NetInfo::_internal_connectioncount() const {
  return connectioncount_;
}
inline int32_t MetricsInfo_NetInfo::connectioncount() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.connectionCount)
  return _internal_connectioncount();
}
inline void MetricsInfo_NetInfo::_internal_set_connectioncount(int32_t value) {
  
  connectioncount_ = value;
}
inline void MetricsInfo_NetInfo::set_connectioncount(int32_t value) {
  _internal_set_connectioncount(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.connectionCount)
}

// int32 validConnectionCount = 4;
inline void MetricsInfo_NetInfo::clear_validconnectioncount() {
  validconnectioncount_ = 0;
}
inline int32_t MetricsInfo_NetInfo::_internal_validconnectioncount() const {
  return validconnectioncount_;
}
inline int32_t MetricsInfo_NetInfo::validconnectioncount() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.validConnectionCount)
  return _internal_validconnectioncount();
}
inline void MetricsInfo_NetInfo::_internal_set_validconnectioncount(int32_t value) {
  
  validconnectioncount_ = value;
}
inline void MetricsInfo_NetInfo::set_validconnectioncount(int32_t value) {
  _internal_set_validconnectioncount(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.validConnectionCount)
}

// .protocol.MetricsInfo.RateInfo tcpInTraffic = 5;
inline bool MetricsInfo_NetInfo::_internal_has_tcpintraffic() const {
  return this != internal_default_instance() && tcpintraffic_ != nullptr;
}
inline bool MetricsInfo_NetInfo::has_tcpintraffic() const {
  return _internal_has_tcpintraffic();
}
inline void MetricsInfo_NetInfo::clear_tcpintraffic() {
  if (GetArenaForAllocation() == nullptr && tcpintraffic_ != nullptr) {
    delete tcpintraffic_;
  }
  tcpintraffic_ = nullptr;
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo::_internal_tcpintraffic() const {
  const ::protocol::MetricsInfo_RateInfo* p = tcpintraffic_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_RateInfo&>(
      ::protocol::_MetricsInfo_RateInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo::tcpintraffic() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.tcpInTraffic)
  return _internal_tcpintraffic();
}
inline void MetricsInfo_NetInfo::unsafe_arena_set_allocated_tcpintraffic(
    ::protocol::MetricsInfo_RateInfo* tcpintraffic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tcpintraffic_);
  }
  tcpintraffic_ = tcpintraffic;
  if (tcpintraffic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.NetInfo.tcpInTraffic)
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::release_tcpintraffic() {
  
  ::protocol::MetricsInfo_RateInfo* temp = tcpintraffic_;
  tcpintraffic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::unsafe_arena_release_tcpintraffic() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.tcpInTraffic)
  
  ::protocol::MetricsInfo_RateInfo* temp = tcpintraffic_;
  tcpintraffic_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::_internal_mutable_tcpintraffic() {
  
  if (tcpintraffic_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(GetArenaForAllocation());
    tcpintraffic_ = p;
  }
  return tcpintraffic_;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::mutable_tcpintraffic() {
  ::protocol::MetricsInfo_RateInfo* _msg = _internal_mutable_tcpintraffic();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.tcpInTraffic)
  return _msg;
}
inline void MetricsInfo_NetInfo::set_allocated_tcpintraffic(::protocol::MetricsInfo_RateInfo* tcpintraffic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tcpintraffic_;
  }
  if (tcpintraffic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_RateInfo>::GetOwningArena(tcpintraffic);
    if (message_arena != submessage_arena) {
      tcpintraffic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tcpintraffic, submessage_arena);
    }
    
  } else {
    
  }
  tcpintraffic_ = tcpintraffic;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.tcpInTraffic)
}

// .protocol.MetricsInfo.RateInfo tcpOutTraffic = 6;
inline bool MetricsInfo_NetInfo::_internal_has_tcpouttraffic() const {
  return this != internal_default_instance() && tcpouttraffic_ != nullptr;
}
inline bool MetricsInfo_NetInfo::has_tcpouttraffic() const {
  return _internal_has_tcpouttraffic();
}
inline void MetricsInfo_NetInfo::clear_tcpouttraffic() {
  if (GetArenaForAllocation() == nullptr && tcpouttraffic_ != nullptr) {
    delete tcpouttraffic_;
  }
  tcpouttraffic_ = nullptr;
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo::_internal_tcpouttraffic() const {
  const ::protocol::MetricsInfo_RateInfo* p = tcpouttraffic_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_RateInfo&>(
      ::protocol::_MetricsInfo_RateInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo::tcpouttraffic() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.tcpOutTraffic)
  return _internal_tcpouttraffic();
}
inline void MetricsInfo_NetInfo::unsafe_arena_set_allocated_tcpouttraffic(
    ::protocol::MetricsInfo_RateInfo* tcpouttraffic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tcpouttraffic_);
  }
  tcpouttraffic_ = tcpouttraffic;
  if (tcpouttraffic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.NetInfo.tcpOutTraffic)
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::release_tcpouttraffic() {
  
  ::protocol::MetricsInfo_RateInfo* temp = tcpouttraffic_;
  tcpouttraffic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::unsafe_arena_release_tcpouttraffic() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.tcpOutTraffic)
  
  ::protocol::MetricsInfo_RateInfo* temp = tcpouttraffic_;
  tcpouttraffic_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::_internal_mutable_tcpouttraffic() {
  
  if (tcpouttraffic_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(GetArenaForAllocation());
    tcpouttraffic_ = p;
  }
  return tcpouttraffic_;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::mutable_tcpouttraffic() {
  ::protocol::MetricsInfo_RateInfo* _msg = _internal_mutable_tcpouttraffic();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.tcpOutTraffic)
  return _msg;
}
inline void MetricsInfo_NetInfo::set_allocated_tcpouttraffic(::protocol::MetricsInfo_RateInfo* tcpouttraffic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tcpouttraffic_;
  }
  if (tcpouttraffic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_RateInfo>::GetOwningArena(tcpouttraffic);
    if (message_arena != submessage_arena) {
      tcpouttraffic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tcpouttraffic, submessage_arena);
    }
    
  } else {
    
  }
  tcpouttraffic_ = tcpouttraffic;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.tcpOutTraffic)
}

// int32 disconnectionCount = 7;
inline void MetricsInfo_NetInfo::clear_disconnectioncount() {
  disconnectioncount_ = 0;
}
inline int32_t MetricsInfo_NetInfo::_internal_disconnectioncount() const {
  return disconnectioncount_;
}
inline int32_t MetricsInfo_NetInfo::disconnectioncount() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.disconnectionCount)
  return _internal_disconnectioncount();
}
inline void MetricsInfo_NetInfo::_internal_set_disconnectioncount(int32_t value) {
  
  disconnectioncount_ = value;
}
inline void MetricsInfo_NetInfo::set_disconnectioncount(int32_t value) {
  _internal_set_disconnectioncount(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.NetInfo.disconnectionCount)
}

// repeated .protocol.MetricsInfo.NetInfo.DisconnectionDetailInfo disconnectionDetail = 8;
inline int MetricsInfo_NetInfo::_internal_disconnectiondetail_size() const {
  return disconnectiondetail_.size();
}
inline int MetricsInfo_NetInfo::disconnectiondetail_size() const {
  return _internal_disconnectiondetail_size();
}
inline void MetricsInfo_NetInfo::clear_disconnectiondetail() {
  disconnectiondetail_.Clear();
}
inline ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo* MetricsInfo_NetInfo::mutable_disconnectiondetail(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.disconnectionDetail)
  return disconnectiondetail_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo >*
MetricsInfo_NetInfo::mutable_disconnectiondetail() {
  // @@protoc_insertion_point(field_mutable_list:protocol.MetricsInfo.NetInfo.disconnectionDetail)
  return &disconnectiondetail_;
}
inline const ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo& MetricsInfo_NetInfo::_internal_disconnectiondetail(int index) const {
  return disconnectiondetail_.Get(index);
}
inline const ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo& MetricsInfo_NetInfo::disconnectiondetail(int index) const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.disconnectionDetail)
  return _internal_disconnectiondetail(index);
}
inline ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo* MetricsInfo_NetInfo::_internal_add_disconnectiondetail() {
  return disconnectiondetail_.Add();
}
inline ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo* MetricsInfo_NetInfo::add_disconnectiondetail() {
  ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo* _add = _internal_add_disconnectiondetail();
  // @@protoc_insertion_point(field_add:protocol.MetricsInfo.NetInfo.disconnectionDetail)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::MetricsInfo_NetInfo_DisconnectionDetailInfo >&
MetricsInfo_NetInfo::disconnectiondetail() const {
  // @@protoc_insertion_point(field_list:protocol.MetricsInfo.NetInfo.disconnectionDetail)
  return disconnectiondetail_;
}

// .protocol.MetricsInfo.RateInfo udpInTraffic = 9;
inline bool MetricsInfo_NetInfo::_internal_has_udpintraffic() const {
  return this != internal_default_instance() && udpintraffic_ != nullptr;
}
inline bool MetricsInfo_NetInfo::has_udpintraffic() const {
  return _internal_has_udpintraffic();
}
inline void MetricsInfo_NetInfo::clear_udpintraffic() {
  if (GetArenaForAllocation() == nullptr && udpintraffic_ != nullptr) {
    delete udpintraffic_;
  }
  udpintraffic_ = nullptr;
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo::_internal_udpintraffic() const {
  const ::protocol::MetricsInfo_RateInfo* p = udpintraffic_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_RateInfo&>(
      ::protocol::_MetricsInfo_RateInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo::udpintraffic() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.udpInTraffic)
  return _internal_udpintraffic();
}
inline void MetricsInfo_NetInfo::unsafe_arena_set_allocated_udpintraffic(
    ::protocol::MetricsInfo_RateInfo* udpintraffic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(udpintraffic_);
  }
  udpintraffic_ = udpintraffic;
  if (udpintraffic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.NetInfo.udpInTraffic)
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::release_udpintraffic() {
  
  ::protocol::MetricsInfo_RateInfo* temp = udpintraffic_;
  udpintraffic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::unsafe_arena_release_udpintraffic() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.udpInTraffic)
  
  ::protocol::MetricsInfo_RateInfo* temp = udpintraffic_;
  udpintraffic_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::_internal_mutable_udpintraffic() {
  
  if (udpintraffic_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(GetArenaForAllocation());
    udpintraffic_ = p;
  }
  return udpintraffic_;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::mutable_udpintraffic() {
  ::protocol::MetricsInfo_RateInfo* _msg = _internal_mutable_udpintraffic();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.udpInTraffic)
  return _msg;
}
inline void MetricsInfo_NetInfo::set_allocated_udpintraffic(::protocol::MetricsInfo_RateInfo* udpintraffic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete udpintraffic_;
  }
  if (udpintraffic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_RateInfo>::GetOwningArena(udpintraffic);
    if (message_arena != submessage_arena) {
      udpintraffic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, udpintraffic, submessage_arena);
    }
    
  } else {
    
  }
  udpintraffic_ = udpintraffic;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.udpInTraffic)
}

// .protocol.MetricsInfo.RateInfo udpOutTraffic = 10;
inline bool MetricsInfo_NetInfo::_internal_has_udpouttraffic() const {
  return this != internal_default_instance() && udpouttraffic_ != nullptr;
}
inline bool MetricsInfo_NetInfo::has_udpouttraffic() const {
  return _internal_has_udpouttraffic();
}
inline void MetricsInfo_NetInfo::clear_udpouttraffic() {
  if (GetArenaForAllocation() == nullptr && udpouttraffic_ != nullptr) {
    delete udpouttraffic_;
  }
  udpouttraffic_ = nullptr;
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo::_internal_udpouttraffic() const {
  const ::protocol::MetricsInfo_RateInfo* p = udpouttraffic_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_RateInfo&>(
      ::protocol::_MetricsInfo_RateInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_RateInfo& MetricsInfo_NetInfo::udpouttraffic() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.udpOutTraffic)
  return _internal_udpouttraffic();
}
inline void MetricsInfo_NetInfo::unsafe_arena_set_allocated_udpouttraffic(
    ::protocol::MetricsInfo_RateInfo* udpouttraffic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(udpouttraffic_);
  }
  udpouttraffic_ = udpouttraffic;
  if (udpouttraffic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.NetInfo.udpOutTraffic)
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::release_udpouttraffic() {
  
  ::protocol::MetricsInfo_RateInfo* temp = udpouttraffic_;
  udpouttraffic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::unsafe_arena_release_udpouttraffic() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.udpOutTraffic)
  
  ::protocol::MetricsInfo_RateInfo* temp = udpouttraffic_;
  udpouttraffic_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::_internal_mutable_udpouttraffic() {
  
  if (udpouttraffic_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_RateInfo>(GetArenaForAllocation());
    udpouttraffic_ = p;
  }
  return udpouttraffic_;
}
inline ::protocol::MetricsInfo_RateInfo* MetricsInfo_NetInfo::mutable_udpouttraffic() {
  ::protocol::MetricsInfo_RateInfo* _msg = _internal_mutable_udpouttraffic();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.udpOutTraffic)
  return _msg;
}
inline void MetricsInfo_NetInfo::set_allocated_udpouttraffic(::protocol::MetricsInfo_RateInfo* udpouttraffic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete udpouttraffic_;
  }
  if (udpouttraffic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_RateInfo>::GetOwningArena(udpouttraffic);
    if (message_arena != submessage_arena) {
      udpouttraffic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, udpouttraffic, submessage_arena);
    }
    
  } else {
    
  }
  udpouttraffic_ = udpouttraffic;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.udpOutTraffic)
}

// .protocol.MetricsInfo.NetInfo.LatencyInfo latency = 11;
inline bool MetricsInfo_NetInfo::_internal_has_latency() const {
  return this != internal_default_instance() && latency_ != nullptr;
}
inline bool MetricsInfo_NetInfo::has_latency() const {
  return _internal_has_latency();
}
inline void MetricsInfo_NetInfo::clear_latency() {
  if (GetArenaForAllocation() == nullptr && latency_ != nullptr) {
    delete latency_;
  }
  latency_ = nullptr;
}
inline const ::protocol::MetricsInfo_NetInfo_LatencyInfo& MetricsInfo_NetInfo::_internal_latency() const {
  const ::protocol::MetricsInfo_NetInfo_LatencyInfo* p = latency_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_NetInfo_LatencyInfo&>(
      ::protocol::_MetricsInfo_NetInfo_LatencyInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_NetInfo_LatencyInfo& MetricsInfo_NetInfo::latency() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.NetInfo.latency)
  return _internal_latency();
}
inline void MetricsInfo_NetInfo::unsafe_arena_set_allocated_latency(
    ::protocol::MetricsInfo_NetInfo_LatencyInfo* latency) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(latency_);
  }
  latency_ = latency;
  if (latency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.NetInfo.latency)
}
inline ::protocol::MetricsInfo_NetInfo_LatencyInfo* MetricsInfo_NetInfo::release_latency() {
  
  ::protocol::MetricsInfo_NetInfo_LatencyInfo* temp = latency_;
  latency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_NetInfo_LatencyInfo* MetricsInfo_NetInfo::unsafe_arena_release_latency() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.NetInfo.latency)
  
  ::protocol::MetricsInfo_NetInfo_LatencyInfo* temp = latency_;
  latency_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_NetInfo_LatencyInfo* MetricsInfo_NetInfo::_internal_mutable_latency() {
  
  if (latency_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_NetInfo_LatencyInfo>(GetArenaForAllocation());
    latency_ = p;
  }
  return latency_;
}
inline ::protocol::MetricsInfo_NetInfo_LatencyInfo* MetricsInfo_NetInfo::mutable_latency() {
  ::protocol::MetricsInfo_NetInfo_LatencyInfo* _msg = _internal_mutable_latency();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.NetInfo.latency)
  return _msg;
}
inline void MetricsInfo_NetInfo::set_allocated_latency(::protocol::MetricsInfo_NetInfo_LatencyInfo* latency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete latency_;
  }
  if (latency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_NetInfo_LatencyInfo>::GetOwningArena(latency);
    if (message_arena != submessage_arena) {
      latency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latency, submessage_arena);
    }
    
  } else {
    
  }
  latency_ = latency;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.NetInfo.latency)
}

// -------------------------------------------------------------------

// MetricsInfo

// int64 interval = 1;
inline void MetricsInfo::clear_interval() {
  interval_ = int64_t{0};
}
inline int64_t MetricsInfo::_internal_interval() const {
  return interval_;
}
inline int64_t MetricsInfo::interval() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.interval)
  return _internal_interval();
}
inline void MetricsInfo::_internal_set_interval(int64_t value) {
  
  interval_ = value;
}
inline void MetricsInfo::set_interval(int64_t value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:protocol.MetricsInfo.interval)
}

// .protocol.MetricsInfo.NodeInfo node = 2;
inline bool MetricsInfo::_internal_has_node() const {
  return this != internal_default_instance() && node_ != nullptr;
}
inline bool MetricsInfo::has_node() const {
  return _internal_has_node();
}
inline void MetricsInfo::clear_node() {
  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
}
inline const ::protocol::MetricsInfo_NodeInfo& MetricsInfo::_internal_node() const {
  const ::protocol::MetricsInfo_NodeInfo* p = node_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_NodeInfo&>(
      ::protocol::_MetricsInfo_NodeInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_NodeInfo& MetricsInfo::node() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.node)
  return _internal_node();
}
inline void MetricsInfo::unsafe_arena_set_allocated_node(
    ::protocol::MetricsInfo_NodeInfo* node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.node)
}
inline ::protocol::MetricsInfo_NodeInfo* MetricsInfo::release_node() {
  
  ::protocol::MetricsInfo_NodeInfo* temp = node_;
  node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_NodeInfo* MetricsInfo::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.node)
  
  ::protocol::MetricsInfo_NodeInfo* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_NodeInfo* MetricsInfo::_internal_mutable_node() {
  
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_NodeInfo>(GetArenaForAllocation());
    node_ = p;
  }
  return node_;
}
inline ::protocol::MetricsInfo_NodeInfo* MetricsInfo::mutable_node() {
  ::protocol::MetricsInfo_NodeInfo* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.node)
  return _msg;
}
inline void MetricsInfo::set_allocated_node(::protocol::MetricsInfo_NodeInfo* node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete node_;
  }
  if (node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_NodeInfo>::GetOwningArena(node);
    if (message_arena != submessage_arena) {
      node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.node)
}

// .protocol.MetricsInfo.BlockChainInfo blockchain = 3;
inline bool MetricsInfo::_internal_has_blockchain() const {
  return this != internal_default_instance() && blockchain_ != nullptr;
}
inline bool MetricsInfo::has_blockchain() const {
  return _internal_has_blockchain();
}
inline void MetricsInfo::clear_blockchain() {
  if (GetArenaForAllocation() == nullptr && blockchain_ != nullptr) {
    delete blockchain_;
  }
  blockchain_ = nullptr;
}
inline const ::protocol::MetricsInfo_BlockChainInfo& MetricsInfo::_internal_blockchain() const {
  const ::protocol::MetricsInfo_BlockChainInfo* p = blockchain_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_BlockChainInfo&>(
      ::protocol::_MetricsInfo_BlockChainInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_BlockChainInfo& MetricsInfo::blockchain() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.blockchain)
  return _internal_blockchain();
}
inline void MetricsInfo::unsafe_arena_set_allocated_blockchain(
    ::protocol::MetricsInfo_BlockChainInfo* blockchain) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blockchain_);
  }
  blockchain_ = blockchain;
  if (blockchain) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.blockchain)
}
inline ::protocol::MetricsInfo_BlockChainInfo* MetricsInfo::release_blockchain() {
  
  ::protocol::MetricsInfo_BlockChainInfo* temp = blockchain_;
  blockchain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_BlockChainInfo* MetricsInfo::unsafe_arena_release_blockchain() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.blockchain)
  
  ::protocol::MetricsInfo_BlockChainInfo* temp = blockchain_;
  blockchain_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_BlockChainInfo* MetricsInfo::_internal_mutable_blockchain() {
  
  if (blockchain_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_BlockChainInfo>(GetArenaForAllocation());
    blockchain_ = p;
  }
  return blockchain_;
}
inline ::protocol::MetricsInfo_BlockChainInfo* MetricsInfo::mutable_blockchain() {
  ::protocol::MetricsInfo_BlockChainInfo* _msg = _internal_mutable_blockchain();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.blockchain)
  return _msg;
}
inline void MetricsInfo::set_allocated_blockchain(::protocol::MetricsInfo_BlockChainInfo* blockchain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete blockchain_;
  }
  if (blockchain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_BlockChainInfo>::GetOwningArena(blockchain);
    if (message_arena != submessage_arena) {
      blockchain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blockchain, submessage_arena);
    }
    
  } else {
    
  }
  blockchain_ = blockchain;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.blockchain)
}

// .protocol.MetricsInfo.NetInfo net = 4;
inline bool MetricsInfo::_internal_has_net() const {
  return this != internal_default_instance() && net_ != nullptr;
}
inline bool MetricsInfo::has_net() const {
  return _internal_has_net();
}
inline void MetricsInfo::clear_net() {
  if (GetArenaForAllocation() == nullptr && net_ != nullptr) {
    delete net_;
  }
  net_ = nullptr;
}
inline const ::protocol::MetricsInfo_NetInfo& MetricsInfo::_internal_net() const {
  const ::protocol::MetricsInfo_NetInfo* p = net_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::MetricsInfo_NetInfo&>(
      ::protocol::_MetricsInfo_NetInfo_default_instance_);
}
inline const ::protocol::MetricsInfo_NetInfo& MetricsInfo::net() const {
  // @@protoc_insertion_point(field_get:protocol.MetricsInfo.net)
  return _internal_net();
}
inline void MetricsInfo::unsafe_arena_set_allocated_net(
    ::protocol::MetricsInfo_NetInfo* net) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(net_);
  }
  net_ = net;
  if (net) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.MetricsInfo.net)
}
inline ::protocol::MetricsInfo_NetInfo* MetricsInfo::release_net() {
  
  ::protocol::MetricsInfo_NetInfo* temp = net_;
  net_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::MetricsInfo_NetInfo* MetricsInfo::unsafe_arena_release_net() {
  // @@protoc_insertion_point(field_release:protocol.MetricsInfo.net)
  
  ::protocol::MetricsInfo_NetInfo* temp = net_;
  net_ = nullptr;
  return temp;
}
inline ::protocol::MetricsInfo_NetInfo* MetricsInfo::_internal_mutable_net() {
  
  if (net_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::MetricsInfo_NetInfo>(GetArenaForAllocation());
    net_ = p;
  }
  return net_;
}
inline ::protocol::MetricsInfo_NetInfo* MetricsInfo::mutable_net() {
  ::protocol::MetricsInfo_NetInfo* _msg = _internal_mutable_net();
  // @@protoc_insertion_point(field_mutable:protocol.MetricsInfo.net)
  return _msg;
}
inline void MetricsInfo::set_allocated_net(::protocol::MetricsInfo_NetInfo* net) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete net_;
  }
  if (net) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::MetricsInfo_NetInfo>::GetOwningArena(net);
    if (message_arena != submessage_arena) {
      net = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, net, submessage_arena);
    }
    
  } else {
    
  }
  net_ = net;
  // @@protoc_insertion_point(field_set_allocated:protocol.MetricsInfo.net)
}

// -------------------------------------------------------------------

// PBFTMessage_Raw

// .protocol.PBFTMessage.MsgType msg_type = 1;
inline void PBFTMessage_Raw::clear_msg_type() {
  msg_type_ = 0;
}
inline ::protocol::PBFTMessage_MsgType PBFTMessage_Raw::_internal_msg_type() const {
  return static_cast< ::protocol::PBFTMessage_MsgType >(msg_type_);
}
inline ::protocol::PBFTMessage_MsgType PBFTMessage_Raw::msg_type() const {
  // @@protoc_insertion_point(field_get:protocol.PBFTMessage.Raw.msg_type)
  return _internal_msg_type();
}
inline void PBFTMessage_Raw::_internal_set_msg_type(::protocol::PBFTMessage_MsgType value) {
  
  msg_type_ = value;
}
inline void PBFTMessage_Raw::set_msg_type(::protocol::PBFTMessage_MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:protocol.PBFTMessage.Raw.msg_type)
}

// .protocol.PBFTMessage.DataType data_type = 2;
inline void PBFTMessage_Raw::clear_data_type() {
  data_type_ = 0;
}
inline ::protocol::PBFTMessage_DataType PBFTMessage_Raw::_internal_data_type() const {
  return static_cast< ::protocol::PBFTMessage_DataType >(data_type_);
}
inline ::protocol::PBFTMessage_DataType PBFTMessage_Raw::data_type() const {
  // @@protoc_insertion_point(field_get:protocol.PBFTMessage.Raw.data_type)
  return _internal_data_type();
}
inline void PBFTMessage_Raw::_internal_set_data_type(::protocol::PBFTMessage_DataType value) {
  
  data_type_ = value;
}
inline void PBFTMessage_Raw::set_data_type(::protocol::PBFTMessage_DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:protocol.PBFTMessage.Raw.data_type)
}

// int64 view_n = 3;
inline void PBFTMessage_Raw::clear_view_n() {
  view_n_ = int64_t{0};
}
inline int64_t PBFTMessage_Raw::_internal_view_n() const {
  return view_n_;
}
inline int64_t PBFTMessage_Raw::view_n() const {
  // @@protoc_insertion_point(field_get:protocol.PBFTMessage.Raw.view_n)
  return _internal_view_n();
}
inline void PBFTMessage_Raw::_internal_set_view_n(int64_t value) {
  
  view_n_ = value;
}
inline void PBFTMessage_Raw::set_view_n(int64_t value) {
  _internal_set_view_n(value);
  // @@protoc_insertion_point(field_set:protocol.PBFTMessage.Raw.view_n)
}

// int64 epoch = 4;
inline void PBFTMessage_Raw::clear_epoch() {
  epoch_ = int64_t{0};
}
inline int64_t PBFTMessage_Raw::_internal_epoch() const {
  return epoch_;
}
inline int64_t PBFTMessage_Raw::epoch() const {
  // @@protoc_insertion_point(field_get:protocol.PBFTMessage.Raw.epoch)
  return _internal_epoch();
}
inline void PBFTMessage_Raw::_internal_set_epoch(int64_t value) {
  
  epoch_ = value;
}
inline void PBFTMessage_Raw::set_epoch(int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:protocol.PBFTMessage.Raw.epoch)
}

// bytes data = 5;
inline void PBFTMessage_Raw::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& PBFTMessage_Raw::data() const {
  // @@protoc_insertion_point(field_get:protocol.PBFTMessage.Raw.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PBFTMessage_Raw::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PBFTMessage.Raw.data)
}
inline std::string* PBFTMessage_Raw::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:protocol.PBFTMessage.Raw.data)
  return _s;
}
inline const std::string& PBFTMessage_Raw::_internal_data() const {
  return data_.Get();
}
inline void PBFTMessage_Raw::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PBFTMessage_Raw::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PBFTMessage_Raw::release_data() {
  // @@protoc_insertion_point(field_release:protocol.PBFTMessage.Raw.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PBFTMessage_Raw::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.PBFTMessage.Raw.data)
}

// -------------------------------------------------------------------

// PBFTMessage

// .protocol.PBFTMessage.Raw raw_data = 1;
inline bool PBFTMessage::_internal_has_raw_data() const {
  return this != internal_default_instance() && raw_data_ != nullptr;
}
inline bool PBFTMessage::has_raw_data() const {
  return _internal_has_raw_data();
}
inline void PBFTMessage::clear_raw_data() {
  if (GetArenaForAllocation() == nullptr && raw_data_ != nullptr) {
    delete raw_data_;
  }
  raw_data_ = nullptr;
}
inline const ::protocol::PBFTMessage_Raw& PBFTMessage::_internal_raw_data() const {
  const ::protocol::PBFTMessage_Raw* p = raw_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::protocol::PBFTMessage_Raw&>(
      ::protocol::_PBFTMessage_Raw_default_instance_);
}
inline const ::protocol::PBFTMessage_Raw& PBFTMessage::raw_data() const {
  // @@protoc_insertion_point(field_get:protocol.PBFTMessage.raw_data)
  return _internal_raw_data();
}
inline void PBFTMessage::unsafe_arena_set_allocated_raw_data(
    ::protocol::PBFTMessage_Raw* raw_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_data_);
  }
  raw_data_ = raw_data;
  if (raw_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.PBFTMessage.raw_data)
}
inline ::protocol::PBFTMessage_Raw* PBFTMessage::release_raw_data() {
  
  ::protocol::PBFTMessage_Raw* temp = raw_data_;
  raw_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protocol::PBFTMessage_Raw* PBFTMessage::unsafe_arena_release_raw_data() {
  // @@protoc_insertion_point(field_release:protocol.PBFTMessage.raw_data)
  
  ::protocol::PBFTMessage_Raw* temp = raw_data_;
  raw_data_ = nullptr;
  return temp;
}
inline ::protocol::PBFTMessage_Raw* PBFTMessage::_internal_mutable_raw_data() {
  
  if (raw_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::PBFTMessage_Raw>(GetArenaForAllocation());
    raw_data_ = p;
  }
  return raw_data_;
}
inline ::protocol::PBFTMessage_Raw* PBFTMessage::mutable_raw_data() {
  ::protocol::PBFTMessage_Raw* _msg = _internal_mutable_raw_data();
  // @@protoc_insertion_point(field_mutable:protocol.PBFTMessage.raw_data)
  return _msg;
}
inline void PBFTMessage::set_allocated_raw_data(::protocol::PBFTMessage_Raw* raw_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete raw_data_;
  }
  if (raw_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::protocol::PBFTMessage_Raw>::GetOwningArena(raw_data);
    if (message_arena != submessage_arena) {
      raw_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    
  } else {
    
  }
  raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:protocol.PBFTMessage.raw_data)
}

// bytes signature = 2;
inline void PBFTMessage::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& PBFTMessage::signature() const {
  // @@protoc_insertion_point(field_get:protocol.PBFTMessage.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PBFTMessage::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PBFTMessage.signature)
}
inline std::string* PBFTMessage::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:protocol.PBFTMessage.signature)
  return _s;
}
inline const std::string& PBFTMessage::_internal_signature() const {
  return signature_.Get();
}
inline void PBFTMessage::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PBFTMessage::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PBFTMessage::release_signature() {
  // @@protoc_insertion_point(field_release:protocol.PBFTMessage.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PBFTMessage::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.PBFTMessage.signature)
}

// -------------------------------------------------------------------

// PBFTCommitResult

// bytes data = 1;
inline void PBFTCommitResult::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& PBFTCommitResult::data() const {
  // @@protoc_insertion_point(field_get:protocol.PBFTCommitResult.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PBFTCommitResult::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocol.PBFTCommitResult.data)
}
inline std::string* PBFTCommitResult::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:protocol.PBFTCommitResult.data)
  return _s;
}
inline const std::string& PBFTCommitResult::_internal_data() const {
  return data_.Get();
}
inline void PBFTCommitResult::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PBFTCommitResult::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PBFTCommitResult::release_data() {
  // @@protoc_insertion_point(field_release:protocol.PBFTCommitResult.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PBFTCommitResult::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocol.PBFTCommitResult.data)
}

// repeated bytes signature = 2;
inline int PBFTCommitResult::_internal_signature_size() const {
  return signature_.size();
}
inline int PBFTCommitResult::signature_size() const {
  return _internal_signature_size();
}
inline void PBFTCommitResult::clear_signature() {
  signature_.Clear();
}
inline std::string* PBFTCommitResult::add_signature() {
  std::string* _s = _internal_add_signature();
  // @@protoc_insertion_point(field_add_mutable:protocol.PBFTCommitResult.signature)
  return _s;
}
inline const std::string& PBFTCommitResult::_internal_signature(int index) const {
  return signature_.Get(index);
}
inline const std::string& PBFTCommitResult::signature(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PBFTCommitResult.signature)
  return _internal_signature(index);
}
inline std::string* PBFTCommitResult::mutable_signature(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PBFTCommitResult.signature)
  return signature_.Mutable(index);
}
inline void PBFTCommitResult::set_signature(int index, const std::string& value) {
  signature_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.PBFTCommitResult.signature)
}
inline void PBFTCommitResult::set_signature(int index, std::string&& value) {
  signature_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.PBFTCommitResult.signature)
}
inline void PBFTCommitResult::set_signature(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signature_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.PBFTCommitResult.signature)
}
inline void PBFTCommitResult::set_signature(int index, const void* value, size_t size) {
  signature_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.PBFTCommitResult.signature)
}
inline std::string* PBFTCommitResult::_internal_add_signature() {
  return signature_.Add();
}
inline void PBFTCommitResult::add_signature(const std::string& value) {
  signature_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.PBFTCommitResult.signature)
}
inline void PBFTCommitResult::add_signature(std::string&& value) {
  signature_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.PBFTCommitResult.signature)
}
inline void PBFTCommitResult::add_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signature_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.PBFTCommitResult.signature)
}
inline void PBFTCommitResult::add_signature(const void* value, size_t size) {
  signature_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.PBFTCommitResult.signature)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PBFTCommitResult::signature() const {
  // @@protoc_insertion_point(field_list:protocol.PBFTCommitResult.signature)
  return signature_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PBFTCommitResult::mutable_signature() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PBFTCommitResult.signature)
  return &signature_;
}

// -------------------------------------------------------------------

// SRL

// repeated bytes srAddress = 1;
inline int SRL::_internal_sraddress_size() const {
  return sraddress_.size();
}
inline int SRL::sraddress_size() const {
  return _internal_sraddress_size();
}
inline void SRL::clear_sraddress() {
  sraddress_.Clear();
}
inline std::string* SRL::add_sraddress() {
  std::string* _s = _internal_add_sraddress();
  // @@protoc_insertion_point(field_add_mutable:protocol.SRL.srAddress)
  return _s;
}
inline const std::string& SRL::_internal_sraddress(int index) const {
  return sraddress_.Get(index);
}
inline const std::string& SRL::sraddress(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SRL.srAddress)
  return _internal_sraddress(index);
}
inline std::string* SRL::mutable_sraddress(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SRL.srAddress)
  return sraddress_.Mutable(index);
}
inline void SRL::set_sraddress(int index, const std::string& value) {
  sraddress_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:protocol.SRL.srAddress)
}
inline void SRL::set_sraddress(int index, std::string&& value) {
  sraddress_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:protocol.SRL.srAddress)
}
inline void SRL::set_sraddress(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  sraddress_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.SRL.srAddress)
}
inline void SRL::set_sraddress(int index, const void* value, size_t size) {
  sraddress_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.SRL.srAddress)
}
inline std::string* SRL::_internal_add_sraddress() {
  return sraddress_.Add();
}
inline void SRL::add_sraddress(const std::string& value) {
  sraddress_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.SRL.srAddress)
}
inline void SRL::add_sraddress(std::string&& value) {
  sraddress_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.SRL.srAddress)
}
inline void SRL::add_sraddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  sraddress_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.SRL.srAddress)
}
inline void SRL::add_sraddress(const void* value, size_t size) {
  sraddress_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.SRL.srAddress)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SRL::sraddress() const {
  // @@protoc_insertion_point(field_list:protocol.SRL.srAddress)
  return sraddress_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SRL::mutable_sraddress() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SRL.srAddress)
  return &sraddress_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::protocol::Proposal_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Proposal_State>() {
  return ::protocol::Proposal_State_descriptor();
}
template <> struct is_proto_enum< ::protocol::MarketOrder_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::MarketOrder_State>() {
  return ::protocol::MarketOrder_State_descriptor();
}
template <> struct is_proto_enum< ::protocol::Permission_PermissionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Permission_PermissionType>() {
  return ::protocol::Permission_PermissionType_descriptor();
}
template <> struct is_proto_enum< ::protocol::Transaction_Contract_ContractType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Transaction_Contract_ContractType>() {
  return ::protocol::Transaction_Contract_ContractType_descriptor();
}
template <> struct is_proto_enum< ::protocol::Transaction_Result_code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Transaction_Result_code>() {
  return ::protocol::Transaction_Result_code_descriptor();
}
template <> struct is_proto_enum< ::protocol::Transaction_Result_contractResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Transaction_Result_contractResult>() {
  return ::protocol::Transaction_Result_contractResult_descriptor();
}
template <> struct is_proto_enum< ::protocol::TransactionInfo_code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TransactionInfo_code>() {
  return ::protocol::TransactionInfo_code_descriptor();
}
template <> struct is_proto_enum< ::protocol::BlockInventory_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::BlockInventory_Type>() {
  return ::protocol::BlockInventory_Type_descriptor();
}
template <> struct is_proto_enum< ::protocol::Inventory_InventoryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Inventory_InventoryType>() {
  return ::protocol::Inventory_InventoryType_descriptor();
}
template <> struct is_proto_enum< ::protocol::Items_ItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Items_ItemType>() {
  return ::protocol::Items_ItemType_descriptor();
}
template <> struct is_proto_enum< ::protocol::PBFTMessage_MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::PBFTMessage_MsgType>() {
  return ::protocol::PBFTMessage_MsgType_descriptor();
}
template <> struct is_proto_enum< ::protocol::PBFTMessage_DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::PBFTMessage_DataType>() {
  return ::protocol::PBFTMessage_DataType_descriptor();
}
template <> struct is_proto_enum< ::protocol::AccountType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::AccountType>() {
  return ::protocol::AccountType_descriptor();
}
template <> struct is_proto_enum< ::protocol::ReasonCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ReasonCode>() {
  return ::protocol::ReasonCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_core_2fTron_2eproto
